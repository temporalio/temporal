name: All Tests

on:
  pull_request:
  push:
    branches:
      - main
      - cloud/*
      - feature/*
      - release/*

permissions:
  contents: read

concurrency: # Auto-cancel existing runs in the PR when a new commit is pushed
  group: run-tests-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

env:
  # For pull_request: use the head of the PR branch (not the merge branch which is the default!)
  # For push: use the pushed commit.
  COMMIT: ${{ github.event.pull_request.head.sha || github.sha }}
  PR_BASE_COMMIT: ${{ github.event.pull_request.base.sha }}
  DOCKER_COMPOSE_FILE: ./develop/github/docker-compose.yml
  TEMPORAL_VERSION_CHECK_DISABLED: 1

jobs:
  test-setup:
    name: Test setup
    runs-on: ubuntu-latest
    outputs:
      job_matrix: ${{ steps.compute_matrix.outputs.job_matrix }}
      full_test_reason: ${{ steps.compute_matrix.outputs.full_test_reason }}
      runner_x64: ${{ steps.compute_matrix.outputs.runner_x64 }}
      runner_arm: ${{ steps.compute_matrix.outputs.runner_arm }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ env.COMMIT }}
          fetch-depth: 0

      - name: Fetch base branch
        if: ${{ github.event_name == 'pull_request' }}
        run: git fetch origin ${{ github.event.pull_request.base.ref }}:${{ github.event.pull_request.base.ref }}

      - name: Compute merge base
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          MERGE_BASE="$(git merge-base "${{ env.COMMIT }}" "${{ github.event.pull_request.base.ref }}")"
          echo "MERGE_BASE=${MERGE_BASE}" >> "$GITHUB_ENV"

      # Primary DBs always get full tests (5 shards), extended DBs get smoke tests (1 shard) in abridged PRs.
      - name: Compute database matrix
        id: compute_matrix
        run: |
          # DB configurations: name -> {persistence_type, persistence_driver, containers}
          declare -A DB_CONFIG
          DB_CONFIG[cass_es]='{"persistence_type":"nosql","persistence_driver":"cassandra","containers":["cassandra","elasticsearch"]}'
          DB_CONFIG[cass_es8]='{"persistence_type":"nosql","persistence_driver":"cassandra","containers":["cassandra","elasticsearch8"]}'
          DB_CONFIG[cass_os2]='{"persistence_type":"nosql","persistence_driver":"cassandra","containers":["cassandra","opensearch2"]}'
          DB_CONFIG[cass_os3]='{"persistence_type":"nosql","persistence_driver":"cassandra","containers":["cassandra","opensearch3"]}'
          DB_CONFIG[sqlite]='{"persistence_type":"sql","persistence_driver":"sqlite","containers":[],"arch":"arm"}'
          DB_CONFIG[mysql8]='{"persistence_type":"sql","persistence_driver":"mysql8","containers":["mysql"]}'
          DB_CONFIG[postgres12]='{"persistence_type":"sql","persistence_driver":"postgres12","containers":["postgresql"]}'
          DB_CONFIG[postgres12_pgx]='{"persistence_type":"sql","persistence_driver":"postgres12_pgx","containers":["postgresql"]}'

          # Testing one NoSQL and one SQL database
          PRIMARY_DBS=("cass_os3" "sqlite")
          EXTENDED_DBS=("cass_es" "cass_es8" "cass_os2" "mysql8" "postgres12" "postgres12_pgx")

          # Smoke tests are a small subset of the full test suite
          SMOKE_TESTS=(
            "TestWorkflowTestSuite"
            "TestSignalWorkflowTestSuite"
            "TestActivityTestSuite/TestActivityHeartBeatWorkflow_Success"
          )
          SMOKE_TEST_ARGS="'-run=$(IFS='|'; echo "${SMOKE_TESTS[*]}")'"

          ## Determine if this is a full or abridged (smoke) test run

          FULL_TEST_REASON=""

          # Push events (main, release branches) run all tests on all DBs
          if [[ "${{ github.event_name }}" == "push" ]]; then
            FULL_TEST_REASON="Running full tests on all DBs (push event)."
          # Check for test-all-dbs label
          elif echo '${{ toJson(github.event.pull_request.labels.*.name) }}' | jq -e 'any(. == "test-all-dbs")' > /dev/null 2>&1; then
            FULL_TEST_REASON="Running full tests on all DBs (test-all-dbs label)."
          # Check for persistence code changes
          elif [[ -n "${MERGE_BASE:-}" ]] && git diff --name-only "$MERGE_BASE" "$COMMIT" | grep -qE "^(common/persistence/|schema/)"; then
            FULL_TEST_REASON="Running full tests on all DBs (persistence code changes)."
          fi

          ## Build job matrix

          MATRIX="[]"

          # Add 5 jobs per DB: tests 1-3 (sharded functional tests), ndc, xdc
          add_full_jobs() {
            local db=$1
            local config=${DB_CONFIG[$db]}

            # Tests 1-3: regular functional tests with sharding
            for shard in 1 2 3; do
              MATRIX=$(jq -c \
                ". + [\$config + {
                  name: \"$db\",
                  display_name: \"shard $shard\",
                  cmd: \"make functional-test-coverage\",
                  shard_index: $((shard - 1)),
                  total_shards: 3,
                  test_timeout: \"35m\",
                  github_timeout: 40
                }]" \
                --argjson config "$config" \
                <<< "$MATRIX")
            done

            # NDC
            MATRIX=$(jq -c \
              ". + [\$config + {
                name: \"$db\",
                display_name: \"ndc\",
                cmd: \"make functional-test-ndc-coverage\",
                test_timeout: \"15m\",
                github_timeout: 20
              }]" \
              --argjson config "$config" \
              <<< "$MATRIX")

            # XDC
            MATRIX=$(jq -c \
              ". + [\$config + {
                name: \"$db\",
                display_name: \"xdc\",
                cmd: \"make functional-test-xdc-coverage\",
                test_timeout: \"35m\",
                github_timeout: 40
              }]" \
              --argjson config "$config" \
              <<< "$MATRIX")
          }

          add_smoke_job() {
            local db=$1
            local config=${DB_CONFIG[$db]}
            MATRIX=$(jq -c \
              ". + [\$config + {
                name: \"$db\",
                display_name: \"smoke\",
                cmd: \"make functional-test-coverage\",
                test_args: \$test_args,
                test_timeout: \"5m\",
                github_timeout: 10
              }]" \
              --argjson config "$config" \
              --arg test_args "$SMOKE_TEST_ARGS" \
              <<< "$MATRIX")
          }

          # Schedule jobs for primary databases
          for db in "${PRIMARY_DBS[@]}"; do
            add_full_jobs "$db"
          done

          # Schedule jobs for extended databases
          for db in "${EXTENDED_DBS[@]}"; do
            if [[ -n "$FULL_TEST_REASON" ]]; then
              add_full_jobs "$db"
            else
              add_smoke_job "$db"
            fi
          done

          # Runner configuration: use 8-core runners for temporalio org, standard runners for forks
          if [[ "${{ github.repository_owner }}" == "temporalio" ]]; then
            runner_x64="ubuntu-latest-8-cores"
            runner_arm="ubuntu-24.04-arm64-8-cores"
          else
            runner_x64="ubuntu-latest"
            runner_arm="ubuntu-24.04-arm"
          fi

          {
            echo "job_matrix=$MATRIX"
            echo "full_test_reason=$FULL_TEST_REASON"
            echo "runner_x64=$runner_x64"
            echo "runner_arm=$runner_arm"
          } >> "$GITHUB_OUTPUT"
          echo "Generated $(jq length <<< "$MATRIX") jobs"

      - name: ${{ steps.compute_matrix.outputs.full_test_reason && 'ℹ️ Full tests' || 'ℹ️ Smoke tests' }}
        run: echo "::notice::${{ steps.compute_matrix.outputs.full_test_reason || 'Running smoke tests on extended DBs. Add the test-all-dbs label to run all tests on all DBs.' }}"

  pre-build:
    name: Pre-build for cache (${{ matrix.arch }})
    needs: test-setup
    strategy:
      matrix:
        arch: [x64, arm]
    runs-on: ${{ matrix.arch == 'arm' && needs.test-setup.outputs.runner_arm || needs.test-setup.outputs.runner_x64 }}
    steps:
      - uses: actions/checkout@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ env.COMMIT }}

      - uses: actions/setup-go@v6
        with:
          go-version-file: "go.mod"
          cache: false # do our own caching

      - name: Restore dependencies
        id: restore-deps
        uses: actions/cache/restore@v4
        with:
          path: ~/go/pkg/mod
          key: go-${{ runner.os }}${{ runner.arch }}-${{ hashFiles('go.mod') }}-deps-${{ hashFiles('go.sum') }}

      - name: Save dependencies
        uses: actions/cache/save@v4
        if: ${{ steps.restore-deps.outputs.cache-hit != 'true' }}
        with:
          path: ~/go/pkg/mod
          key: ${{ steps.restore-deps.outputs.cache-primary-key }}

      - name: Save build outputs
        uses: actions/cache/save@v4
        with:
          path: ~/.cache/go-build
          key: go-${{ runner.os }}${{ runner.arch }}-build-${{ env.COMMIT }}

  misc-checks:
    name: Misc checks
    needs: [pre-build, test-setup]
    runs-on: ${{ needs.test-setup.outputs.runner_arm }}
    steps:
      - uses: actions/checkout@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ env.COMMIT }}
          # buf-breaking tries to compare HEAD against merge base so we need to be able to find it
          fetch-depth: 100

      - uses: actions/setup-go@v6
        with:
          go-version-file: "go.mod"
          cache: false # do our own caching

      - name: Restore dependencies
        uses: actions/cache/restore@v4
        with:
          path: ~/go/pkg/mod
          key: go-${{ runner.os }}${{ runner.arch }}-${{ hashFiles('go.mod') }}-deps-${{ hashFiles('go.sum') }}

      - name: Restore build outputs
        uses: actions/cache/restore@v4
        with:
          path: ~/.cache/go-build
          key: go-${{ runner.os }}${{ runner.arch }}-build-${{ env.COMMIT }}

      - uses: arduino/setup-protoc@v3
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}

      - run: GOOS=windows GOARCH=amd64 make clean-bins bins

      - run: GOOS=darwin GOARCH=arm64 make clean-bins bins

      - run: make clean-bins ci-build-misc

  unit-test:
    name: Unit test
    needs: [pre-build, test-setup]
    runs-on: ${{ needs.test-setup.outputs.runner_arm }}
    steps:
      - uses: actions/checkout@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ env.COMMIT }}

      - uses: actions/setup-go@v6
        with:
          go-version-file: "go.mod"
          cache: false # do our own caching

      - name: Restore dependencies
        uses: actions/cache/restore@v4
        with:
          path: ~/go/pkg/mod
          key: go-${{ runner.os }}${{ runner.arch }}-${{ hashFiles('go.mod') }}-deps-${{ hashFiles('go.sum') }}

      - name: Restore build outputs
        uses: actions/cache/restore@v4
        with:
          path: ~/.cache/go-build
          key: go-${{ runner.os }}${{ runner.arch }}-build-${{ env.COMMIT }}

      - name: Run unit tests
        timeout-minutes: 20
        run: go mod download && ./develop/github/monitor_test.sh make unit-test-coverage

      - name: Upload test logs
        if: always()
        uses: actions/upload-artifact@v4.4.3
        with:
          name: test-logs--unit-test
          path: ./.testoutput/*.log
          include-hidden-files: true
          if-no-files-found: ignore
          retention-days: 28

      - name: Generate test summary
        uses: mikepenz/action-junit-report@v5.0.0-rc01
        if: failure()
        with:
          report_paths: ./.testoutput/junit.*.xml
          detailed_summary: true
          check_annotations: false
          annotate_only: true
          skip_annotations: true

      - name: Upload code coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          directory: ./.testoutput
          flags: unit-test

      - name: Upload test results to Codecov
        if: ${{ !cancelled() }}
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          directory: ./.testoutput
          flags: unit-test
          report_type: test_results

      - name: Upload test results to GitHub
        # Can't pin to major because the action linter doesn't recognize the include-hidden-files flag.
        uses: actions/upload-artifact@v4.4.3
        if: ${{ !cancelled() }}
        with:
          name: junit-xml--${{github.run_id}}--${{github.run_attempt}}--unit-test
          path: ./.testoutput/junit.*.xml
          include-hidden-files: true
          retention-days: 28

  integration-test:
    name: Integration test
    needs: [pre-build, test-setup]
    runs-on: ${{ needs.test-setup.outputs.runner_x64 }}
    steps:
      - uses: actions/checkout@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ env.COMMIT }}

      - name: Start containerized dependencies
        uses: hoverkraft-tech/compose-action@v2.0.1
        with:
          compose-file: ${{ env.DOCKER_COMPOSE_FILE }}
          services: |
            cassandra
            mysql
            postgresql
          down-flags: -v

      - uses: actions/setup-go@v6
        with:
          go-version-file: "go.mod"
          cache: false # do our own caching

      - name: Restore dependencies
        uses: actions/cache/restore@v4
        with:
          path: ~/go/pkg/mod
          key: go-${{ runner.os }}${{ runner.arch }}-${{ hashFiles('go.mod') }}-deps-${{ hashFiles('go.sum') }}

      - name: Restore build outputs
        uses: actions/cache/restore@v4
        with:
          path: ~/.cache/go-build
          key: go-${{ runner.os }}${{ runner.arch }}-build-${{ env.COMMIT }}

      - name: Run integration test
        timeout-minutes: 15
        run: go mod download && ./develop/github/monitor_test.sh make integration-test-coverage

      - name: Upload test logs
        if: always()
        uses: actions/upload-artifact@v4.4.3
        with:
          name: test-logs--integration-test
          path: ./.testoutput/*.log
          include-hidden-files: true
          if-no-files-found: ignore
          retention-days: 28

      - name: Generate test summary
        uses: mikepenz/action-junit-report@v5.0.0-rc01
        if: failure()
        with:
          report_paths: ./.testoutput/junit.*.xml
          detailed_summary: true
          check_annotations: false
          annotate_only: true
          skip_annotations: true

      - name: Upload code coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          directory: ./.testoutput
          flags: integration-test

      - name: Upload test results to Codecov
        if: ${{ !cancelled() }}
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          directory: ./.testoutput
          flags: integration-test
          report_type: test_results

      - name: Upload test results to GitHub
        # Can't pin to major because the action linter doesn't recognize the include-hidden-files flag.
        uses: actions/upload-artifact@v4.4.3
        if: ${{ !cancelled() }}
        with:
          name: junit-xml--${{github.run_id}}--${{github.run_attempt}}--integration-test
          path: ./.testoutput/junit.*.xml
          include-hidden-files: true
          retention-days: 28

      - name: Tear down docker compose
        if: ${{ always() }}
        run: |
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} down -v

  # Root job name includes matrix details so it is unique per shard/smoke test.
  # This MUST stay in sync with the `job_name` passed to the job-id action below.
  functional-test:
    # Display name shown in the UI. The job-id lookup uses this exact value.
    name: Functional test (${{ matrix.name }}, ${{ matrix.display_name }})
    needs: [pre-build, test-setup]
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.test-setup.outputs.job_matrix) }}
    runs-on: ${{ matrix.arch == 'arm' && needs.test-setup.outputs.runner_arm || needs.test-setup.outputs.runner_x64 }}
    env:
      PERSISTENCE_TYPE: ${{ matrix.persistence_type }}
      PERSISTENCE_DRIVER: ${{ matrix.persistence_driver }}
      TEST_TIMEOUT: ${{ matrix.test_timeout }}
      TEST_RUNNER_WORKERS: ${{ startsWith(matrix.name, 'cass_') && '4' || '' }}
    steps:
      - uses: ScribeMD/docker-cache@0.3.7
        with:
          key: docker-${{ runner.os }}${{ runner.arch }}-${{ hashFiles(env.DOCKER_COMPOSE_FILE) }}

      - uses: actions/checkout@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ env.COMMIT }}

      - name: Start containerized dependencies
        if: ${{ toJson(matrix.containers) != '[]' }}
        uses: hoverkraft-tech/compose-action@v2.0.1
        with:
          compose-file: ${{ env.DOCKER_COMPOSE_FILE }}
          services: "${{ join(matrix.containers, '\n') }}"
          down-flags: -v

      - uses: actions/setup-go@v6
        with:
          go-version-file: "go.mod"
          cache: false # do our own caching

      - name: Restore dependencies
        uses: actions/cache/restore@v4
        with:
          path: ~/go/pkg/mod
          key: go-${{ runner.os }}${{ runner.arch }}-${{ hashFiles('go.mod') }}-deps-${{ hashFiles('go.sum') }}

      - name: Restore build outputs
        uses: actions/cache/restore@v4
        with:
          path: ~/.cache/go-build
          key: go-${{ runner.os }}${{ runner.arch }}-build-${{ env.COMMIT }}

      - name: Get job ID
        id: get_job_id
        uses: ./.github/actions/get-job-id
        with:
          job_name: Functional test (${{ matrix.name }}, ${{ matrix.display_name }})
          run_id: ${{ github.run_id }}

      - name: ${{ matrix.display_name == 'smoke' && 'ℹ️ Smoke test' || 'ℹ️ Full test' }}
        run: echo "::notice::${{ matrix.display_name == 'smoke' && 'This is a smoke test. Add the test-all-dbs label to run all tests on all DBs.' || needs.test-setup.outputs.full_test_reason }}"

      - name: Run functional test
        timeout-minutes: ${{ matrix.github_timeout }}
        run: go mod download && ./develop/github/monitor_test.sh ${{ matrix.cmd }}
        env:
          TEST_RUNNER_SHARDS_TOTAL: ${{ matrix.total_shards || '' }}
          TEST_RUNNER_SHARD_INDEX: ${{ matrix.shard_index || '' }}
          TEST_ARGS: ${{ matrix.test_args || '' }}

      - name: Print memory snapshot
        if: always()
        run: if [ -f /tmp/memory_snapshot.txt ]; then cat /tmp/memory_snapshot.txt; fi

      - name: Upload test logs
        if: always()
        uses: actions/upload-artifact@v4.4.3
        with:
          name: test-logs--${{matrix.name}}--${{matrix.display_name}}
          path: ./.testoutput/*.log
          include-hidden-files: true
          if-no-files-found: ignore
          retention-days: 28

      - name: Generate test summary
        uses: mikepenz/action-junit-report@v5.0.0-rc01
        if: failure()
        with:
          report_paths: ./.testoutput/junit.*.xml
          detailed_summary: true
          check_annotations: false
          annotate_only: true
          skip_annotations: true

      - name: Upload code coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          directory: ./.testoutput
          flags: functional-test

      - name: Upload test results to Codecov
        if: ${{ !cancelled() }}
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          directory: ./.testoutput
          flags: functional-test
          report_type: test_results

      - name: Upload test results to GitHub
        # Can't pin to major because the action linter doesn't recognize the include-hidden-files flag.
        uses: actions/upload-artifact@v4.4.3
        if: ${{ !cancelled() }}
        with:
          name: junit-xml--${{github.run_id}}--${{ steps.get_job_id.outputs.job_id }}--${{github.run_attempt}}--${{matrix.name}}--${{ matrix.display_name }}--functional-test
          path: ./.testoutput/junit.*.xml
          include-hidden-files: true
          retention-days: 28

  list-test-logs:
    name: List test logs
    if: always()
    needs: [unit-test, integration-test, functional-test]
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.list.outputs.matrix }}
    steps:
      - name: Download all test log artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: test-logs--*
          path: ./logs

      - name: List log files
        id: list
        run: |
          MATRIX="[]"
          for dir in ./logs/test-logs--*/; do
            [ -d "$dir" ] || continue
            artifact=$(basename "$dir")
            for f in "$dir"*.log; do
              [ -s "$f" ] || continue
              name=$(basename "$f")
              MATRIX=$(jq -c \
                '. + [{"artifact": $a, "file": $f}]' \
                --arg a "$artifact" --arg f "$name" \
                <<< "$MATRIX")
            done
          done
          echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"
          echo "Found $(jq length <<< "$MATRIX") log files"

  print-test-log:
    name: "Log: ${{ matrix.file }}"
    if: always() && needs.list-test-logs.outputs.matrix != '[]'
    needs: list-test-logs
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.list-test-logs.outputs.matrix) }}
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.artifact }}

      - name: Print log
        run: cat "${{ matrix.file }}"

  test-status:
    if: always()
    name: Test Status
    needs:
      - misc-checks
      - unit-test
      - integration-test
      - functional-test
    runs-on: ubuntu-latest
    env:
      RESULTS: ${{ toJSON(needs.*.result) }}
    steps:
      - name: Check results
        run: |
          # all statuses must be success
          if [[ -n $(echo "$RESULTS" | jq '.[] | select (. != "success")') ]]; then
            exit 1
          fi

  notify-failure:
    name: Notify Slack on Failure
    if: |
      always() &&
      github.ref == 'refs/heads/main' &&
      needs.test-status.result == 'failure'
    needs: test-status
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: "go.mod"
          cache: true

      - name: Send Slack notification
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          GH_TOKEN: ${{ github.token }}
        run: |
          go run ./cmd/tools/ci-notify alert \
            --run-id "${{ github.run_id }}" \
            --slack-webhook "$SLACK_WEBHOOK"
