package main

import (
	"archive/zip"
	"bufio"
	"flag"
	"fmt"
	"io"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/dgryski/go-farm"
)

// TestCase represents a parsed test case from JUnit XML
type TestCase struct {
	ClassName string  `xml:"classname,attr"`
	Name      string  `xml:"name,attr"`
	Time      float64 `xml:"time,attr"`
}

// TestSuite represents a test suite containing test cases
type TestSuite struct {
	TestCases []TestCase `xml:"testcase"`
}

// ShardResult represents the result of a sharding attempt
type ShardResult struct {
	Salt    string
	MaxTime float64
}

const (
	defaultLevel = 2 // 1 means shard by suite, 2 means shard by test
)

var (
	// Level overrides. If not present, sharding is based on the defaultLevel
	targetLevel = make(map[string]int)
)

func main() {
	shards := flag.Int("s", 4, "Number of shards")
	tries := flag.Int("t", 10000, "Number of tries")
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [options] <FILES>...\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "Optimizes the seed/salt selection for Github CI test sharding\n\n")
		fmt.Fprintf(os.Stderr, "JUnit XML files can be generated by using `gotestsum` as your test runner.\n\n")
		flag.PrintDefaults()
	}
	flag.Parse()

	if flag.NArg() == 0 {
		flag.Usage()
		os.Exit(1)
	}

	tmap, err := loadTestData(flag.Args())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading test data: %v\n", err)
		os.Exit(1)
	}

	smap := aggregateByLevel(tmap)
	times := optimizeShardingSalt(smap, *shards, *tries)

	// Sort by time and display results
	var results []ShardResult
	for salt, maxTime := range times {
		results = append(results, ShardResult{Salt: salt, MaxTime: maxTime})
	}

	sort.Slice(results, func(i, j int) bool {
		return results[i].MaxTime < results[j].MaxTime
	})

	fmt.Println("Seed\tEstimated Runtime")
	limit := min(len(results), 25)
	for i := range limit {
		fmt.Printf("%s\t%f\n", results[i].Salt, results[i].MaxTime)
	}
}

func loadTestData(files []string) (map[string][]float64, error) {
	tmap := make(map[string][]float64)

	for _, filename := range files {
		if strings.HasSuffix(filename, ".zip") {
			if err := processZip(filename, tmap); err != nil {
				return nil, fmt.Errorf("processing zip file %s: %w", filename, err)
			}
		} else if strings.HasSuffix(filename, ".xml") {
			if err := processXML(filename, tmap); err != nil {
				return nil, fmt.Errorf("processing xml file %s: %w", filename, err)
			}
		} else {
			return nil, fmt.Errorf("unknown file type: %s", filename)
		}
	}

	return tmap, nil
}

func processZip(filename string, tmap map[string][]float64) error {
	r, err := zip.OpenReader(filename)
	if err != nil {
		return err
	}
	defer r.Close()

	for _, f := range r.File {
		if !strings.HasSuffix(f.Name, ".xml") {
			continue
		}

		rc, err := f.Open()
		if err != nil {
			return err
		}

		if err := processXMLReader(rc, tmap); err != nil {
			rc.Close()
			return err
		}
		rc.Close()
	}

	return nil
}

func processXML(filename string, tmap map[string][]float64) error {
	file, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	return processXMLReader(file, tmap)
}

// While it's well-known that using regular expressions to parse XML will result
// in z̷a̸l̵g̵o̴ ̸t̴e̸x̷t̴ it's fine here as we're doing so little.
var testcaseRegex = regexp.MustCompile(`<testcase classname="([^"]*)" name="([^"]*)" time="([^"]*)"></testcase>`)

func processXMLReader(reader io.Reader, tmap map[string][]float64) error {
	scanner := bufio.NewScanner(reader)
	for scanner.Scan() {
		line := scanner.Text()
		matches := testcaseRegex.FindStringSubmatch(line)
		if len(matches) == 4 {
			name := matches[2]
			timeStr := matches[3]

			time, err := strconv.ParseFloat(timeStr, 64)
			if err != nil {
				continue // Skip invalid time values
			}

			tmap[name] = append(tmap[name], time)
		}
	}

	return scanner.Err()
}

func aggregateByLevel(tmap map[string][]float64) map[string]float64 {
	smap := make(map[string]float64)

	for name, times := range tmap {
		// Find maximum time for this test
		maxTime := 0.0
		for _, t := range times {
			if t > maxTime {
				maxTime = t
			}
		}

		// Split name by '/' to determine level
		nameParts := strings.Split(name, "/")
		level := len(nameParts)
		suite := nameParts[0]

		// Check target level for this suite
		targetLevelForSuite, exists := targetLevel[suite]
		if !exists {
			targetLevelForSuite = defaultLevel
		}

		if level == targetLevelForSuite {
			smap[name] = maxTime
		}
	}

	return smap
}

func optimizeShardingSalt(smap map[string]float64, shards, tries int) map[string]float64 {
	times := make(map[string]float64)

	for s := range tries {
		totals := make([]float64, shards)
		saltStr := fmt.Sprintf("-salt-%d", s)

		for testName, testTime := range smap {
			keyWithSalt := testName + saltStr

			hash := farm.Fingerprint32([]byte(keyWithSalt))
			shardIndex := int(hash) % shards
			if shardIndex < 0 {
				shardIndex = -shardIndex
			}

			totals[shardIndex] += testTime
		}

		// Find maximum time across all shards
		var maxTime float64
		for _, total := range totals {
			if total > maxTime {
				maxTime = total
			}
		}

		times[saltStr] = maxTime
	}

	return times
}
