package optimizetestsharding

import (
	"archive/zip"
	"bufio"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/dgryski/go-farm"
)

// ShardResult represents the result of a sharding attempt.
type ShardResult struct {
	Salt    string
	MaxTime float64
}

func Run() {
	shards := flag.Int("s", 3, "Number of shards")
	tries := flag.Int("t", 10000, "Number of tries")
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [options] <FILES>...\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "Optimizes the salt selection for functional test sharding.\n\n")
		fmt.Fprintf(os.Stderr, "Accepts JUnit XML files (generated by gotestsum) or ZIP archives.\n")
		fmt.Fprintf(os.Stderr, "Aggregates test times at the suite level (first component of test name)\n")
		fmt.Fprintf(os.Stderr, "and finds the salt that minimizes the maximum shard time.\n\n")
		flag.PrintDefaults()
	}
	flag.Parse()

	if flag.NArg() == 0 {
		flag.Usage()
		os.Exit(1)
	}

	tmap, err := loadTestData(flag.Args())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading test data: %v\n", err)
		os.Exit(1)
	}

	smap := aggregateBySuite(tmap)
	if len(smap) == 0 {
		fmt.Fprintf(os.Stderr, "No suite-level test data found\n")
		os.Exit(1)
	}

	results := optimizeShardingSalt(smap, *shards, *tries)

	sort.Slice(results, func(i, j int) bool {
		return results[i].MaxTime < results[j].MaxTime
	})

	if len(results) == 0 {
		os.Exit(1)
	}
	fmt.Println(results[0].Salt)
}

func loadTestData(paths []string) (map[string][]float64, error) {
	tmap := make(map[string][]float64)

	var files []string
	for _, pattern := range paths {
		matches, err := filepath.Glob(pattern)
		if err != nil {
			return nil, fmt.Errorf("invalid glob pattern %s: %w", pattern, err)
		}
		if len(matches) > 0 {
			files = append(files, matches...)
		}
	}
	if len(files) == 0 {
		return nil, fmt.Errorf("no files found")
	}

	for _, filename := range files {
		if strings.HasSuffix(filename, ".zip") {
			if err := processZip(filename, tmap); err != nil {
				return nil, fmt.Errorf("processing zip file %s: %w", filename, err)
			}
		} else if strings.HasSuffix(filename, ".xml") {
			if err := processXML(filename, tmap); err != nil {
				return nil, fmt.Errorf("processing xml file %s: %w", filename, err)
			}
		} else {
			return nil, fmt.Errorf("unknown file type: %s", filename)
		}
	}

	return tmap, nil
}

func processZip(filename string, tmap map[string][]float64) error {
	r, err := zip.OpenReader(filename)
	if err != nil {
		return err
	}
	defer r.Close()

	for _, f := range r.File {
		if !strings.HasSuffix(f.Name, ".xml") {
			continue
		}

		rc, err := f.Open()
		if err != nil {
			return err
		}

		if err := processXMLReader(rc, tmap); err != nil {
			rc.Close()
			return err
		}
		rc.Close()
	}

	return nil
}

func processXML(filename string, tmap map[string][]float64) error {
	file, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	return processXMLReader(file, tmap)
}

// While it's well-known that using regular expressions to parse XML will result
// in z̷a̸l̵g̵o̴ ̸t̴e̸x̷t̴ it's fine here as we're doing so little.
var testcaseRegex = regexp.MustCompile(`<testcase classname="([^"]*)" name="([^"]*)" time="([^"]*)"></testcase>`)

func processXMLReader(reader io.Reader, tmap map[string][]float64) error {
	scanner := bufio.NewScanner(reader)
	for scanner.Scan() {
		line := scanner.Text()
		matches := testcaseRegex.FindStringSubmatch(line)
		if len(matches) == 4 {
			name := matches[2]
			timeStr := matches[3]

			time, err := strconv.ParseFloat(timeStr, 64)
			if err != nil {
				continue // Skip invalid time values
			}

			tmap[name] = append(tmap[name], time)
		}
	}

	return scanner.Err()
}

// aggregateBySuite groups test times by suite name (first component before "/").
// Only entries with a "/" are considered (individual test methods), to avoid
// double-counting with parent suite-level entries that JUnit XML may include.
func aggregateBySuite(tmap map[string][]float64) map[string]float64 {
	smap := make(map[string]float64)

	for name, times := range tmap {
		idx := strings.Index(name, "/")
		if idx < 0 {
			// Skip entries without "/" — these are suite-level totals
			// that would double-count individual test times.
			continue
		}
		suiteName := name[:idx]

		// Use the maximum observed time for this test method.
		maxTime := 0.0
		for _, t := range times {
			if t > maxTime {
				maxTime = t
			}
		}

		smap[suiteName] += maxTime
	}

	return smap
}

func optimizeShardingSalt(smap map[string]float64, shards, tries int) []ShardResult {
	results := make([]ShardResult, 0, tries)

	for s := range tries {
		totals := make([]float64, shards)
		saltStr := fmt.Sprintf("-salt-%d", s)

		for suiteName, suiteTime := range smap {
			keyWithSalt := suiteName + saltStr

			hash := farm.Fingerprint32([]byte(keyWithSalt))
			shardIndex := int(hash) % shards
			if shardIndex < 0 {
				shardIndex = -shardIndex
			}

			totals[shardIndex] += suiteTime
		}

		// Find maximum time across all shards
		var maxTime float64
		for _, total := range totals {
			if total > maxTime {
				maxTime = total
			}
		}

		results = append(results, ShardResult{Salt: saltStr, MaxTime: maxTime})
	}

	return results
}
