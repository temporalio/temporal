package testrunner2

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"strings"
	"sync"
	"time"
)

type testEventAction string

const (
	actionRun   testEventAction = "run"
	actionPass  testEventAction = "pass"
	actionFail  testEventAction = "fail"
	actionSkip  testEventAction = "skip"
	actionStuck testEventAction = "stuck"
)

type testEvent struct {
	Action testEventAction
	Test   string // "TestFoo" or "TestFoo/Sub1"
}

type testEventStreamConfig struct {
	Writer         io.Writer          // underlying writer (logCapture)
	Handler        func(testEvent)    // called for each lifecycle event
	StuckThreshold time.Duration      // per-test: cancel when a single test runs longer than this (0 = disabled)
	StuckCancel    context.CancelFunc // cancel when stuck detected
	Log            func(format string, v ...any)
}

type testEventStream struct {
	w       io.Writer
	handler func(testEvent)

	// Stuck test monitoring
	threshold time.Duration      // per-test stuck threshold
	cancel    context.CancelFunc // cancel when stuck detected
	log       func(format string, v ...any)

	mu          sync.Mutex
	running     map[string]time.Time
	retried     map[string]bool // tests with retries already emitted (from actionFail or actionStuck)
	stuckAlerts []alert         // alerts generated by stuck detection
	lineBuf     []byte
	closed      chan struct{}
}

func newTestEventStream(cfg testEventStreamConfig) *testEventStream {
	s := &testEventStream{
		w:         cfg.Writer,
		handler:   cfg.Handler,
		threshold: cfg.StuckThreshold,
		cancel:    cfg.StuckCancel,
		log:       cfg.Log,
		running:   make(map[string]time.Time),
		retried:   make(map[string]bool),
		closed:    make(chan struct{}),
	}
	if s.threshold > 0 {
		go s.watchLoop()
	}
	return s
}

// Write passes data through to the underlying writer while parsing test events.
func (s *testEventStream) Write(p []byte) (int, error) {
	s.mu.Lock()
	s.lineBuf = append(s.lineBuf, p...)
	s.processLines()
	s.mu.Unlock()
	return s.w.Write(p)
}

func (s *testEventStream) processLines() {
	for {
		idx := bytes.IndexByte(s.lineBuf, '\n')
		if idx < 0 {
			break
		}
		line := s.lineBuf[:idx]
		s.lineBuf = s.lineBuf[idx+1:]
		s.parseLine(line)
	}
}

// parseLine extracts test lifecycle events from verbose test output.
// Handles both plain `go test -v` output and `-test.v=test2json` format
// (which prefixes event lines with 0x16 SYN characters).
func (s *testEventStream) parseLine(line []byte) {
	str := strings.TrimLeft(string(line), "\x16")
	str = strings.TrimSpace(str)

	fields := strings.Fields(str)
	if len(fields) < 3 {
		return
	}

	var ev testEvent
	switch {
	case fields[0] == "===" && fields[1] == "RUN":
		ev = testEvent{Action: actionRun, Test: fields[2]}
		s.running[ev.Test] = time.Now()
	case fields[0] == "---" && fields[1] == "PASS:":
		ev = testEvent{Action: actionPass, Test: fields[2]}
		delete(s.running, ev.Test)
	case fields[0] == "---" && fields[1] == "FAIL:":
		ev = testEvent{Action: actionFail, Test: fields[2]}
		delete(s.running, ev.Test)
		// Mark as retried so stuck detector won't redundantly emit it
		s.retried[ev.Test] = true
	case fields[0] == "---" && fields[1] == "SKIP:":
		ev = testEvent{Action: actionSkip, Test: fields[2]}
		delete(s.running, ev.Test)
	default:
		return
	}

	// Reset ancestor timers on child activity so the stuck detector
	// measures time since last progress, not total runtime.
	s.resetAncestorTimers(ev.Test)

	if s.handler != nil {
		s.handler(ev)
	}
}

func (s *testEventStream) watchLoop() {
	ticker := time.NewTicker(time.Second)
	defer ticker.Stop()
	for {
		select {
		case <-s.closed:
			return
		case <-ticker.C:
			if s.emitStuckTests() {
				return
			}
		}
	}
}

// emitStuckTests checks for stuck tests, emits actionStuck events for each,
// and cancels the process when all remaining leaf tests have been retried.
// Returns true if the process was cancelled (goroutine should exit).
func (s *testEventStream) emitStuckTests() bool {
	s.mu.Lock()
	defer s.mu.Unlock()

	if s.threshold == 0 || len(s.running) == 0 {
		return false
	}

	now := time.Now()
	for name, started := range s.running {
		dur := now.Sub(started)
		if dur <= s.threshold || s.hasRunningChildren(name) {
			continue
		}
		if s.retried[name] {
			continue // already emitted via actionFail or a prior actionStuck
		}

		summary := fmt.Sprintf("test stuck: %s (no progress for %v)", name, dur.Round(time.Second))
		s.log("stuck test detected: %s (running for %v)", name, dur.Round(time.Second))
		s.retried[name] = true
		s.stuckAlerts = append(s.stuckAlerts, alert{
			Kind:    failureKindTimeout,
			Summary: summary,
			Tests:   []string{name},
		})

		if s.handler != nil {
			s.handler(testEvent{Action: actionStuck, Test: name})
		}
	}

	// Cancel when ALL remaining leaf tests in running have been retried
	if s.allRetriedOrParent() {
		s.cancel()
		return true
	}
	return false
}

// allRetriedOrParent returns true if every test in running is either retried
// or a parent of another running test (i.e., not a leaf).
func (s *testEventStream) allRetriedOrParent() bool {
	if len(s.running) == 0 {
		return false
	}
	for name := range s.running {
		if s.hasRunningChildren(name) {
			continue // parent, skip
		}
		if !s.retried[name] {
			return false
		}
	}
	return true
}

// resetAncestorTimers resets the running timer for all ancestors of the given
// test name. This ensures the stuck detector measures time since last child
// activity rather than total parent runtime.
func (s *testEventStream) resetAncestorTimers(name string) {
	now := time.Now()
	for {
		idx := strings.LastIndex(name, "/")
		if idx < 0 {
			break
		}
		name = name[:idx]
		if _, ok := s.running[name]; ok {
			s.running[name] = now
		}
	}
}

func (s *testEventStream) hasRunningChildren(name string) bool {
	prefix := name + "/"
	for other := range s.running {
		if strings.HasPrefix(other, prefix) {
			return true
		}
	}
	return false
}

// RunningTests returns leaf tests still in the running map (for post-exit crash recovery).
func (s *testEventStream) RunningTests() []string {
	s.mu.Lock()
	defer s.mu.Unlock()
	var names []string
	for name := range s.running {
		if !s.hasRunningChildren(name) {
			names = append(names, name)
		}
	}
	return names
}

// StuckAlerts returns alerts generated by stuck test detection.
// Safe to call after the process has exited (watchLoop no longer writes).
func (s *testEventStream) StuckAlerts() []alert {
	s.mu.Lock()
	defer s.mu.Unlock()
	return s.stuckAlerts
}

// Close stops the monitoring goroutine.
func (s *testEventStream) Close() {
	close(s.closed)
}
