{{- /*gotype: go.temporal.io/server/cmd/tools/gendynamicconfig.dynamicConfigData*/ -}}
// Code generated by cmd/tools/gendynamicconfig. DO NOT EDIT.

package dynamicconfig

import (
	"time"

	enumspb "go.temporal.io/api/enums/v1"
	enumsspb "go.temporal.io/server/api/enums/v1"
	"go.temporal.io/server/common/namespace"
)

const (
	PrecedenceUnknown Precedence = iota
{{- range .Precedences}}
	Precedence{{.Name}}
{{- end}}
)
{{$Precedences := .Precedences }}
{{- range $T :=.Types}}
{{- range $P := $Precedences}}
{{ if $T.IsGeneric -}}
type {{$P.Name}}TypedSetting[T any] setting[T, func({{$P.GoArgs}})]
type {{$P.Name}}TypedConstrainedDefaultSetting[T any] constrainedDefaultSetting[T, func({{$P.GoArgs}})]

// New{{$P.Name}}TypedSetting creates a setting that uses mapstructure to handle complex structured
// values. The value from dynamic config will be _merged_ over a deep copy of 'def'. Be very careful
// when using non-empty maps or slices as defaults, the result may not be what you want.
func New{{$P.Name}}TypedSetting[T any](key string, def T, description string) {{$P.Name}}TypedSetting[T] {
	// Warn on any shared structure used with ConvertStructure, even though we handle it by deep copying.
	warnDefaultSharedStructure(key, def)
	// If even deep copy won't even work, we should panic early. Do that by calling deep copy once here.
	_ = deepCopyForMapstructure(def)

	s := {{$P.Name}}TypedSetting[T]{
		key:         MakeKey(key),
		def:         def,
		convert:     ConvertStructure[T](def),
		description: description,
	}
	register(s)
	return s
}

// New{{$P.Name}}TypedSettingWithConverter creates a setting with a custom converter function.
func New{{$P.Name}}TypedSettingWithConverter[T any](key string, convert func(any) (T, error), def T, description string) {{$P.Name}}TypedSetting[T] {
	{{/* Do not warn on shared structure here, it's the converter's concern. */ -}}
	s := {{$P.Name}}TypedSetting[T]{
		key:         MakeKey(key),
		def:         def,
		convert:     convert,
		description: description,
	}
	register(s)
	return s
}

// New{{$P.Name}}TypedSettingWithConstrainedDefault creates a setting with a compound default value.
func New{{$P.Name}}TypedSettingWithConstrainedDefault[T any](key string, convert func(any) (T, error), cdef []TypedConstrainedValue[T], description string) {{$P.Name}}TypedConstrainedDefaultSetting[T] {
	{{/* Do not warn on shared structure here, it's the converter's concern. */ -}}
	s := {{$P.Name}}TypedConstrainedDefaultSetting[T]{
		key:         MakeKey(key),
		cdef:        cdef,
		convert:     convert,
		description: description,
	}
	register(s)
	return s
}

func (s {{$P.Name}}TypedSetting[T]) Key() Key               { return s.key }
func (s {{$P.Name}}TypedSetting[T]) Precedence() Precedence { return Precedence{{$P.Name}} }
func (s {{$P.Name}}TypedSetting[T]) Validate(v any) error {
	_, err := s.convert(v)
	return err
}

func (s {{$P.Name}}TypedConstrainedDefaultSetting[T]) Key() Key               { return s.key }
func (s {{$P.Name}}TypedConstrainedDefaultSetting[T]) Precedence() Precedence { return Precedence{{$P.Name}} }
func (s {{$P.Name}}TypedConstrainedDefaultSetting[T]) Validate(v any) error {
	_, err := s.convert(v)
	return err
}

func (s {{$P.Name}}TypedSetting[T]) WithDefault(v T) {{$P.Name}}TypedSetting[T] {
	newS := s
	newS.def = v
	{{/* The base setting should be registered so we do not register the return value here */ -}}
	return newS
}

{{if eq $P.Name "Global" -}}
type TypedPropertyFn[T any] func({{$P.GoArgs}}) T
{{- else -}}
type TypedPropertyFnWith{{$P.Name}}Filter[T any] func({{$P.GoArgs}}) T
{{- end}}

{{if eq $P.Name "Global" -}}
func (s {{$P.Name}}TypedSetting[T]) Get(c *Collection) TypedPropertyFn[T] {
{{- else -}}
func (s {{$P.Name}}TypedSetting[T]) Get(c *Collection) TypedPropertyFnWith{{$P.Name}}Filter[T] {
{{- end}}
	return func({{$P.GoArgs}}) T {
		prec := {{$P.Expr}}
		return matchAndConvert(
			c,
			s.key,
			s.def,
			s.convert,
			prec,
		)
	}
}

{{if eq $P.Name "Global" -}}
func (s {{$P.Name}}TypedConstrainedDefaultSetting[T]) Get(c *Collection) TypedPropertyFn[T] {
{{- else -}}
func (s {{$P.Name}}TypedConstrainedDefaultSetting[T]) Get(c *Collection) TypedPropertyFnWith{{$P.Name}}Filter[T] {
{{- end}}
	return func({{$P.GoArgs}}) T {
		prec := {{$P.Expr}}
		return matchAndConvertWithConstrainedDefault(
			c,
			s.key,
			s.cdef,
			s.convert,
			prec,
		)
	}
}

{{if eq $P.Name "Global" -}}
type TypedSubscribable[T any] func(callback func(T)) (v T, cancel func())
{{- else -}}
type TypedSubscribableWith{{$P.Name}}Filter[T any] func({{$P.GoArgs}}, callback func(T)) (v T, cancel func())
{{- end}}

{{if eq $P.Name "Global" -}}
func (s {{$P.Name}}TypedSetting[T]) Subscribe(c *Collection) TypedSubscribable[T] {
	return func(callback func(T)) (T, func()) {
{{- else -}}
func (s {{$P.Name}}TypedSetting[T]) Subscribe(c *Collection) TypedSubscribableWith{{$P.Name}}Filter[T] {
	return func({{$P.GoArgs}}, callback func(T)) (T, func()) {
{{- end}}
		prec := {{$P.Expr}}
		return subscribe(c, s.key, s.def, s.convert, prec, callback)
	}
}

func (s {{$P.Name}}TypedSetting[T]) dispatchUpdate(c *Collection, sub any, cvs []ConstrainedValue) {
	dispatchUpdate(
		c,
		s.key,
		s.convert,
		sub.(*subscription[T]),
		cvs,
	)
}

{{if eq $P.Name "Global" -}}
func (s {{$P.Name}}TypedConstrainedDefaultSetting[T]) Subscribe(c *Collection) TypedSubscribable[T] {
	return func(callback func(T)) (T, func()) {
		prec := {{$P.Expr}}
		return subscribeWithConstrainedDefault(c, s.key, s.cdef, s.convert, prec, callback)
	}
}
{{- else -}}
func (s {{$P.Name}}TypedConstrainedDefaultSetting[T]) Subscribe(c *Collection) TypedSubscribableWith{{$P.Name}}Filter[T] {
	return func({{$P.GoArgs}}, callback func(T)) (T, func()) {
		prec := {{$P.Expr}}
		return subscribeWithConstrainedDefault(c, s.key, s.cdef, s.convert, prec, callback)
	}
}
{{- end}}

func (s {{$P.Name}}TypedConstrainedDefaultSetting[T]) dispatchUpdate(c *Collection, sub any, cvs []ConstrainedValue) {
	dispatchUpdateWithConstrainedDefault(
		c,
		s.key,
		s.convert,
		sub.(*subscription[T]),
		cvs,
	)
}

{{if eq $P.Name "Global" -}}
func GetTypedPropertyFn[T any](value T) TypedPropertyFn[T] {
{{- else -}}
func GetTypedPropertyFnFilteredBy{{$P.Name}}[T any](value T) TypedPropertyFnWith{{$P.Name}}Filter[T] {
{{- end}}
	return func({{$P.GoArgs}}) T {
		return value
	}
}
{{else -}}
type {{$P.Name}}{{$T.Name}}Setting = {{$P.Name}}TypedSetting[{{$T.GoType}}]
type {{$P.Name}}{{$T.Name}}ConstrainedDefaultSetting = {{$P.Name}}TypedConstrainedDefaultSetting[{{$T.GoType}}]

func New{{$P.Name}}{{$T.Name}}Setting(key string, def {{$T.GoType}}, description string) {{$P.Name}}{{$T.Name}}Setting {
	return New{{$P.Name}}TypedSettingWithConverter[{{$T.GoType}}](key, convert{{$T.Name}}, def, description)
}

func New{{$P.Name}}{{$T.Name}}SettingWithConstrainedDefault(key string, cdef []TypedConstrainedValue[{{$T.GoType}}], description string) {{$P.Name}}{{$T.Name}}ConstrainedDefaultSetting {
	return New{{$P.Name}}TypedSettingWithConstrainedDefault[{{$T.GoType}}](key, convert{{$T.Name}}, cdef, description)
}

{{if eq $P.Name "Global" -}}
type {{$T.Name}}PropertyFn = TypedPropertyFn[{{$T.GoType}}]
{{- else -}}
type {{$T.Name}}PropertyFnWith{{$P.Name}}Filter = TypedPropertyFnWith{{$P.Name}}Filter[{{$T.GoType}}]
{{- end}}

{{if eq $P.Name "Global" -}}
func Get{{$T.Name}}PropertyFn(value {{$T.GoType}}) {{$T.Name}}PropertyFn {
	return GetTypedPropertyFn(value)
}
{{- else -}}
func Get{{$T.Name}}PropertyFnFilteredBy{{$P.Name}}(value {{$T.GoType}}) {{$T.Name}}PropertyFnWith{{$P.Name}}Filter {
	return GetTypedPropertyFnFilteredBy{{$P.Name}}(value)
}
{{- end}}
{{end }}{{/* if $T.IsGeneric */}}
{{- end}}{{/* range $T :=.Types */}}
{{- end}}{{/* range $P := $Precedences */}}
