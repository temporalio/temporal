// The MIT License (MIT)
// 
// Copyright (c) 2020 Uber Technologies, Inc.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Code generated by thriftrw v1.20.2. DO NOT EDIT.
// @generated

package shared

import (
	bytes "bytes"
	base64 "encoding/base64"
	json "encoding/json"
	fmt "fmt"
	multierr "go.uber.org/multierr"
	ptr "go.uber.org/thriftrw/ptr"
	thriftreflect "go.uber.org/thriftrw/thriftreflect"
	wire "go.uber.org/thriftrw/wire"
	zapcore "go.uber.org/zap/zapcore"
	math "math"
	strconv "strconv"
	strings "strings"
)

type ActivityType struct {
	Name *string `json:"name,omitempty"`
}

// ToWire translates a ActivityType struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ActivityType) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ActivityType struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ActivityType struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ActivityType
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ActivityType) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ActivityType
// struct.
func (v *ActivityType) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}

	return fmt.Sprintf("ActivityType{%v}", strings.Join(fields[:i], ", "))
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this ActivityType match the
// provided ActivityType.
//
// This function performs a deep comparison.
func (v *ActivityType) Equals(rhs *ActivityType) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ActivityType.
func (v *ActivityType) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *ActivityType) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *ActivityType) IsSetName() bool {
	return v != nil && v.Name != nil
}

type ArchivalStatus int32

const (
	ArchivalStatusDisabled ArchivalStatus = 0
	ArchivalStatusEnabled  ArchivalStatus = 1
)

// ArchivalStatus_Values returns all recognized values of ArchivalStatus.
func ArchivalStatus_Values() []ArchivalStatus {
	return []ArchivalStatus{
		ArchivalStatusDisabled,
		ArchivalStatusEnabled,
	}
}

// UnmarshalText tries to decode ArchivalStatus from a byte slice
// containing its name.
//
//   var v ArchivalStatus
//   err := v.UnmarshalText([]byte("DISABLED"))
func (v *ArchivalStatus) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "DISABLED":
		*v = ArchivalStatusDisabled
		return nil
	case "ENABLED":
		*v = ArchivalStatusEnabled
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "ArchivalStatus", err)
		}
		*v = ArchivalStatus(val)
		return nil
	}
}

// MarshalText encodes ArchivalStatus to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v ArchivalStatus) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("DISABLED"), nil
	case 1:
		return []byte("ENABLED"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ArchivalStatus.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v ArchivalStatus) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "DISABLED")
	case 1:
		enc.AddString("name", "ENABLED")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v ArchivalStatus) Ptr() *ArchivalStatus {
	return &v
}

// ToWire translates ArchivalStatus into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v ArchivalStatus) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes ArchivalStatus from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return ArchivalStatus(0), err
//   }
//
//   var v ArchivalStatus
//   if err := v.FromWire(x); err != nil {
//     return ArchivalStatus(0), err
//   }
//   return v, nil
func (v *ArchivalStatus) FromWire(w wire.Value) error {
	*v = (ArchivalStatus)(w.GetI32())
	return nil
}

// String returns a readable string representation of ArchivalStatus.
func (v ArchivalStatus) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "DISABLED"
	case 1:
		return "ENABLED"
	}
	return fmt.Sprintf("ArchivalStatus(%d)", w)
}

// Equals returns true if this ArchivalStatus value matches the provided
// value.
func (v ArchivalStatus) Equals(rhs ArchivalStatus) bool {
	return v == rhs
}

// MarshalJSON serializes ArchivalStatus into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v ArchivalStatus) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"DISABLED\""), nil
	case 1:
		return ([]byte)("\"ENABLED\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode ArchivalStatus from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *ArchivalStatus) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "ArchivalStatus")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "ArchivalStatus")
		}
		*v = (ArchivalStatus)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "ArchivalStatus")
	}
}

type CancelExternalWorkflowExecutionFailedCause int32

const (
	CancelExternalWorkflowExecutionFailedCauseUnknownExternalWorkflowExecution CancelExternalWorkflowExecutionFailedCause = 0
)

// CancelExternalWorkflowExecutionFailedCause_Values returns all recognized values of CancelExternalWorkflowExecutionFailedCause.
func CancelExternalWorkflowExecutionFailedCause_Values() []CancelExternalWorkflowExecutionFailedCause {
	return []CancelExternalWorkflowExecutionFailedCause{
		CancelExternalWorkflowExecutionFailedCauseUnknownExternalWorkflowExecution,
	}
}

// UnmarshalText tries to decode CancelExternalWorkflowExecutionFailedCause from a byte slice
// containing its name.
//
//   var v CancelExternalWorkflowExecutionFailedCause
//   err := v.UnmarshalText([]byte("UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION"))
func (v *CancelExternalWorkflowExecutionFailedCause) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION":
		*v = CancelExternalWorkflowExecutionFailedCauseUnknownExternalWorkflowExecution
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "CancelExternalWorkflowExecutionFailedCause", err)
		}
		*v = CancelExternalWorkflowExecutionFailedCause(val)
		return nil
	}
}

// MarshalText encodes CancelExternalWorkflowExecutionFailedCause to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v CancelExternalWorkflowExecutionFailedCause) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CancelExternalWorkflowExecutionFailedCause.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v CancelExternalWorkflowExecutionFailedCause) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v CancelExternalWorkflowExecutionFailedCause) Ptr() *CancelExternalWorkflowExecutionFailedCause {
	return &v
}

// ToWire translates CancelExternalWorkflowExecutionFailedCause into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v CancelExternalWorkflowExecutionFailedCause) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes CancelExternalWorkflowExecutionFailedCause from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return CancelExternalWorkflowExecutionFailedCause(0), err
//   }
//
//   var v CancelExternalWorkflowExecutionFailedCause
//   if err := v.FromWire(x); err != nil {
//     return CancelExternalWorkflowExecutionFailedCause(0), err
//   }
//   return v, nil
func (v *CancelExternalWorkflowExecutionFailedCause) FromWire(w wire.Value) error {
	*v = (CancelExternalWorkflowExecutionFailedCause)(w.GetI32())
	return nil
}

// String returns a readable string representation of CancelExternalWorkflowExecutionFailedCause.
func (v CancelExternalWorkflowExecutionFailedCause) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION"
	}
	return fmt.Sprintf("CancelExternalWorkflowExecutionFailedCause(%d)", w)
}

// Equals returns true if this CancelExternalWorkflowExecutionFailedCause value matches the provided
// value.
func (v CancelExternalWorkflowExecutionFailedCause) Equals(rhs CancelExternalWorkflowExecutionFailedCause) bool {
	return v == rhs
}

// MarshalJSON serializes CancelExternalWorkflowExecutionFailedCause into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v CancelExternalWorkflowExecutionFailedCause) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode CancelExternalWorkflowExecutionFailedCause from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *CancelExternalWorkflowExecutionFailedCause) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "CancelExternalWorkflowExecutionFailedCause")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "CancelExternalWorkflowExecutionFailedCause")
		}
		*v = (CancelExternalWorkflowExecutionFailedCause)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "CancelExternalWorkflowExecutionFailedCause")
	}
}

type ChildWorkflowExecutionFailedCause int32

const (
	ChildWorkflowExecutionFailedCauseWorkflowAlreadyRunning ChildWorkflowExecutionFailedCause = 0
)

// ChildWorkflowExecutionFailedCause_Values returns all recognized values of ChildWorkflowExecutionFailedCause.
func ChildWorkflowExecutionFailedCause_Values() []ChildWorkflowExecutionFailedCause {
	return []ChildWorkflowExecutionFailedCause{
		ChildWorkflowExecutionFailedCauseWorkflowAlreadyRunning,
	}
}

// UnmarshalText tries to decode ChildWorkflowExecutionFailedCause from a byte slice
// containing its name.
//
//   var v ChildWorkflowExecutionFailedCause
//   err := v.UnmarshalText([]byte("WORKFLOW_ALREADY_RUNNING"))
func (v *ChildWorkflowExecutionFailedCause) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "WORKFLOW_ALREADY_RUNNING":
		*v = ChildWorkflowExecutionFailedCauseWorkflowAlreadyRunning
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "ChildWorkflowExecutionFailedCause", err)
		}
		*v = ChildWorkflowExecutionFailedCause(val)
		return nil
	}
}

// MarshalText encodes ChildWorkflowExecutionFailedCause to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v ChildWorkflowExecutionFailedCause) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("WORKFLOW_ALREADY_RUNNING"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ChildWorkflowExecutionFailedCause.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v ChildWorkflowExecutionFailedCause) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "WORKFLOW_ALREADY_RUNNING")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v ChildWorkflowExecutionFailedCause) Ptr() *ChildWorkflowExecutionFailedCause {
	return &v
}

// ToWire translates ChildWorkflowExecutionFailedCause into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v ChildWorkflowExecutionFailedCause) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes ChildWorkflowExecutionFailedCause from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return ChildWorkflowExecutionFailedCause(0), err
//   }
//
//   var v ChildWorkflowExecutionFailedCause
//   if err := v.FromWire(x); err != nil {
//     return ChildWorkflowExecutionFailedCause(0), err
//   }
//   return v, nil
func (v *ChildWorkflowExecutionFailedCause) FromWire(w wire.Value) error {
	*v = (ChildWorkflowExecutionFailedCause)(w.GetI32())
	return nil
}

// String returns a readable string representation of ChildWorkflowExecutionFailedCause.
func (v ChildWorkflowExecutionFailedCause) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "WORKFLOW_ALREADY_RUNNING"
	}
	return fmt.Sprintf("ChildWorkflowExecutionFailedCause(%d)", w)
}

// Equals returns true if this ChildWorkflowExecutionFailedCause value matches the provided
// value.
func (v ChildWorkflowExecutionFailedCause) Equals(rhs ChildWorkflowExecutionFailedCause) bool {
	return v == rhs
}

// MarshalJSON serializes ChildWorkflowExecutionFailedCause into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v ChildWorkflowExecutionFailedCause) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"WORKFLOW_ALREADY_RUNNING\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode ChildWorkflowExecutionFailedCause from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *ChildWorkflowExecutionFailedCause) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "ChildWorkflowExecutionFailedCause")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "ChildWorkflowExecutionFailedCause")
		}
		*v = (ChildWorkflowExecutionFailedCause)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "ChildWorkflowExecutionFailedCause")
	}
}

type CloseShardRequest struct {
	ShardID *int32 `json:"shardID,omitempty"`
}

// ToWire translates a CloseShardRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CloseShardRequest) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ShardID != nil {
		w, err = wire.NewValueI32(*(v.ShardID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a CloseShardRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CloseShardRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CloseShardRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CloseShardRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ShardID = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a CloseShardRequest
// struct.
func (v *CloseShardRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.ShardID != nil {
		fields[i] = fmt.Sprintf("ShardID: %v", *(v.ShardID))
		i++
	}

	return fmt.Sprintf("CloseShardRequest{%v}", strings.Join(fields[:i], ", "))
}

func _I32_EqualsPtr(lhs, rhs *int32) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this CloseShardRequest match the
// provided CloseShardRequest.
//
// This function performs a deep comparison.
func (v *CloseShardRequest) Equals(rhs *CloseShardRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.ShardID, rhs.ShardID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CloseShardRequest.
func (v *CloseShardRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ShardID != nil {
		enc.AddInt32("shardID", *v.ShardID)
	}
	return err
}

// GetShardID returns the value of ShardID if it is set or its
// zero value if it is unset.
func (v *CloseShardRequest) GetShardID() (o int32) {
	if v != nil && v.ShardID != nil {
		return *v.ShardID
	}

	return
}

// IsSetShardID returns true if ShardID is not nil.
func (v *CloseShardRequest) IsSetShardID() bool {
	return v != nil && v.ShardID != nil
}

type ClusterInfo struct {
	SupportedClientVersions *SupportedClientVersions `json:"supportedClientVersions,omitempty"`
}

// ToWire translates a ClusterInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ClusterInfo) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.SupportedClientVersions != nil {
		w, err = v.SupportedClientVersions.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _SupportedClientVersions_Read(w wire.Value) (*SupportedClientVersions, error) {
	var v SupportedClientVersions
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a ClusterInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ClusterInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ClusterInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ClusterInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TStruct {
				v.SupportedClientVersions, err = _SupportedClientVersions_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ClusterInfo
// struct.
func (v *ClusterInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.SupportedClientVersions != nil {
		fields[i] = fmt.Sprintf("SupportedClientVersions: %v", v.SupportedClientVersions)
		i++
	}

	return fmt.Sprintf("ClusterInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ClusterInfo match the
// provided ClusterInfo.
//
// This function performs a deep comparison.
func (v *ClusterInfo) Equals(rhs *ClusterInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.SupportedClientVersions == nil && rhs.SupportedClientVersions == nil) || (v.SupportedClientVersions != nil && rhs.SupportedClientVersions != nil && v.SupportedClientVersions.Equals(rhs.SupportedClientVersions))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ClusterInfo.
func (v *ClusterInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.SupportedClientVersions != nil {
		err = multierr.Append(err, enc.AddObject("supportedClientVersions", v.SupportedClientVersions))
	}
	return err
}

// GetSupportedClientVersions returns the value of SupportedClientVersions if it is set or its
// zero value if it is unset.
func (v *ClusterInfo) GetSupportedClientVersions() (o *SupportedClientVersions) {
	if v != nil && v.SupportedClientVersions != nil {
		return v.SupportedClientVersions
	}

	return
}

// IsSetSupportedClientVersions returns true if SupportedClientVersions is not nil.
func (v *ClusterInfo) IsSetSupportedClientVersions() bool {
	return v != nil && v.SupportedClientVersions != nil
}

type ClusterReplicationConfiguration struct {
	ClusterName *string `json:"clusterName,omitempty"`
}

// ToWire translates a ClusterReplicationConfiguration struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ClusterReplicationConfiguration) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ClusterName != nil {
		w, err = wire.NewValueString(*(v.ClusterName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ClusterReplicationConfiguration struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ClusterReplicationConfiguration struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ClusterReplicationConfiguration
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ClusterReplicationConfiguration) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ClusterName = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ClusterReplicationConfiguration
// struct.
func (v *ClusterReplicationConfiguration) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.ClusterName != nil {
		fields[i] = fmt.Sprintf("ClusterName: %v", *(v.ClusterName))
		i++
	}

	return fmt.Sprintf("ClusterReplicationConfiguration{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ClusterReplicationConfiguration match the
// provided ClusterReplicationConfiguration.
//
// This function performs a deep comparison.
func (v *ClusterReplicationConfiguration) Equals(rhs *ClusterReplicationConfiguration) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.ClusterName, rhs.ClusterName) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ClusterReplicationConfiguration.
func (v *ClusterReplicationConfiguration) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ClusterName != nil {
		enc.AddString("clusterName", *v.ClusterName)
	}
	return err
}

// GetClusterName returns the value of ClusterName if it is set or its
// zero value if it is unset.
func (v *ClusterReplicationConfiguration) GetClusterName() (o string) {
	if v != nil && v.ClusterName != nil {
		return *v.ClusterName
	}

	return
}

// IsSetClusterName returns true if ClusterName is not nil.
func (v *ClusterReplicationConfiguration) IsSetClusterName() bool {
	return v != nil && v.ClusterName != nil
}

type ContinueAsNewInitiator int32

const (
	ContinueAsNewInitiatorDecider      ContinueAsNewInitiator = 0
	ContinueAsNewInitiatorRetryPolicy  ContinueAsNewInitiator = 1
	ContinueAsNewInitiatorCronSchedule ContinueAsNewInitiator = 2
)

// ContinueAsNewInitiator_Values returns all recognized values of ContinueAsNewInitiator.
func ContinueAsNewInitiator_Values() []ContinueAsNewInitiator {
	return []ContinueAsNewInitiator{
		ContinueAsNewInitiatorDecider,
		ContinueAsNewInitiatorRetryPolicy,
		ContinueAsNewInitiatorCronSchedule,
	}
}

// UnmarshalText tries to decode ContinueAsNewInitiator from a byte slice
// containing its name.
//
//   var v ContinueAsNewInitiator
//   err := v.UnmarshalText([]byte("Decider"))
func (v *ContinueAsNewInitiator) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "Decider":
		*v = ContinueAsNewInitiatorDecider
		return nil
	case "RetryPolicy":
		*v = ContinueAsNewInitiatorRetryPolicy
		return nil
	case "CronSchedule":
		*v = ContinueAsNewInitiatorCronSchedule
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "ContinueAsNewInitiator", err)
		}
		*v = ContinueAsNewInitiator(val)
		return nil
	}
}

// MarshalText encodes ContinueAsNewInitiator to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v ContinueAsNewInitiator) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("Decider"), nil
	case 1:
		return []byte("RetryPolicy"), nil
	case 2:
		return []byte("CronSchedule"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ContinueAsNewInitiator.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v ContinueAsNewInitiator) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "Decider")
	case 1:
		enc.AddString("name", "RetryPolicy")
	case 2:
		enc.AddString("name", "CronSchedule")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v ContinueAsNewInitiator) Ptr() *ContinueAsNewInitiator {
	return &v
}

// ToWire translates ContinueAsNewInitiator into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v ContinueAsNewInitiator) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes ContinueAsNewInitiator from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return ContinueAsNewInitiator(0), err
//   }
//
//   var v ContinueAsNewInitiator
//   if err := v.FromWire(x); err != nil {
//     return ContinueAsNewInitiator(0), err
//   }
//   return v, nil
func (v *ContinueAsNewInitiator) FromWire(w wire.Value) error {
	*v = (ContinueAsNewInitiator)(w.GetI32())
	return nil
}

// String returns a readable string representation of ContinueAsNewInitiator.
func (v ContinueAsNewInitiator) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "Decider"
	case 1:
		return "RetryPolicy"
	case 2:
		return "CronSchedule"
	}
	return fmt.Sprintf("ContinueAsNewInitiator(%d)", w)
}

// Equals returns true if this ContinueAsNewInitiator value matches the provided
// value.
func (v ContinueAsNewInitiator) Equals(rhs ContinueAsNewInitiator) bool {
	return v == rhs
}

// MarshalJSON serializes ContinueAsNewInitiator into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v ContinueAsNewInitiator) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"Decider\""), nil
	case 1:
		return ([]byte)("\"RetryPolicy\""), nil
	case 2:
		return ([]byte)("\"CronSchedule\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode ContinueAsNewInitiator from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *ContinueAsNewInitiator) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "ContinueAsNewInitiator")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "ContinueAsNewInitiator")
		}
		*v = (ContinueAsNewInitiator)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "ContinueAsNewInitiator")
	}
}

type CountWorkflowExecutionsRequest struct {
	Domain *string `json:"domain,omitempty"`
	Query  *string `json:"query,omitempty"`
}

// ToWire translates a CountWorkflowExecutionsRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CountWorkflowExecutionsRequest) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Domain != nil {
		w, err = wire.NewValueString(*(v.Domain)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Query != nil {
		w, err = wire.NewValueString(*(v.Query)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a CountWorkflowExecutionsRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CountWorkflowExecutionsRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CountWorkflowExecutionsRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CountWorkflowExecutionsRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Domain = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Query = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a CountWorkflowExecutionsRequest
// struct.
func (v *CountWorkflowExecutionsRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Domain != nil {
		fields[i] = fmt.Sprintf("Domain: %v", *(v.Domain))
		i++
	}
	if v.Query != nil {
		fields[i] = fmt.Sprintf("Query: %v", *(v.Query))
		i++
	}

	return fmt.Sprintf("CountWorkflowExecutionsRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this CountWorkflowExecutionsRequest match the
// provided CountWorkflowExecutionsRequest.
//
// This function performs a deep comparison.
func (v *CountWorkflowExecutionsRequest) Equals(rhs *CountWorkflowExecutionsRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Domain, rhs.Domain) {
		return false
	}
	if !_String_EqualsPtr(v.Query, rhs.Query) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CountWorkflowExecutionsRequest.
func (v *CountWorkflowExecutionsRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Domain != nil {
		enc.AddString("domain", *v.Domain)
	}
	if v.Query != nil {
		enc.AddString("query", *v.Query)
	}
	return err
}

// GetDomain returns the value of Domain if it is set or its
// zero value if it is unset.
func (v *CountWorkflowExecutionsRequest) GetDomain() (o string) {
	if v != nil && v.Domain != nil {
		return *v.Domain
	}

	return
}

// IsSetDomain returns true if Domain is not nil.
func (v *CountWorkflowExecutionsRequest) IsSetDomain() bool {
	return v != nil && v.Domain != nil
}

// GetQuery returns the value of Query if it is set or its
// zero value if it is unset.
func (v *CountWorkflowExecutionsRequest) GetQuery() (o string) {
	if v != nil && v.Query != nil {
		return *v.Query
	}

	return
}

// IsSetQuery returns true if Query is not nil.
func (v *CountWorkflowExecutionsRequest) IsSetQuery() bool {
	return v != nil && v.Query != nil
}

type CountWorkflowExecutionsResponse struct {
	Count *int64 `json:"count,omitempty"`
}

// ToWire translates a CountWorkflowExecutionsResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CountWorkflowExecutionsResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Count != nil {
		w, err = wire.NewValueI64(*(v.Count)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a CountWorkflowExecutionsResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CountWorkflowExecutionsResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CountWorkflowExecutionsResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CountWorkflowExecutionsResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Count = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a CountWorkflowExecutionsResponse
// struct.
func (v *CountWorkflowExecutionsResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Count != nil {
		fields[i] = fmt.Sprintf("Count: %v", *(v.Count))
		i++
	}

	return fmt.Sprintf("CountWorkflowExecutionsResponse{%v}", strings.Join(fields[:i], ", "))
}

func _I64_EqualsPtr(lhs, rhs *int64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this CountWorkflowExecutionsResponse match the
// provided CountWorkflowExecutionsResponse.
//
// This function performs a deep comparison.
func (v *CountWorkflowExecutionsResponse) Equals(rhs *CountWorkflowExecutionsResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Count, rhs.Count) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CountWorkflowExecutionsResponse.
func (v *CountWorkflowExecutionsResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Count != nil {
		enc.AddInt64("count", *v.Count)
	}
	return err
}

// GetCount returns the value of Count if it is set or its
// zero value if it is unset.
func (v *CountWorkflowExecutionsResponse) GetCount() (o int64) {
	if v != nil && v.Count != nil {
		return *v.Count
	}

	return
}

// IsSetCount returns true if Count is not nil.
func (v *CountWorkflowExecutionsResponse) IsSetCount() bool {
	return v != nil && v.Count != nil
}

type DataBlob struct {
	EncodingType *EncodingType `json:"EncodingType,omitempty"`
	Data         []byte        `json:"Data,omitempty"`
}

// ToWire translates a DataBlob struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DataBlob) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.EncodingType != nil {
		w, err = v.EncodingType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Data != nil {
		w, err = wire.NewValueBinary(v.Data), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _EncodingType_Read(w wire.Value) (EncodingType, error) {
	var v EncodingType
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a DataBlob struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DataBlob struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DataBlob
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DataBlob) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI32 {
				var x EncodingType
				x, err = _EncodingType_Read(field.Value)
				v.EncodingType = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				v.Data, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a DataBlob
// struct.
func (v *DataBlob) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.EncodingType != nil {
		fields[i] = fmt.Sprintf("EncodingType: %v", *(v.EncodingType))
		i++
	}
	if v.Data != nil {
		fields[i] = fmt.Sprintf("Data: %v", v.Data)
		i++
	}

	return fmt.Sprintf("DataBlob{%v}", strings.Join(fields[:i], ", "))
}

func _EncodingType_EqualsPtr(lhs, rhs *EncodingType) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this DataBlob match the
// provided DataBlob.
//
// This function performs a deep comparison.
func (v *DataBlob) Equals(rhs *DataBlob) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_EncodingType_EqualsPtr(v.EncodingType, rhs.EncodingType) {
		return false
	}
	if !((v.Data == nil && rhs.Data == nil) || (v.Data != nil && rhs.Data != nil && bytes.Equal(v.Data, rhs.Data))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DataBlob.
func (v *DataBlob) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.EncodingType != nil {
		err = multierr.Append(err, enc.AddObject("EncodingType", *v.EncodingType))
	}
	if v.Data != nil {
		enc.AddString("Data", base64.StdEncoding.EncodeToString(v.Data))
	}
	return err
}

// GetEncodingType returns the value of EncodingType if it is set or its
// zero value if it is unset.
func (v *DataBlob) GetEncodingType() (o EncodingType) {
	if v != nil && v.EncodingType != nil {
		return *v.EncodingType
	}

	return
}

// IsSetEncodingType returns true if EncodingType is not nil.
func (v *DataBlob) IsSetEncodingType() bool {
	return v != nil && v.EncodingType != nil
}

// GetData returns the value of Data if it is set or its
// zero value if it is unset.
func (v *DataBlob) GetData() (o []byte) {
	if v != nil && v.Data != nil {
		return v.Data
	}

	return
}

// IsSetData returns true if Data is not nil.
func (v *DataBlob) IsSetData() bool {
	return v != nil && v.Data != nil
}

type DecisionTaskFailedCause int32

const (
	DecisionTaskFailedCauseUnhandledDecision                                   DecisionTaskFailedCause = 0
	DecisionTaskFailedCauseBadScheduleActivityAttributes                       DecisionTaskFailedCause = 1
	DecisionTaskFailedCauseBadRequestCancelActivityAttributes                  DecisionTaskFailedCause = 2
	DecisionTaskFailedCauseBadStartTimerAttributes                             DecisionTaskFailedCause = 3
	DecisionTaskFailedCauseBadCancelTimerAttributes                            DecisionTaskFailedCause = 4
	DecisionTaskFailedCauseBadRecordMarkerAttributes                           DecisionTaskFailedCause = 5
	DecisionTaskFailedCauseBadCompleteWorkflowExecutionAttributes              DecisionTaskFailedCause = 6
	DecisionTaskFailedCauseBadFailWorkflowExecutionAttributes                  DecisionTaskFailedCause = 7
	DecisionTaskFailedCauseBadCancelWorkflowExecutionAttributes                DecisionTaskFailedCause = 8
	DecisionTaskFailedCauseBadRequestCancelExternalWorkflowExecutionAttributes DecisionTaskFailedCause = 9
	DecisionTaskFailedCauseBadContinueAsNewAttributes                          DecisionTaskFailedCause = 10
	DecisionTaskFailedCauseStartTimerDuplicateID                               DecisionTaskFailedCause = 11
	DecisionTaskFailedCauseResetStickyTasklist                                 DecisionTaskFailedCause = 12
	DecisionTaskFailedCauseWorkflowWorkerUnhandledFailure                      DecisionTaskFailedCause = 13
	DecisionTaskFailedCauseBadSignalWorkflowExecutionAttributes                DecisionTaskFailedCause = 14
	DecisionTaskFailedCauseBadStartChildExecutionAttributes                    DecisionTaskFailedCause = 15
	DecisionTaskFailedCauseForceCloseDecision                                  DecisionTaskFailedCause = 16
	DecisionTaskFailedCauseFailoverCloseDecision                               DecisionTaskFailedCause = 17
	DecisionTaskFailedCauseBadSignalInputSize                                  DecisionTaskFailedCause = 18
	DecisionTaskFailedCauseResetWorkflow                                       DecisionTaskFailedCause = 19
	DecisionTaskFailedCauseBadBinary                                           DecisionTaskFailedCause = 20
	DecisionTaskFailedCauseScheduleActivityDuplicateID                         DecisionTaskFailedCause = 21
	DecisionTaskFailedCauseBadSearchAttributes                                 DecisionTaskFailedCause = 22
)

// DecisionTaskFailedCause_Values returns all recognized values of DecisionTaskFailedCause.
func DecisionTaskFailedCause_Values() []DecisionTaskFailedCause {
	return []DecisionTaskFailedCause{
		DecisionTaskFailedCauseUnhandledDecision,
		DecisionTaskFailedCauseBadScheduleActivityAttributes,
		DecisionTaskFailedCauseBadRequestCancelActivityAttributes,
		DecisionTaskFailedCauseBadStartTimerAttributes,
		DecisionTaskFailedCauseBadCancelTimerAttributes,
		DecisionTaskFailedCauseBadRecordMarkerAttributes,
		DecisionTaskFailedCauseBadCompleteWorkflowExecutionAttributes,
		DecisionTaskFailedCauseBadFailWorkflowExecutionAttributes,
		DecisionTaskFailedCauseBadCancelWorkflowExecutionAttributes,
		DecisionTaskFailedCauseBadRequestCancelExternalWorkflowExecutionAttributes,
		DecisionTaskFailedCauseBadContinueAsNewAttributes,
		DecisionTaskFailedCauseStartTimerDuplicateID,
		DecisionTaskFailedCauseResetStickyTasklist,
		DecisionTaskFailedCauseWorkflowWorkerUnhandledFailure,
		DecisionTaskFailedCauseBadSignalWorkflowExecutionAttributes,
		DecisionTaskFailedCauseBadStartChildExecutionAttributes,
		DecisionTaskFailedCauseForceCloseDecision,
		DecisionTaskFailedCauseFailoverCloseDecision,
		DecisionTaskFailedCauseBadSignalInputSize,
		DecisionTaskFailedCauseResetWorkflow,
		DecisionTaskFailedCauseBadBinary,
		DecisionTaskFailedCauseScheduleActivityDuplicateID,
		DecisionTaskFailedCauseBadSearchAttributes,
	}
}

// UnmarshalText tries to decode DecisionTaskFailedCause from a byte slice
// containing its name.
//
//   var v DecisionTaskFailedCause
//   err := v.UnmarshalText([]byte("UNHANDLED_DECISION"))
func (v *DecisionTaskFailedCause) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "UNHANDLED_DECISION":
		*v = DecisionTaskFailedCauseUnhandledDecision
		return nil
	case "BAD_SCHEDULE_ACTIVITY_ATTRIBUTES":
		*v = DecisionTaskFailedCauseBadScheduleActivityAttributes
		return nil
	case "BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES":
		*v = DecisionTaskFailedCauseBadRequestCancelActivityAttributes
		return nil
	case "BAD_START_TIMER_ATTRIBUTES":
		*v = DecisionTaskFailedCauseBadStartTimerAttributes
		return nil
	case "BAD_CANCEL_TIMER_ATTRIBUTES":
		*v = DecisionTaskFailedCauseBadCancelTimerAttributes
		return nil
	case "BAD_RECORD_MARKER_ATTRIBUTES":
		*v = DecisionTaskFailedCauseBadRecordMarkerAttributes
		return nil
	case "BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES":
		*v = DecisionTaskFailedCauseBadCompleteWorkflowExecutionAttributes
		return nil
	case "BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES":
		*v = DecisionTaskFailedCauseBadFailWorkflowExecutionAttributes
		return nil
	case "BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES":
		*v = DecisionTaskFailedCauseBadCancelWorkflowExecutionAttributes
		return nil
	case "BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES":
		*v = DecisionTaskFailedCauseBadRequestCancelExternalWorkflowExecutionAttributes
		return nil
	case "BAD_CONTINUE_AS_NEW_ATTRIBUTES":
		*v = DecisionTaskFailedCauseBadContinueAsNewAttributes
		return nil
	case "START_TIMER_DUPLICATE_ID":
		*v = DecisionTaskFailedCauseStartTimerDuplicateID
		return nil
	case "RESET_STICKY_TASKLIST":
		*v = DecisionTaskFailedCauseResetStickyTasklist
		return nil
	case "WORKFLOW_WORKER_UNHANDLED_FAILURE":
		*v = DecisionTaskFailedCauseWorkflowWorkerUnhandledFailure
		return nil
	case "BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES":
		*v = DecisionTaskFailedCauseBadSignalWorkflowExecutionAttributes
		return nil
	case "BAD_START_CHILD_EXECUTION_ATTRIBUTES":
		*v = DecisionTaskFailedCauseBadStartChildExecutionAttributes
		return nil
	case "FORCE_CLOSE_DECISION":
		*v = DecisionTaskFailedCauseForceCloseDecision
		return nil
	case "FAILOVER_CLOSE_DECISION":
		*v = DecisionTaskFailedCauseFailoverCloseDecision
		return nil
	case "BAD_SIGNAL_INPUT_SIZE":
		*v = DecisionTaskFailedCauseBadSignalInputSize
		return nil
	case "RESET_WORKFLOW":
		*v = DecisionTaskFailedCauseResetWorkflow
		return nil
	case "BAD_BINARY":
		*v = DecisionTaskFailedCauseBadBinary
		return nil
	case "SCHEDULE_ACTIVITY_DUPLICATE_ID":
		*v = DecisionTaskFailedCauseScheduleActivityDuplicateID
		return nil
	case "BAD_SEARCH_ATTRIBUTES":
		*v = DecisionTaskFailedCauseBadSearchAttributes
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "DecisionTaskFailedCause", err)
		}
		*v = DecisionTaskFailedCause(val)
		return nil
	}
}

// MarshalText encodes DecisionTaskFailedCause to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v DecisionTaskFailedCause) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("UNHANDLED_DECISION"), nil
	case 1:
		return []byte("BAD_SCHEDULE_ACTIVITY_ATTRIBUTES"), nil
	case 2:
		return []byte("BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES"), nil
	case 3:
		return []byte("BAD_START_TIMER_ATTRIBUTES"), nil
	case 4:
		return []byte("BAD_CANCEL_TIMER_ATTRIBUTES"), nil
	case 5:
		return []byte("BAD_RECORD_MARKER_ATTRIBUTES"), nil
	case 6:
		return []byte("BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES"), nil
	case 7:
		return []byte("BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES"), nil
	case 8:
		return []byte("BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES"), nil
	case 9:
		return []byte("BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES"), nil
	case 10:
		return []byte("BAD_CONTINUE_AS_NEW_ATTRIBUTES"), nil
	case 11:
		return []byte("START_TIMER_DUPLICATE_ID"), nil
	case 12:
		return []byte("RESET_STICKY_TASKLIST"), nil
	case 13:
		return []byte("WORKFLOW_WORKER_UNHANDLED_FAILURE"), nil
	case 14:
		return []byte("BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES"), nil
	case 15:
		return []byte("BAD_START_CHILD_EXECUTION_ATTRIBUTES"), nil
	case 16:
		return []byte("FORCE_CLOSE_DECISION"), nil
	case 17:
		return []byte("FAILOVER_CLOSE_DECISION"), nil
	case 18:
		return []byte("BAD_SIGNAL_INPUT_SIZE"), nil
	case 19:
		return []byte("RESET_WORKFLOW"), nil
	case 20:
		return []byte("BAD_BINARY"), nil
	case 21:
		return []byte("SCHEDULE_ACTIVITY_DUPLICATE_ID"), nil
	case 22:
		return []byte("BAD_SEARCH_ATTRIBUTES"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DecisionTaskFailedCause.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v DecisionTaskFailedCause) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "UNHANDLED_DECISION")
	case 1:
		enc.AddString("name", "BAD_SCHEDULE_ACTIVITY_ATTRIBUTES")
	case 2:
		enc.AddString("name", "BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES")
	case 3:
		enc.AddString("name", "BAD_START_TIMER_ATTRIBUTES")
	case 4:
		enc.AddString("name", "BAD_CANCEL_TIMER_ATTRIBUTES")
	case 5:
		enc.AddString("name", "BAD_RECORD_MARKER_ATTRIBUTES")
	case 6:
		enc.AddString("name", "BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES")
	case 7:
		enc.AddString("name", "BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES")
	case 8:
		enc.AddString("name", "BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES")
	case 9:
		enc.AddString("name", "BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES")
	case 10:
		enc.AddString("name", "BAD_CONTINUE_AS_NEW_ATTRIBUTES")
	case 11:
		enc.AddString("name", "START_TIMER_DUPLICATE_ID")
	case 12:
		enc.AddString("name", "RESET_STICKY_TASKLIST")
	case 13:
		enc.AddString("name", "WORKFLOW_WORKER_UNHANDLED_FAILURE")
	case 14:
		enc.AddString("name", "BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES")
	case 15:
		enc.AddString("name", "BAD_START_CHILD_EXECUTION_ATTRIBUTES")
	case 16:
		enc.AddString("name", "FORCE_CLOSE_DECISION")
	case 17:
		enc.AddString("name", "FAILOVER_CLOSE_DECISION")
	case 18:
		enc.AddString("name", "BAD_SIGNAL_INPUT_SIZE")
	case 19:
		enc.AddString("name", "RESET_WORKFLOW")
	case 20:
		enc.AddString("name", "BAD_BINARY")
	case 21:
		enc.AddString("name", "SCHEDULE_ACTIVITY_DUPLICATE_ID")
	case 22:
		enc.AddString("name", "BAD_SEARCH_ATTRIBUTES")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v DecisionTaskFailedCause) Ptr() *DecisionTaskFailedCause {
	return &v
}

// ToWire translates DecisionTaskFailedCause into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v DecisionTaskFailedCause) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes DecisionTaskFailedCause from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return DecisionTaskFailedCause(0), err
//   }
//
//   var v DecisionTaskFailedCause
//   if err := v.FromWire(x); err != nil {
//     return DecisionTaskFailedCause(0), err
//   }
//   return v, nil
func (v *DecisionTaskFailedCause) FromWire(w wire.Value) error {
	*v = (DecisionTaskFailedCause)(w.GetI32())
	return nil
}

// String returns a readable string representation of DecisionTaskFailedCause.
func (v DecisionTaskFailedCause) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "UNHANDLED_DECISION"
	case 1:
		return "BAD_SCHEDULE_ACTIVITY_ATTRIBUTES"
	case 2:
		return "BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES"
	case 3:
		return "BAD_START_TIMER_ATTRIBUTES"
	case 4:
		return "BAD_CANCEL_TIMER_ATTRIBUTES"
	case 5:
		return "BAD_RECORD_MARKER_ATTRIBUTES"
	case 6:
		return "BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES"
	case 7:
		return "BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES"
	case 8:
		return "BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES"
	case 9:
		return "BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES"
	case 10:
		return "BAD_CONTINUE_AS_NEW_ATTRIBUTES"
	case 11:
		return "START_TIMER_DUPLICATE_ID"
	case 12:
		return "RESET_STICKY_TASKLIST"
	case 13:
		return "WORKFLOW_WORKER_UNHANDLED_FAILURE"
	case 14:
		return "BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES"
	case 15:
		return "BAD_START_CHILD_EXECUTION_ATTRIBUTES"
	case 16:
		return "FORCE_CLOSE_DECISION"
	case 17:
		return "FAILOVER_CLOSE_DECISION"
	case 18:
		return "BAD_SIGNAL_INPUT_SIZE"
	case 19:
		return "RESET_WORKFLOW"
	case 20:
		return "BAD_BINARY"
	case 21:
		return "SCHEDULE_ACTIVITY_DUPLICATE_ID"
	case 22:
		return "BAD_SEARCH_ATTRIBUTES"
	}
	return fmt.Sprintf("DecisionTaskFailedCause(%d)", w)
}

// Equals returns true if this DecisionTaskFailedCause value matches the provided
// value.
func (v DecisionTaskFailedCause) Equals(rhs DecisionTaskFailedCause) bool {
	return v == rhs
}

// MarshalJSON serializes DecisionTaskFailedCause into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v DecisionTaskFailedCause) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"UNHANDLED_DECISION\""), nil
	case 1:
		return ([]byte)("\"BAD_SCHEDULE_ACTIVITY_ATTRIBUTES\""), nil
	case 2:
		return ([]byte)("\"BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES\""), nil
	case 3:
		return ([]byte)("\"BAD_START_TIMER_ATTRIBUTES\""), nil
	case 4:
		return ([]byte)("\"BAD_CANCEL_TIMER_ATTRIBUTES\""), nil
	case 5:
		return ([]byte)("\"BAD_RECORD_MARKER_ATTRIBUTES\""), nil
	case 6:
		return ([]byte)("\"BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES\""), nil
	case 7:
		return ([]byte)("\"BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES\""), nil
	case 8:
		return ([]byte)("\"BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES\""), nil
	case 9:
		return ([]byte)("\"BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES\""), nil
	case 10:
		return ([]byte)("\"BAD_CONTINUE_AS_NEW_ATTRIBUTES\""), nil
	case 11:
		return ([]byte)("\"START_TIMER_DUPLICATE_ID\""), nil
	case 12:
		return ([]byte)("\"RESET_STICKY_TASKLIST\""), nil
	case 13:
		return ([]byte)("\"WORKFLOW_WORKER_UNHANDLED_FAILURE\""), nil
	case 14:
		return ([]byte)("\"BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES\""), nil
	case 15:
		return ([]byte)("\"BAD_START_CHILD_EXECUTION_ATTRIBUTES\""), nil
	case 16:
		return ([]byte)("\"FORCE_CLOSE_DECISION\""), nil
	case 17:
		return ([]byte)("\"FAILOVER_CLOSE_DECISION\""), nil
	case 18:
		return ([]byte)("\"BAD_SIGNAL_INPUT_SIZE\""), nil
	case 19:
		return ([]byte)("\"RESET_WORKFLOW\""), nil
	case 20:
		return ([]byte)("\"BAD_BINARY\""), nil
	case 21:
		return ([]byte)("\"SCHEDULE_ACTIVITY_DUPLICATE_ID\""), nil
	case 22:
		return ([]byte)("\"BAD_SEARCH_ATTRIBUTES\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode DecisionTaskFailedCause from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *DecisionTaskFailedCause) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "DecisionTaskFailedCause")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "DecisionTaskFailedCause")
		}
		*v = (DecisionTaskFailedCause)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "DecisionTaskFailedCause")
	}
}

type DecisionType int32

const (
	DecisionTypeScheduleActivityTask                   DecisionType = 0
	DecisionTypeRequestCancelActivityTask              DecisionType = 1
	DecisionTypeStartTimer                             DecisionType = 2
	DecisionTypeCompleteWorkflowExecution              DecisionType = 3
	DecisionTypeFailWorkflowExecution                  DecisionType = 4
	DecisionTypeCancelTimer                            DecisionType = 5
	DecisionTypeCancelWorkflowExecution                DecisionType = 6
	DecisionTypeRequestCancelExternalWorkflowExecution DecisionType = 7
	DecisionTypeRecordMarker                           DecisionType = 8
	DecisionTypeContinueAsNewWorkflowExecution         DecisionType = 9
	DecisionTypeStartChildWorkflowExecution            DecisionType = 10
	DecisionTypeSignalExternalWorkflowExecution        DecisionType = 11
	DecisionTypeUpsertWorkflowSearchAttributes         DecisionType = 12
)

// DecisionType_Values returns all recognized values of DecisionType.
func DecisionType_Values() []DecisionType {
	return []DecisionType{
		DecisionTypeScheduleActivityTask,
		DecisionTypeRequestCancelActivityTask,
		DecisionTypeStartTimer,
		DecisionTypeCompleteWorkflowExecution,
		DecisionTypeFailWorkflowExecution,
		DecisionTypeCancelTimer,
		DecisionTypeCancelWorkflowExecution,
		DecisionTypeRequestCancelExternalWorkflowExecution,
		DecisionTypeRecordMarker,
		DecisionTypeContinueAsNewWorkflowExecution,
		DecisionTypeStartChildWorkflowExecution,
		DecisionTypeSignalExternalWorkflowExecution,
		DecisionTypeUpsertWorkflowSearchAttributes,
	}
}

// UnmarshalText tries to decode DecisionType from a byte slice
// containing its name.
//
//   var v DecisionType
//   err := v.UnmarshalText([]byte("ScheduleActivityTask"))
func (v *DecisionType) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "ScheduleActivityTask":
		*v = DecisionTypeScheduleActivityTask
		return nil
	case "RequestCancelActivityTask":
		*v = DecisionTypeRequestCancelActivityTask
		return nil
	case "StartTimer":
		*v = DecisionTypeStartTimer
		return nil
	case "CompleteWorkflowExecution":
		*v = DecisionTypeCompleteWorkflowExecution
		return nil
	case "FailWorkflowExecution":
		*v = DecisionTypeFailWorkflowExecution
		return nil
	case "CancelTimer":
		*v = DecisionTypeCancelTimer
		return nil
	case "CancelWorkflowExecution":
		*v = DecisionTypeCancelWorkflowExecution
		return nil
	case "RequestCancelExternalWorkflowExecution":
		*v = DecisionTypeRequestCancelExternalWorkflowExecution
		return nil
	case "RecordMarker":
		*v = DecisionTypeRecordMarker
		return nil
	case "ContinueAsNewWorkflowExecution":
		*v = DecisionTypeContinueAsNewWorkflowExecution
		return nil
	case "StartChildWorkflowExecution":
		*v = DecisionTypeStartChildWorkflowExecution
		return nil
	case "SignalExternalWorkflowExecution":
		*v = DecisionTypeSignalExternalWorkflowExecution
		return nil
	case "UpsertWorkflowSearchAttributes":
		*v = DecisionTypeUpsertWorkflowSearchAttributes
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "DecisionType", err)
		}
		*v = DecisionType(val)
		return nil
	}
}

// MarshalText encodes DecisionType to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v DecisionType) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("ScheduleActivityTask"), nil
	case 1:
		return []byte("RequestCancelActivityTask"), nil
	case 2:
		return []byte("StartTimer"), nil
	case 3:
		return []byte("CompleteWorkflowExecution"), nil
	case 4:
		return []byte("FailWorkflowExecution"), nil
	case 5:
		return []byte("CancelTimer"), nil
	case 6:
		return []byte("CancelWorkflowExecution"), nil
	case 7:
		return []byte("RequestCancelExternalWorkflowExecution"), nil
	case 8:
		return []byte("RecordMarker"), nil
	case 9:
		return []byte("ContinueAsNewWorkflowExecution"), nil
	case 10:
		return []byte("StartChildWorkflowExecution"), nil
	case 11:
		return []byte("SignalExternalWorkflowExecution"), nil
	case 12:
		return []byte("UpsertWorkflowSearchAttributes"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DecisionType.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v DecisionType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "ScheduleActivityTask")
	case 1:
		enc.AddString("name", "RequestCancelActivityTask")
	case 2:
		enc.AddString("name", "StartTimer")
	case 3:
		enc.AddString("name", "CompleteWorkflowExecution")
	case 4:
		enc.AddString("name", "FailWorkflowExecution")
	case 5:
		enc.AddString("name", "CancelTimer")
	case 6:
		enc.AddString("name", "CancelWorkflowExecution")
	case 7:
		enc.AddString("name", "RequestCancelExternalWorkflowExecution")
	case 8:
		enc.AddString("name", "RecordMarker")
	case 9:
		enc.AddString("name", "ContinueAsNewWorkflowExecution")
	case 10:
		enc.AddString("name", "StartChildWorkflowExecution")
	case 11:
		enc.AddString("name", "SignalExternalWorkflowExecution")
	case 12:
		enc.AddString("name", "UpsertWorkflowSearchAttributes")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v DecisionType) Ptr() *DecisionType {
	return &v
}

// ToWire translates DecisionType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v DecisionType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes DecisionType from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return DecisionType(0), err
//   }
//
//   var v DecisionType
//   if err := v.FromWire(x); err != nil {
//     return DecisionType(0), err
//   }
//   return v, nil
func (v *DecisionType) FromWire(w wire.Value) error {
	*v = (DecisionType)(w.GetI32())
	return nil
}

// String returns a readable string representation of DecisionType.
func (v DecisionType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "ScheduleActivityTask"
	case 1:
		return "RequestCancelActivityTask"
	case 2:
		return "StartTimer"
	case 3:
		return "CompleteWorkflowExecution"
	case 4:
		return "FailWorkflowExecution"
	case 5:
		return "CancelTimer"
	case 6:
		return "CancelWorkflowExecution"
	case 7:
		return "RequestCancelExternalWorkflowExecution"
	case 8:
		return "RecordMarker"
	case 9:
		return "ContinueAsNewWorkflowExecution"
	case 10:
		return "StartChildWorkflowExecution"
	case 11:
		return "SignalExternalWorkflowExecution"
	case 12:
		return "UpsertWorkflowSearchAttributes"
	}
	return fmt.Sprintf("DecisionType(%d)", w)
}

// Equals returns true if this DecisionType value matches the provided
// value.
func (v DecisionType) Equals(rhs DecisionType) bool {
	return v == rhs
}

// MarshalJSON serializes DecisionType into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v DecisionType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"ScheduleActivityTask\""), nil
	case 1:
		return ([]byte)("\"RequestCancelActivityTask\""), nil
	case 2:
		return ([]byte)("\"StartTimer\""), nil
	case 3:
		return ([]byte)("\"CompleteWorkflowExecution\""), nil
	case 4:
		return ([]byte)("\"FailWorkflowExecution\""), nil
	case 5:
		return ([]byte)("\"CancelTimer\""), nil
	case 6:
		return ([]byte)("\"CancelWorkflowExecution\""), nil
	case 7:
		return ([]byte)("\"RequestCancelExternalWorkflowExecution\""), nil
	case 8:
		return ([]byte)("\"RecordMarker\""), nil
	case 9:
		return ([]byte)("\"ContinueAsNewWorkflowExecution\""), nil
	case 10:
		return ([]byte)("\"StartChildWorkflowExecution\""), nil
	case 11:
		return ([]byte)("\"SignalExternalWorkflowExecution\""), nil
	case 12:
		return ([]byte)("\"UpsertWorkflowSearchAttributes\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode DecisionType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *DecisionType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "DecisionType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "DecisionType")
		}
		*v = (DecisionType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "DecisionType")
	}
}

type DescribeHistoryHostResponse struct {
	NumberOfShards        *int32           `json:"numberOfShards,omitempty"`
	ShardIDs              []int32          `json:"shardIDs,omitempty"`
	DomainCache           *DomainCacheInfo `json:"domainCache,omitempty"`
	ShardControllerStatus *string          `json:"shardControllerStatus,omitempty"`
	Address               *string          `json:"address,omitempty"`
}

type _List_I32_ValueList []int32

func (v _List_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueI32(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_I32_ValueList) Size() int {
	return len(v)
}

func (_List_I32_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_I32_ValueList) Close() {}

// ToWire translates a DescribeHistoryHostResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DescribeHistoryHostResponse) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.NumberOfShards != nil {
		w, err = wire.NewValueI32(*(v.NumberOfShards)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.ShardIDs != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.ShardIDs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.DomainCache != nil {
		w, err = v.DomainCache.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.ShardControllerStatus != nil {
		w, err = wire.NewValueString(*(v.ShardControllerStatus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.Address != nil {
		w, err = wire.NewValueString(*(v.Address)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_I32_Read(l wire.ValueList) ([]int32, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make([]int32, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetI32(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _DomainCacheInfo_Read(w wire.Value) (*DomainCacheInfo, error) {
	var v DomainCacheInfo
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a DescribeHistoryHostResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DescribeHistoryHostResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DescribeHistoryHostResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DescribeHistoryHostResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.NumberOfShards = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TList {
				v.ShardIDs, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TStruct {
				v.DomainCache, err = _DomainCacheInfo_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ShardControllerStatus = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Address = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a DescribeHistoryHostResponse
// struct.
func (v *DescribeHistoryHostResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.NumberOfShards != nil {
		fields[i] = fmt.Sprintf("NumberOfShards: %v", *(v.NumberOfShards))
		i++
	}
	if v.ShardIDs != nil {
		fields[i] = fmt.Sprintf("ShardIDs: %v", v.ShardIDs)
		i++
	}
	if v.DomainCache != nil {
		fields[i] = fmt.Sprintf("DomainCache: %v", v.DomainCache)
		i++
	}
	if v.ShardControllerStatus != nil {
		fields[i] = fmt.Sprintf("ShardControllerStatus: %v", *(v.ShardControllerStatus))
		i++
	}
	if v.Address != nil {
		fields[i] = fmt.Sprintf("Address: %v", *(v.Address))
		i++
	}

	return fmt.Sprintf("DescribeHistoryHostResponse{%v}", strings.Join(fields[:i], ", "))
}

func _List_I32_Equals(lhs, rhs []int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this DescribeHistoryHostResponse match the
// provided DescribeHistoryHostResponse.
//
// This function performs a deep comparison.
func (v *DescribeHistoryHostResponse) Equals(rhs *DescribeHistoryHostResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.NumberOfShards, rhs.NumberOfShards) {
		return false
	}
	if !((v.ShardIDs == nil && rhs.ShardIDs == nil) || (v.ShardIDs != nil && rhs.ShardIDs != nil && _List_I32_Equals(v.ShardIDs, rhs.ShardIDs))) {
		return false
	}
	if !((v.DomainCache == nil && rhs.DomainCache == nil) || (v.DomainCache != nil && rhs.DomainCache != nil && v.DomainCache.Equals(rhs.DomainCache))) {
		return false
	}
	if !_String_EqualsPtr(v.ShardControllerStatus, rhs.ShardControllerStatus) {
		return false
	}
	if !_String_EqualsPtr(v.Address, rhs.Address) {
		return false
	}

	return true
}

type _List_I32_Zapper []int32

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_I32_Zapper.
func (l _List_I32_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendInt32(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DescribeHistoryHostResponse.
func (v *DescribeHistoryHostResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.NumberOfShards != nil {
		enc.AddInt32("numberOfShards", *v.NumberOfShards)
	}
	if v.ShardIDs != nil {
		err = multierr.Append(err, enc.AddArray("shardIDs", (_List_I32_Zapper)(v.ShardIDs)))
	}
	if v.DomainCache != nil {
		err = multierr.Append(err, enc.AddObject("domainCache", v.DomainCache))
	}
	if v.ShardControllerStatus != nil {
		enc.AddString("shardControllerStatus", *v.ShardControllerStatus)
	}
	if v.Address != nil {
		enc.AddString("address", *v.Address)
	}
	return err
}

// GetNumberOfShards returns the value of NumberOfShards if it is set or its
// zero value if it is unset.
func (v *DescribeHistoryHostResponse) GetNumberOfShards() (o int32) {
	if v != nil && v.NumberOfShards != nil {
		return *v.NumberOfShards
	}

	return
}

// IsSetNumberOfShards returns true if NumberOfShards is not nil.
func (v *DescribeHistoryHostResponse) IsSetNumberOfShards() bool {
	return v != nil && v.NumberOfShards != nil
}

// GetShardIDs returns the value of ShardIDs if it is set or its
// zero value if it is unset.
func (v *DescribeHistoryHostResponse) GetShardIDs() (o []int32) {
	if v != nil && v.ShardIDs != nil {
		return v.ShardIDs
	}

	return
}

// IsSetShardIDs returns true if ShardIDs is not nil.
func (v *DescribeHistoryHostResponse) IsSetShardIDs() bool {
	return v != nil && v.ShardIDs != nil
}

// GetDomainCache returns the value of DomainCache if it is set or its
// zero value if it is unset.
func (v *DescribeHistoryHostResponse) GetDomainCache() (o *DomainCacheInfo) {
	if v != nil && v.DomainCache != nil {
		return v.DomainCache
	}

	return
}

// IsSetDomainCache returns true if DomainCache is not nil.
func (v *DescribeHistoryHostResponse) IsSetDomainCache() bool {
	return v != nil && v.DomainCache != nil
}

// GetShardControllerStatus returns the value of ShardControllerStatus if it is set or its
// zero value if it is unset.
func (v *DescribeHistoryHostResponse) GetShardControllerStatus() (o string) {
	if v != nil && v.ShardControllerStatus != nil {
		return *v.ShardControllerStatus
	}

	return
}

// IsSetShardControllerStatus returns true if ShardControllerStatus is not nil.
func (v *DescribeHistoryHostResponse) IsSetShardControllerStatus() bool {
	return v != nil && v.ShardControllerStatus != nil
}

// GetAddress returns the value of Address if it is set or its
// zero value if it is unset.
func (v *DescribeHistoryHostResponse) GetAddress() (o string) {
	if v != nil && v.Address != nil {
		return *v.Address
	}

	return
}

// IsSetAddress returns true if Address is not nil.
func (v *DescribeHistoryHostResponse) IsSetAddress() bool {
	return v != nil && v.Address != nil
}

type DescribeTaskListRequest struct {
	Domain                *string       `json:"domain,omitempty"`
	TaskList              *TaskList     `json:"taskList,omitempty"`
	TaskListType          *TaskListType `json:"taskListType,omitempty"`
	IncludeTaskListStatus *bool         `json:"includeTaskListStatus,omitempty"`
}

// ToWire translates a DescribeTaskListRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DescribeTaskListRequest) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Domain != nil {
		w, err = wire.NewValueString(*(v.Domain)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.TaskList != nil {
		w, err = v.TaskList.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.TaskListType != nil {
		w, err = v.TaskListType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.IncludeTaskListStatus != nil {
		w, err = wire.NewValueBool(*(v.IncludeTaskListStatus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _TaskList_Read(w wire.Value) (*TaskList, error) {
	var v TaskList
	err := v.FromWire(w)
	return &v, err
}

func _TaskListType_Read(w wire.Value) (TaskListType, error) {
	var v TaskListType
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a DescribeTaskListRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DescribeTaskListRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DescribeTaskListRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DescribeTaskListRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Domain = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TStruct {
				v.TaskList, err = _TaskList_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TI32 {
				var x TaskListType
				x, err = _TaskListType_Read(field.Value)
				v.TaskListType = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.IncludeTaskListStatus = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a DescribeTaskListRequest
// struct.
func (v *DescribeTaskListRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Domain != nil {
		fields[i] = fmt.Sprintf("Domain: %v", *(v.Domain))
		i++
	}
	if v.TaskList != nil {
		fields[i] = fmt.Sprintf("TaskList: %v", v.TaskList)
		i++
	}
	if v.TaskListType != nil {
		fields[i] = fmt.Sprintf("TaskListType: %v", *(v.TaskListType))
		i++
	}
	if v.IncludeTaskListStatus != nil {
		fields[i] = fmt.Sprintf("IncludeTaskListStatus: %v", *(v.IncludeTaskListStatus))
		i++
	}

	return fmt.Sprintf("DescribeTaskListRequest{%v}", strings.Join(fields[:i], ", "))
}

func _TaskListType_EqualsPtr(lhs, rhs *TaskListType) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this DescribeTaskListRequest match the
// provided DescribeTaskListRequest.
//
// This function performs a deep comparison.
func (v *DescribeTaskListRequest) Equals(rhs *DescribeTaskListRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Domain, rhs.Domain) {
		return false
	}
	if !((v.TaskList == nil && rhs.TaskList == nil) || (v.TaskList != nil && rhs.TaskList != nil && v.TaskList.Equals(rhs.TaskList))) {
		return false
	}
	if !_TaskListType_EqualsPtr(v.TaskListType, rhs.TaskListType) {
		return false
	}
	if !_Bool_EqualsPtr(v.IncludeTaskListStatus, rhs.IncludeTaskListStatus) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DescribeTaskListRequest.
func (v *DescribeTaskListRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Domain != nil {
		enc.AddString("domain", *v.Domain)
	}
	if v.TaskList != nil {
		err = multierr.Append(err, enc.AddObject("taskList", v.TaskList))
	}
	if v.TaskListType != nil {
		err = multierr.Append(err, enc.AddObject("taskListType", *v.TaskListType))
	}
	if v.IncludeTaskListStatus != nil {
		enc.AddBool("includeTaskListStatus", *v.IncludeTaskListStatus)
	}
	return err
}

// GetDomain returns the value of Domain if it is set or its
// zero value if it is unset.
func (v *DescribeTaskListRequest) GetDomain() (o string) {
	if v != nil && v.Domain != nil {
		return *v.Domain
	}

	return
}

// IsSetDomain returns true if Domain is not nil.
func (v *DescribeTaskListRequest) IsSetDomain() bool {
	return v != nil && v.Domain != nil
}

// GetTaskList returns the value of TaskList if it is set or its
// zero value if it is unset.
func (v *DescribeTaskListRequest) GetTaskList() (o *TaskList) {
	if v != nil && v.TaskList != nil {
		return v.TaskList
	}

	return
}

// IsSetTaskList returns true if TaskList is not nil.
func (v *DescribeTaskListRequest) IsSetTaskList() bool {
	return v != nil && v.TaskList != nil
}

// GetTaskListType returns the value of TaskListType if it is set or its
// zero value if it is unset.
func (v *DescribeTaskListRequest) GetTaskListType() (o TaskListType) {
	if v != nil && v.TaskListType != nil {
		return *v.TaskListType
	}

	return
}

// IsSetTaskListType returns true if TaskListType is not nil.
func (v *DescribeTaskListRequest) IsSetTaskListType() bool {
	return v != nil && v.TaskListType != nil
}

// GetIncludeTaskListStatus returns the value of IncludeTaskListStatus if it is set or its
// zero value if it is unset.
func (v *DescribeTaskListRequest) GetIncludeTaskListStatus() (o bool) {
	if v != nil && v.IncludeTaskListStatus != nil {
		return *v.IncludeTaskListStatus
	}

	return
}

// IsSetIncludeTaskListStatus returns true if IncludeTaskListStatus is not nil.
func (v *DescribeTaskListRequest) IsSetIncludeTaskListStatus() bool {
	return v != nil && v.IncludeTaskListStatus != nil
}

type DescribeTaskListResponse struct {
	Pollers        []*PollerInfo   `json:"pollers,omitempty"`
	TaskListStatus *TaskListStatus `json:"taskListStatus,omitempty"`
}

type _List_PollerInfo_ValueList []*PollerInfo

func (v _List_PollerInfo_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_PollerInfo_ValueList) Size() int {
	return len(v)
}

func (_List_PollerInfo_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_PollerInfo_ValueList) Close() {}

// ToWire translates a DescribeTaskListResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DescribeTaskListResponse) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Pollers != nil {
		w, err = wire.NewValueList(_List_PollerInfo_ValueList(v.Pollers)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.TaskListStatus != nil {
		w, err = v.TaskListStatus.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _PollerInfo_Read(w wire.Value) (*PollerInfo, error) {
	var v PollerInfo
	err := v.FromWire(w)
	return &v, err
}

func _List_PollerInfo_Read(l wire.ValueList) ([]*PollerInfo, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*PollerInfo, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _PollerInfo_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _TaskListStatus_Read(w wire.Value) (*TaskListStatus, error) {
	var v TaskListStatus
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a DescribeTaskListResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DescribeTaskListResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DescribeTaskListResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DescribeTaskListResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TList {
				v.Pollers, err = _List_PollerInfo_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TStruct {
				v.TaskListStatus, err = _TaskListStatus_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a DescribeTaskListResponse
// struct.
func (v *DescribeTaskListResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Pollers != nil {
		fields[i] = fmt.Sprintf("Pollers: %v", v.Pollers)
		i++
	}
	if v.TaskListStatus != nil {
		fields[i] = fmt.Sprintf("TaskListStatus: %v", v.TaskListStatus)
		i++
	}

	return fmt.Sprintf("DescribeTaskListResponse{%v}", strings.Join(fields[:i], ", "))
}

func _List_PollerInfo_Equals(lhs, rhs []*PollerInfo) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this DescribeTaskListResponse match the
// provided DescribeTaskListResponse.
//
// This function performs a deep comparison.
func (v *DescribeTaskListResponse) Equals(rhs *DescribeTaskListResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Pollers == nil && rhs.Pollers == nil) || (v.Pollers != nil && rhs.Pollers != nil && _List_PollerInfo_Equals(v.Pollers, rhs.Pollers))) {
		return false
	}
	if !((v.TaskListStatus == nil && rhs.TaskListStatus == nil) || (v.TaskListStatus != nil && rhs.TaskListStatus != nil && v.TaskListStatus.Equals(rhs.TaskListStatus))) {
		return false
	}

	return true
}

type _List_PollerInfo_Zapper []*PollerInfo

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_PollerInfo_Zapper.
func (l _List_PollerInfo_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DescribeTaskListResponse.
func (v *DescribeTaskListResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Pollers != nil {
		err = multierr.Append(err, enc.AddArray("pollers", (_List_PollerInfo_Zapper)(v.Pollers)))
	}
	if v.TaskListStatus != nil {
		err = multierr.Append(err, enc.AddObject("taskListStatus", v.TaskListStatus))
	}
	return err
}

// GetPollers returns the value of Pollers if it is set or its
// zero value if it is unset.
func (v *DescribeTaskListResponse) GetPollers() (o []*PollerInfo) {
	if v != nil && v.Pollers != nil {
		return v.Pollers
	}

	return
}

// IsSetPollers returns true if Pollers is not nil.
func (v *DescribeTaskListResponse) IsSetPollers() bool {
	return v != nil && v.Pollers != nil
}

// GetTaskListStatus returns the value of TaskListStatus if it is set or its
// zero value if it is unset.
func (v *DescribeTaskListResponse) GetTaskListStatus() (o *TaskListStatus) {
	if v != nil && v.TaskListStatus != nil {
		return v.TaskListStatus
	}

	return
}

// IsSetTaskListStatus returns true if TaskListStatus is not nil.
func (v *DescribeTaskListResponse) IsSetTaskListStatus() bool {
	return v != nil && v.TaskListStatus != nil
}

type DomainCacheInfo struct {
	NumOfItemsInCacheByID   *int64 `json:"numOfItemsInCacheByID,omitempty"`
	NumOfItemsInCacheByName *int64 `json:"numOfItemsInCacheByName,omitempty"`
}

// ToWire translates a DomainCacheInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DomainCacheInfo) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.NumOfItemsInCacheByID != nil {
		w, err = wire.NewValueI64(*(v.NumOfItemsInCacheByID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.NumOfItemsInCacheByName != nil {
		w, err = wire.NewValueI64(*(v.NumOfItemsInCacheByName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a DomainCacheInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DomainCacheInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DomainCacheInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DomainCacheInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.NumOfItemsInCacheByID = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.NumOfItemsInCacheByName = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a DomainCacheInfo
// struct.
func (v *DomainCacheInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.NumOfItemsInCacheByID != nil {
		fields[i] = fmt.Sprintf("NumOfItemsInCacheByID: %v", *(v.NumOfItemsInCacheByID))
		i++
	}
	if v.NumOfItemsInCacheByName != nil {
		fields[i] = fmt.Sprintf("NumOfItemsInCacheByName: %v", *(v.NumOfItemsInCacheByName))
		i++
	}

	return fmt.Sprintf("DomainCacheInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this DomainCacheInfo match the
// provided DomainCacheInfo.
//
// This function performs a deep comparison.
func (v *DomainCacheInfo) Equals(rhs *DomainCacheInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.NumOfItemsInCacheByID, rhs.NumOfItemsInCacheByID) {
		return false
	}
	if !_I64_EqualsPtr(v.NumOfItemsInCacheByName, rhs.NumOfItemsInCacheByName) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DomainCacheInfo.
func (v *DomainCacheInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.NumOfItemsInCacheByID != nil {
		enc.AddInt64("numOfItemsInCacheByID", *v.NumOfItemsInCacheByID)
	}
	if v.NumOfItemsInCacheByName != nil {
		enc.AddInt64("numOfItemsInCacheByName", *v.NumOfItemsInCacheByName)
	}
	return err
}

// GetNumOfItemsInCacheByID returns the value of NumOfItemsInCacheByID if it is set or its
// zero value if it is unset.
func (v *DomainCacheInfo) GetNumOfItemsInCacheByID() (o int64) {
	if v != nil && v.NumOfItemsInCacheByID != nil {
		return *v.NumOfItemsInCacheByID
	}

	return
}

// IsSetNumOfItemsInCacheByID returns true if NumOfItemsInCacheByID is not nil.
func (v *DomainCacheInfo) IsSetNumOfItemsInCacheByID() bool {
	return v != nil && v.NumOfItemsInCacheByID != nil
}

// GetNumOfItemsInCacheByName returns the value of NumOfItemsInCacheByName if it is set or its
// zero value if it is unset.
func (v *DomainCacheInfo) GetNumOfItemsInCacheByName() (o int64) {
	if v != nil && v.NumOfItemsInCacheByName != nil {
		return *v.NumOfItemsInCacheByName
	}

	return
}

// IsSetNumOfItemsInCacheByName returns true if NumOfItemsInCacheByName is not nil.
func (v *DomainCacheInfo) IsSetNumOfItemsInCacheByName() bool {
	return v != nil && v.NumOfItemsInCacheByName != nil
}

type DomainInfo struct {
	Name        *string           `json:"name,omitempty"`
	Status      *DomainStatus     `json:"status,omitempty"`
	Description *string           `json:"description,omitempty"`
	OwnerEmail  *string           `json:"ownerEmail,omitempty"`
	Data        map[string]string `json:"data,omitempty"`
	UUID        *string           `json:"uuid,omitempty"`
}

type _Map_String_String_MapItemList map[string]string

func (m _Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) Close() {}

// ToWire translates a DomainInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DomainInfo) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Status != nil {
		w, err = v.Status.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.Description != nil {
		w, err = wire.NewValueString(*(v.Description)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.OwnerEmail != nil {
		w, err = wire.NewValueString(*(v.OwnerEmail)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.Data != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Data)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.UUID != nil {
		w, err = wire.NewValueString(*(v.UUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _DomainStatus_Read(w wire.Value) (DomainStatus, error) {
	var v DomainStatus
	err := v.FromWire(w)
	return v, err
}

func _Map_String_String_Read(m wire.MapItemList) (map[string]string, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a DomainInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DomainInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DomainInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DomainInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI32 {
				var x DomainStatus
				x, err = _DomainStatus_Read(field.Value)
				v.Status = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Description = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.OwnerEmail = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TMap {
				v.Data, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.UUID = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a DomainInfo
// struct.
func (v *DomainInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Status != nil {
		fields[i] = fmt.Sprintf("Status: %v", *(v.Status))
		i++
	}
	if v.Description != nil {
		fields[i] = fmt.Sprintf("Description: %v", *(v.Description))
		i++
	}
	if v.OwnerEmail != nil {
		fields[i] = fmt.Sprintf("OwnerEmail: %v", *(v.OwnerEmail))
		i++
	}
	if v.Data != nil {
		fields[i] = fmt.Sprintf("Data: %v", v.Data)
		i++
	}
	if v.UUID != nil {
		fields[i] = fmt.Sprintf("UUID: %v", *(v.UUID))
		i++
	}

	return fmt.Sprintf("DomainInfo{%v}", strings.Join(fields[:i], ", "))
}

func _DomainStatus_EqualsPtr(lhs, rhs *DomainStatus) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

func _Map_String_String_Equals(lhs, rhs map[string]string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this DomainInfo match the
// provided DomainInfo.
//
// This function performs a deep comparison.
func (v *DomainInfo) Equals(rhs *DomainInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_DomainStatus_EqualsPtr(v.Status, rhs.Status) {
		return false
	}
	if !_String_EqualsPtr(v.Description, rhs.Description) {
		return false
	}
	if !_String_EqualsPtr(v.OwnerEmail, rhs.OwnerEmail) {
		return false
	}
	if !((v.Data == nil && rhs.Data == nil) || (v.Data != nil && rhs.Data != nil && _Map_String_String_Equals(v.Data, rhs.Data))) {
		return false
	}
	if !_String_EqualsPtr(v.UUID, rhs.UUID) {
		return false
	}

	return true
}

type _Map_String_String_Zapper map[string]string

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_String_Zapper.
func (m _Map_String_String_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddString((string)(k), v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DomainInfo.
func (v *DomainInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Status != nil {
		err = multierr.Append(err, enc.AddObject("status", *v.Status))
	}
	if v.Description != nil {
		enc.AddString("description", *v.Description)
	}
	if v.OwnerEmail != nil {
		enc.AddString("ownerEmail", *v.OwnerEmail)
	}
	if v.Data != nil {
		err = multierr.Append(err, enc.AddObject("data", (_Map_String_String_Zapper)(v.Data)))
	}
	if v.UUID != nil {
		enc.AddString("uuid", *v.UUID)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *DomainInfo) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetStatus returns the value of Status if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetStatus() (o DomainStatus) {
	if v != nil && v.Status != nil {
		return *v.Status
	}

	return
}

// IsSetStatus returns true if Status is not nil.
func (v *DomainInfo) IsSetStatus() bool {
	return v != nil && v.Status != nil
}

// GetDescription returns the value of Description if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetDescription() (o string) {
	if v != nil && v.Description != nil {
		return *v.Description
	}

	return
}

// IsSetDescription returns true if Description is not nil.
func (v *DomainInfo) IsSetDescription() bool {
	return v != nil && v.Description != nil
}

// GetOwnerEmail returns the value of OwnerEmail if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetOwnerEmail() (o string) {
	if v != nil && v.OwnerEmail != nil {
		return *v.OwnerEmail
	}

	return
}

// IsSetOwnerEmail returns true if OwnerEmail is not nil.
func (v *DomainInfo) IsSetOwnerEmail() bool {
	return v != nil && v.OwnerEmail != nil
}

// GetData returns the value of Data if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetData() (o map[string]string) {
	if v != nil && v.Data != nil {
		return v.Data
	}

	return
}

// IsSetData returns true if Data is not nil.
func (v *DomainInfo) IsSetData() bool {
	return v != nil && v.Data != nil
}

// GetUUID returns the value of UUID if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetUUID() (o string) {
	if v != nil && v.UUID != nil {
		return *v.UUID
	}

	return
}

// IsSetUUID returns true if UUID is not nil.
func (v *DomainInfo) IsSetUUID() bool {
	return v != nil && v.UUID != nil
}

type DomainReplicationConfiguration struct {
	ActiveClusterName *string                            `json:"activeClusterName,omitempty"`
	Clusters          []*ClusterReplicationConfiguration `json:"clusters,omitempty"`
}

type _List_ClusterReplicationConfiguration_ValueList []*ClusterReplicationConfiguration

func (v _List_ClusterReplicationConfiguration_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_ClusterReplicationConfiguration_ValueList) Size() int {
	return len(v)
}

func (_List_ClusterReplicationConfiguration_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_ClusterReplicationConfiguration_ValueList) Close() {}

// ToWire translates a DomainReplicationConfiguration struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DomainReplicationConfiguration) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ActiveClusterName != nil {
		w, err = wire.NewValueString(*(v.ActiveClusterName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Clusters != nil {
		w, err = wire.NewValueList(_List_ClusterReplicationConfiguration_ValueList(v.Clusters)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ClusterReplicationConfiguration_Read(w wire.Value) (*ClusterReplicationConfiguration, error) {
	var v ClusterReplicationConfiguration
	err := v.FromWire(w)
	return &v, err
}

func _List_ClusterReplicationConfiguration_Read(l wire.ValueList) ([]*ClusterReplicationConfiguration, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*ClusterReplicationConfiguration, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _ClusterReplicationConfiguration_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a DomainReplicationConfiguration struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DomainReplicationConfiguration struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DomainReplicationConfiguration
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DomainReplicationConfiguration) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ActiveClusterName = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TList {
				v.Clusters, err = _List_ClusterReplicationConfiguration_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a DomainReplicationConfiguration
// struct.
func (v *DomainReplicationConfiguration) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.ActiveClusterName != nil {
		fields[i] = fmt.Sprintf("ActiveClusterName: %v", *(v.ActiveClusterName))
		i++
	}
	if v.Clusters != nil {
		fields[i] = fmt.Sprintf("Clusters: %v", v.Clusters)
		i++
	}

	return fmt.Sprintf("DomainReplicationConfiguration{%v}", strings.Join(fields[:i], ", "))
}

func _List_ClusterReplicationConfiguration_Equals(lhs, rhs []*ClusterReplicationConfiguration) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this DomainReplicationConfiguration match the
// provided DomainReplicationConfiguration.
//
// This function performs a deep comparison.
func (v *DomainReplicationConfiguration) Equals(rhs *DomainReplicationConfiguration) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.ActiveClusterName, rhs.ActiveClusterName) {
		return false
	}
	if !((v.Clusters == nil && rhs.Clusters == nil) || (v.Clusters != nil && rhs.Clusters != nil && _List_ClusterReplicationConfiguration_Equals(v.Clusters, rhs.Clusters))) {
		return false
	}

	return true
}

type _List_ClusterReplicationConfiguration_Zapper []*ClusterReplicationConfiguration

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_ClusterReplicationConfiguration_Zapper.
func (l _List_ClusterReplicationConfiguration_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DomainReplicationConfiguration.
func (v *DomainReplicationConfiguration) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ActiveClusterName != nil {
		enc.AddString("activeClusterName", *v.ActiveClusterName)
	}
	if v.Clusters != nil {
		err = multierr.Append(err, enc.AddArray("clusters", (_List_ClusterReplicationConfiguration_Zapper)(v.Clusters)))
	}
	return err
}

// GetActiveClusterName returns the value of ActiveClusterName if it is set or its
// zero value if it is unset.
func (v *DomainReplicationConfiguration) GetActiveClusterName() (o string) {
	if v != nil && v.ActiveClusterName != nil {
		return *v.ActiveClusterName
	}

	return
}

// IsSetActiveClusterName returns true if ActiveClusterName is not nil.
func (v *DomainReplicationConfiguration) IsSetActiveClusterName() bool {
	return v != nil && v.ActiveClusterName != nil
}

// GetClusters returns the value of Clusters if it is set or its
// zero value if it is unset.
func (v *DomainReplicationConfiguration) GetClusters() (o []*ClusterReplicationConfiguration) {
	if v != nil && v.Clusters != nil {
		return v.Clusters
	}

	return
}

// IsSetClusters returns true if Clusters is not nil.
func (v *DomainReplicationConfiguration) IsSetClusters() bool {
	return v != nil && v.Clusters != nil
}

type DomainStatus int32

const (
	DomainStatusRegistered DomainStatus = 0
	DomainStatusDeprecated DomainStatus = 1
	DomainStatusDeleted    DomainStatus = 2
)

// DomainStatus_Values returns all recognized values of DomainStatus.
func DomainStatus_Values() []DomainStatus {
	return []DomainStatus{
		DomainStatusRegistered,
		DomainStatusDeprecated,
		DomainStatusDeleted,
	}
}

// UnmarshalText tries to decode DomainStatus from a byte slice
// containing its name.
//
//   var v DomainStatus
//   err := v.UnmarshalText([]byte("REGISTERED"))
func (v *DomainStatus) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "REGISTERED":
		*v = DomainStatusRegistered
		return nil
	case "DEPRECATED":
		*v = DomainStatusDeprecated
		return nil
	case "DELETED":
		*v = DomainStatusDeleted
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "DomainStatus", err)
		}
		*v = DomainStatus(val)
		return nil
	}
}

// MarshalText encodes DomainStatus to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v DomainStatus) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("REGISTERED"), nil
	case 1:
		return []byte("DEPRECATED"), nil
	case 2:
		return []byte("DELETED"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DomainStatus.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v DomainStatus) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "REGISTERED")
	case 1:
		enc.AddString("name", "DEPRECATED")
	case 2:
		enc.AddString("name", "DELETED")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v DomainStatus) Ptr() *DomainStatus {
	return &v
}

// ToWire translates DomainStatus into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v DomainStatus) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes DomainStatus from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return DomainStatus(0), err
//   }
//
//   var v DomainStatus
//   if err := v.FromWire(x); err != nil {
//     return DomainStatus(0), err
//   }
//   return v, nil
func (v *DomainStatus) FromWire(w wire.Value) error {
	*v = (DomainStatus)(w.GetI32())
	return nil
}

// String returns a readable string representation of DomainStatus.
func (v DomainStatus) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "REGISTERED"
	case 1:
		return "DEPRECATED"
	case 2:
		return "DELETED"
	}
	return fmt.Sprintf("DomainStatus(%d)", w)
}

// Equals returns true if this DomainStatus value matches the provided
// value.
func (v DomainStatus) Equals(rhs DomainStatus) bool {
	return v == rhs
}

// MarshalJSON serializes DomainStatus into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v DomainStatus) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"REGISTERED\""), nil
	case 1:
		return ([]byte)("\"DEPRECATED\""), nil
	case 2:
		return ([]byte)("\"DELETED\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode DomainStatus from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *DomainStatus) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "DomainStatus")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "DomainStatus")
		}
		*v = (DomainStatus)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "DomainStatus")
	}
}

type EncodingType int32

const (
	EncodingTypeThriftRW EncodingType = 0
	EncodingTypeJSON     EncodingType = 1
)

// EncodingType_Values returns all recognized values of EncodingType.
func EncodingType_Values() []EncodingType {
	return []EncodingType{
		EncodingTypeThriftRW,
		EncodingTypeJSON,
	}
}

// UnmarshalText tries to decode EncodingType from a byte slice
// containing its name.
//
//   var v EncodingType
//   err := v.UnmarshalText([]byte("ThriftRW"))
func (v *EncodingType) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "ThriftRW":
		*v = EncodingTypeThriftRW
		return nil
	case "JSON":
		*v = EncodingTypeJSON
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "EncodingType", err)
		}
		*v = EncodingType(val)
		return nil
	}
}

// MarshalText encodes EncodingType to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v EncodingType) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("ThriftRW"), nil
	case 1:
		return []byte("JSON"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of EncodingType.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v EncodingType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "ThriftRW")
	case 1:
		enc.AddString("name", "JSON")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v EncodingType) Ptr() *EncodingType {
	return &v
}

// ToWire translates EncodingType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v EncodingType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes EncodingType from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return EncodingType(0), err
//   }
//
//   var v EncodingType
//   if err := v.FromWire(x); err != nil {
//     return EncodingType(0), err
//   }
//   return v, nil
func (v *EncodingType) FromWire(w wire.Value) error {
	*v = (EncodingType)(w.GetI32())
	return nil
}

// String returns a readable string representation of EncodingType.
func (v EncodingType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "ThriftRW"
	case 1:
		return "JSON"
	}
	return fmt.Sprintf("EncodingType(%d)", w)
}

// Equals returns true if this EncodingType value matches the provided
// value.
func (v EncodingType) Equals(rhs EncodingType) bool {
	return v == rhs
}

// MarshalJSON serializes EncodingType into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v EncodingType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"ThriftRW\""), nil
	case 1:
		return ([]byte)("\"JSON\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode EncodingType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *EncodingType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "EncodingType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "EncodingType")
		}
		*v = (EncodingType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "EncodingType")
	}
}

type EventType int32

const (
	EventTypeWorkflowExecutionStarted                        EventType = 0
	EventTypeWorkflowExecutionCompleted                      EventType = 1
	EventTypeWorkflowExecutionFailed                         EventType = 2
	EventTypeWorkflowExecutionTimedOut                       EventType = 3
	EventTypeDecisionTaskScheduled                           EventType = 4
	EventTypeDecisionTaskStarted                             EventType = 5
	EventTypeDecisionTaskCompleted                           EventType = 6
	EventTypeDecisionTaskTimedOut                            EventType = 7
	EventTypeDecisionTaskFailed                              EventType = 8
	EventTypeActivityTaskScheduled                           EventType = 9
	EventTypeActivityTaskStarted                             EventType = 10
	EventTypeActivityTaskCompleted                           EventType = 11
	EventTypeActivityTaskFailed                              EventType = 12
	EventTypeActivityTaskTimedOut                            EventType = 13
	EventTypeActivityTaskCancelRequested                     EventType = 14
	EventTypeRequestCancelActivityTaskFailed                 EventType = 15
	EventTypeActivityTaskCanceled                            EventType = 16
	EventTypeTimerStarted                                    EventType = 17
	EventTypeTimerFired                                      EventType = 18
	EventTypeCancelTimerFailed                               EventType = 19
	EventTypeTimerCanceled                                   EventType = 20
	EventTypeWorkflowExecutionCancelRequested                EventType = 21
	EventTypeWorkflowExecutionCanceled                       EventType = 22
	EventTypeRequestCancelExternalWorkflowExecutionInitiated EventType = 23
	EventTypeRequestCancelExternalWorkflowExecutionFailed    EventType = 24
	EventTypeExternalWorkflowExecutionCancelRequested        EventType = 25
	EventTypeMarkerRecorded                                  EventType = 26
	EventTypeWorkflowExecutionSignaled                       EventType = 27
	EventTypeWorkflowExecutionTerminated                     EventType = 28
	EventTypeWorkflowExecutionContinuedAsNew                 EventType = 29
	EventTypeStartChildWorkflowExecutionInitiated            EventType = 30
	EventTypeStartChildWorkflowExecutionFailed               EventType = 31
	EventTypeChildWorkflowExecutionStarted                   EventType = 32
	EventTypeChildWorkflowExecutionCompleted                 EventType = 33
	EventTypeChildWorkflowExecutionFailed                    EventType = 34
	EventTypeChildWorkflowExecutionCanceled                  EventType = 35
	EventTypeChildWorkflowExecutionTimedOut                  EventType = 36
	EventTypeChildWorkflowExecutionTerminated                EventType = 37
	EventTypeSignalExternalWorkflowExecutionInitiated        EventType = 38
	EventTypeSignalExternalWorkflowExecutionFailed           EventType = 39
	EventTypeExternalWorkflowExecutionSignaled               EventType = 40
	EventTypeUpsertWorkflowSearchAttributes                  EventType = 41
)

// EventType_Values returns all recognized values of EventType.
func EventType_Values() []EventType {
	return []EventType{
		EventTypeWorkflowExecutionStarted,
		EventTypeWorkflowExecutionCompleted,
		EventTypeWorkflowExecutionFailed,
		EventTypeWorkflowExecutionTimedOut,
		EventTypeDecisionTaskScheduled,
		EventTypeDecisionTaskStarted,
		EventTypeDecisionTaskCompleted,
		EventTypeDecisionTaskTimedOut,
		EventTypeDecisionTaskFailed,
		EventTypeActivityTaskScheduled,
		EventTypeActivityTaskStarted,
		EventTypeActivityTaskCompleted,
		EventTypeActivityTaskFailed,
		EventTypeActivityTaskTimedOut,
		EventTypeActivityTaskCancelRequested,
		EventTypeRequestCancelActivityTaskFailed,
		EventTypeActivityTaskCanceled,
		EventTypeTimerStarted,
		EventTypeTimerFired,
		EventTypeCancelTimerFailed,
		EventTypeTimerCanceled,
		EventTypeWorkflowExecutionCancelRequested,
		EventTypeWorkflowExecutionCanceled,
		EventTypeRequestCancelExternalWorkflowExecutionInitiated,
		EventTypeRequestCancelExternalWorkflowExecutionFailed,
		EventTypeExternalWorkflowExecutionCancelRequested,
		EventTypeMarkerRecorded,
		EventTypeWorkflowExecutionSignaled,
		EventTypeWorkflowExecutionTerminated,
		EventTypeWorkflowExecutionContinuedAsNew,
		EventTypeStartChildWorkflowExecutionInitiated,
		EventTypeStartChildWorkflowExecutionFailed,
		EventTypeChildWorkflowExecutionStarted,
		EventTypeChildWorkflowExecutionCompleted,
		EventTypeChildWorkflowExecutionFailed,
		EventTypeChildWorkflowExecutionCanceled,
		EventTypeChildWorkflowExecutionTimedOut,
		EventTypeChildWorkflowExecutionTerminated,
		EventTypeSignalExternalWorkflowExecutionInitiated,
		EventTypeSignalExternalWorkflowExecutionFailed,
		EventTypeExternalWorkflowExecutionSignaled,
		EventTypeUpsertWorkflowSearchAttributes,
	}
}

// UnmarshalText tries to decode EventType from a byte slice
// containing its name.
//
//   var v EventType
//   err := v.UnmarshalText([]byte("WorkflowExecutionStarted"))
func (v *EventType) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "WorkflowExecutionStarted":
		*v = EventTypeWorkflowExecutionStarted
		return nil
	case "WorkflowExecutionCompleted":
		*v = EventTypeWorkflowExecutionCompleted
		return nil
	case "WorkflowExecutionFailed":
		*v = EventTypeWorkflowExecutionFailed
		return nil
	case "WorkflowExecutionTimedOut":
		*v = EventTypeWorkflowExecutionTimedOut
		return nil
	case "DecisionTaskScheduled":
		*v = EventTypeDecisionTaskScheduled
		return nil
	case "DecisionTaskStarted":
		*v = EventTypeDecisionTaskStarted
		return nil
	case "DecisionTaskCompleted":
		*v = EventTypeDecisionTaskCompleted
		return nil
	case "DecisionTaskTimedOut":
		*v = EventTypeDecisionTaskTimedOut
		return nil
	case "DecisionTaskFailed":
		*v = EventTypeDecisionTaskFailed
		return nil
	case "ActivityTaskScheduled":
		*v = EventTypeActivityTaskScheduled
		return nil
	case "ActivityTaskStarted":
		*v = EventTypeActivityTaskStarted
		return nil
	case "ActivityTaskCompleted":
		*v = EventTypeActivityTaskCompleted
		return nil
	case "ActivityTaskFailed":
		*v = EventTypeActivityTaskFailed
		return nil
	case "ActivityTaskTimedOut":
		*v = EventTypeActivityTaskTimedOut
		return nil
	case "ActivityTaskCancelRequested":
		*v = EventTypeActivityTaskCancelRequested
		return nil
	case "RequestCancelActivityTaskFailed":
		*v = EventTypeRequestCancelActivityTaskFailed
		return nil
	case "ActivityTaskCanceled":
		*v = EventTypeActivityTaskCanceled
		return nil
	case "TimerStarted":
		*v = EventTypeTimerStarted
		return nil
	case "TimerFired":
		*v = EventTypeTimerFired
		return nil
	case "CancelTimerFailed":
		*v = EventTypeCancelTimerFailed
		return nil
	case "TimerCanceled":
		*v = EventTypeTimerCanceled
		return nil
	case "WorkflowExecutionCancelRequested":
		*v = EventTypeWorkflowExecutionCancelRequested
		return nil
	case "WorkflowExecutionCanceled":
		*v = EventTypeWorkflowExecutionCanceled
		return nil
	case "RequestCancelExternalWorkflowExecutionInitiated":
		*v = EventTypeRequestCancelExternalWorkflowExecutionInitiated
		return nil
	case "RequestCancelExternalWorkflowExecutionFailed":
		*v = EventTypeRequestCancelExternalWorkflowExecutionFailed
		return nil
	case "ExternalWorkflowExecutionCancelRequested":
		*v = EventTypeExternalWorkflowExecutionCancelRequested
		return nil
	case "MarkerRecorded":
		*v = EventTypeMarkerRecorded
		return nil
	case "WorkflowExecutionSignaled":
		*v = EventTypeWorkflowExecutionSignaled
		return nil
	case "WorkflowExecutionTerminated":
		*v = EventTypeWorkflowExecutionTerminated
		return nil
	case "WorkflowExecutionContinuedAsNew":
		*v = EventTypeWorkflowExecutionContinuedAsNew
		return nil
	case "StartChildWorkflowExecutionInitiated":
		*v = EventTypeStartChildWorkflowExecutionInitiated
		return nil
	case "StartChildWorkflowExecutionFailed":
		*v = EventTypeStartChildWorkflowExecutionFailed
		return nil
	case "ChildWorkflowExecutionStarted":
		*v = EventTypeChildWorkflowExecutionStarted
		return nil
	case "ChildWorkflowExecutionCompleted":
		*v = EventTypeChildWorkflowExecutionCompleted
		return nil
	case "ChildWorkflowExecutionFailed":
		*v = EventTypeChildWorkflowExecutionFailed
		return nil
	case "ChildWorkflowExecutionCanceled":
		*v = EventTypeChildWorkflowExecutionCanceled
		return nil
	case "ChildWorkflowExecutionTimedOut":
		*v = EventTypeChildWorkflowExecutionTimedOut
		return nil
	case "ChildWorkflowExecutionTerminated":
		*v = EventTypeChildWorkflowExecutionTerminated
		return nil
	case "SignalExternalWorkflowExecutionInitiated":
		*v = EventTypeSignalExternalWorkflowExecutionInitiated
		return nil
	case "SignalExternalWorkflowExecutionFailed":
		*v = EventTypeSignalExternalWorkflowExecutionFailed
		return nil
	case "ExternalWorkflowExecutionSignaled":
		*v = EventTypeExternalWorkflowExecutionSignaled
		return nil
	case "UpsertWorkflowSearchAttributes":
		*v = EventTypeUpsertWorkflowSearchAttributes
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "EventType", err)
		}
		*v = EventType(val)
		return nil
	}
}

// MarshalText encodes EventType to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v EventType) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("WorkflowExecutionStarted"), nil
	case 1:
		return []byte("WorkflowExecutionCompleted"), nil
	case 2:
		return []byte("WorkflowExecutionFailed"), nil
	case 3:
		return []byte("WorkflowExecutionTimedOut"), nil
	case 4:
		return []byte("DecisionTaskScheduled"), nil
	case 5:
		return []byte("DecisionTaskStarted"), nil
	case 6:
		return []byte("DecisionTaskCompleted"), nil
	case 7:
		return []byte("DecisionTaskTimedOut"), nil
	case 8:
		return []byte("DecisionTaskFailed"), nil
	case 9:
		return []byte("ActivityTaskScheduled"), nil
	case 10:
		return []byte("ActivityTaskStarted"), nil
	case 11:
		return []byte("ActivityTaskCompleted"), nil
	case 12:
		return []byte("ActivityTaskFailed"), nil
	case 13:
		return []byte("ActivityTaskTimedOut"), nil
	case 14:
		return []byte("ActivityTaskCancelRequested"), nil
	case 15:
		return []byte("RequestCancelActivityTaskFailed"), nil
	case 16:
		return []byte("ActivityTaskCanceled"), nil
	case 17:
		return []byte("TimerStarted"), nil
	case 18:
		return []byte("TimerFired"), nil
	case 19:
		return []byte("CancelTimerFailed"), nil
	case 20:
		return []byte("TimerCanceled"), nil
	case 21:
		return []byte("WorkflowExecutionCancelRequested"), nil
	case 22:
		return []byte("WorkflowExecutionCanceled"), nil
	case 23:
		return []byte("RequestCancelExternalWorkflowExecutionInitiated"), nil
	case 24:
		return []byte("RequestCancelExternalWorkflowExecutionFailed"), nil
	case 25:
		return []byte("ExternalWorkflowExecutionCancelRequested"), nil
	case 26:
		return []byte("MarkerRecorded"), nil
	case 27:
		return []byte("WorkflowExecutionSignaled"), nil
	case 28:
		return []byte("WorkflowExecutionTerminated"), nil
	case 29:
		return []byte("WorkflowExecutionContinuedAsNew"), nil
	case 30:
		return []byte("StartChildWorkflowExecutionInitiated"), nil
	case 31:
		return []byte("StartChildWorkflowExecutionFailed"), nil
	case 32:
		return []byte("ChildWorkflowExecutionStarted"), nil
	case 33:
		return []byte("ChildWorkflowExecutionCompleted"), nil
	case 34:
		return []byte("ChildWorkflowExecutionFailed"), nil
	case 35:
		return []byte("ChildWorkflowExecutionCanceled"), nil
	case 36:
		return []byte("ChildWorkflowExecutionTimedOut"), nil
	case 37:
		return []byte("ChildWorkflowExecutionTerminated"), nil
	case 38:
		return []byte("SignalExternalWorkflowExecutionInitiated"), nil
	case 39:
		return []byte("SignalExternalWorkflowExecutionFailed"), nil
	case 40:
		return []byte("ExternalWorkflowExecutionSignaled"), nil
	case 41:
		return []byte("UpsertWorkflowSearchAttributes"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of EventType.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v EventType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "WorkflowExecutionStarted")
	case 1:
		enc.AddString("name", "WorkflowExecutionCompleted")
	case 2:
		enc.AddString("name", "WorkflowExecutionFailed")
	case 3:
		enc.AddString("name", "WorkflowExecutionTimedOut")
	case 4:
		enc.AddString("name", "DecisionTaskScheduled")
	case 5:
		enc.AddString("name", "DecisionTaskStarted")
	case 6:
		enc.AddString("name", "DecisionTaskCompleted")
	case 7:
		enc.AddString("name", "DecisionTaskTimedOut")
	case 8:
		enc.AddString("name", "DecisionTaskFailed")
	case 9:
		enc.AddString("name", "ActivityTaskScheduled")
	case 10:
		enc.AddString("name", "ActivityTaskStarted")
	case 11:
		enc.AddString("name", "ActivityTaskCompleted")
	case 12:
		enc.AddString("name", "ActivityTaskFailed")
	case 13:
		enc.AddString("name", "ActivityTaskTimedOut")
	case 14:
		enc.AddString("name", "ActivityTaskCancelRequested")
	case 15:
		enc.AddString("name", "RequestCancelActivityTaskFailed")
	case 16:
		enc.AddString("name", "ActivityTaskCanceled")
	case 17:
		enc.AddString("name", "TimerStarted")
	case 18:
		enc.AddString("name", "TimerFired")
	case 19:
		enc.AddString("name", "CancelTimerFailed")
	case 20:
		enc.AddString("name", "TimerCanceled")
	case 21:
		enc.AddString("name", "WorkflowExecutionCancelRequested")
	case 22:
		enc.AddString("name", "WorkflowExecutionCanceled")
	case 23:
		enc.AddString("name", "RequestCancelExternalWorkflowExecutionInitiated")
	case 24:
		enc.AddString("name", "RequestCancelExternalWorkflowExecutionFailed")
	case 25:
		enc.AddString("name", "ExternalWorkflowExecutionCancelRequested")
	case 26:
		enc.AddString("name", "MarkerRecorded")
	case 27:
		enc.AddString("name", "WorkflowExecutionSignaled")
	case 28:
		enc.AddString("name", "WorkflowExecutionTerminated")
	case 29:
		enc.AddString("name", "WorkflowExecutionContinuedAsNew")
	case 30:
		enc.AddString("name", "StartChildWorkflowExecutionInitiated")
	case 31:
		enc.AddString("name", "StartChildWorkflowExecutionFailed")
	case 32:
		enc.AddString("name", "ChildWorkflowExecutionStarted")
	case 33:
		enc.AddString("name", "ChildWorkflowExecutionCompleted")
	case 34:
		enc.AddString("name", "ChildWorkflowExecutionFailed")
	case 35:
		enc.AddString("name", "ChildWorkflowExecutionCanceled")
	case 36:
		enc.AddString("name", "ChildWorkflowExecutionTimedOut")
	case 37:
		enc.AddString("name", "ChildWorkflowExecutionTerminated")
	case 38:
		enc.AddString("name", "SignalExternalWorkflowExecutionInitiated")
	case 39:
		enc.AddString("name", "SignalExternalWorkflowExecutionFailed")
	case 40:
		enc.AddString("name", "ExternalWorkflowExecutionSignaled")
	case 41:
		enc.AddString("name", "UpsertWorkflowSearchAttributes")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v EventType) Ptr() *EventType {
	return &v
}

// ToWire translates EventType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v EventType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes EventType from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return EventType(0), err
//   }
//
//   var v EventType
//   if err := v.FromWire(x); err != nil {
//     return EventType(0), err
//   }
//   return v, nil
func (v *EventType) FromWire(w wire.Value) error {
	*v = (EventType)(w.GetI32())
	return nil
}

// String returns a readable string representation of EventType.
func (v EventType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "WorkflowExecutionStarted"
	case 1:
		return "WorkflowExecutionCompleted"
	case 2:
		return "WorkflowExecutionFailed"
	case 3:
		return "WorkflowExecutionTimedOut"
	case 4:
		return "DecisionTaskScheduled"
	case 5:
		return "DecisionTaskStarted"
	case 6:
		return "DecisionTaskCompleted"
	case 7:
		return "DecisionTaskTimedOut"
	case 8:
		return "DecisionTaskFailed"
	case 9:
		return "ActivityTaskScheduled"
	case 10:
		return "ActivityTaskStarted"
	case 11:
		return "ActivityTaskCompleted"
	case 12:
		return "ActivityTaskFailed"
	case 13:
		return "ActivityTaskTimedOut"
	case 14:
		return "ActivityTaskCancelRequested"
	case 15:
		return "RequestCancelActivityTaskFailed"
	case 16:
		return "ActivityTaskCanceled"
	case 17:
		return "TimerStarted"
	case 18:
		return "TimerFired"
	case 19:
		return "CancelTimerFailed"
	case 20:
		return "TimerCanceled"
	case 21:
		return "WorkflowExecutionCancelRequested"
	case 22:
		return "WorkflowExecutionCanceled"
	case 23:
		return "RequestCancelExternalWorkflowExecutionInitiated"
	case 24:
		return "RequestCancelExternalWorkflowExecutionFailed"
	case 25:
		return "ExternalWorkflowExecutionCancelRequested"
	case 26:
		return "MarkerRecorded"
	case 27:
		return "WorkflowExecutionSignaled"
	case 28:
		return "WorkflowExecutionTerminated"
	case 29:
		return "WorkflowExecutionContinuedAsNew"
	case 30:
		return "StartChildWorkflowExecutionInitiated"
	case 31:
		return "StartChildWorkflowExecutionFailed"
	case 32:
		return "ChildWorkflowExecutionStarted"
	case 33:
		return "ChildWorkflowExecutionCompleted"
	case 34:
		return "ChildWorkflowExecutionFailed"
	case 35:
		return "ChildWorkflowExecutionCanceled"
	case 36:
		return "ChildWorkflowExecutionTimedOut"
	case 37:
		return "ChildWorkflowExecutionTerminated"
	case 38:
		return "SignalExternalWorkflowExecutionInitiated"
	case 39:
		return "SignalExternalWorkflowExecutionFailed"
	case 40:
		return "ExternalWorkflowExecutionSignaled"
	case 41:
		return "UpsertWorkflowSearchAttributes"
	}
	return fmt.Sprintf("EventType(%d)", w)
}

// Equals returns true if this EventType value matches the provided
// value.
func (v EventType) Equals(rhs EventType) bool {
	return v == rhs
}

// MarshalJSON serializes EventType into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v EventType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"WorkflowExecutionStarted\""), nil
	case 1:
		return ([]byte)("\"WorkflowExecutionCompleted\""), nil
	case 2:
		return ([]byte)("\"WorkflowExecutionFailed\""), nil
	case 3:
		return ([]byte)("\"WorkflowExecutionTimedOut\""), nil
	case 4:
		return ([]byte)("\"DecisionTaskScheduled\""), nil
	case 5:
		return ([]byte)("\"DecisionTaskStarted\""), nil
	case 6:
		return ([]byte)("\"DecisionTaskCompleted\""), nil
	case 7:
		return ([]byte)("\"DecisionTaskTimedOut\""), nil
	case 8:
		return ([]byte)("\"DecisionTaskFailed\""), nil
	case 9:
		return ([]byte)("\"ActivityTaskScheduled\""), nil
	case 10:
		return ([]byte)("\"ActivityTaskStarted\""), nil
	case 11:
		return ([]byte)("\"ActivityTaskCompleted\""), nil
	case 12:
		return ([]byte)("\"ActivityTaskFailed\""), nil
	case 13:
		return ([]byte)("\"ActivityTaskTimedOut\""), nil
	case 14:
		return ([]byte)("\"ActivityTaskCancelRequested\""), nil
	case 15:
		return ([]byte)("\"RequestCancelActivityTaskFailed\""), nil
	case 16:
		return ([]byte)("\"ActivityTaskCanceled\""), nil
	case 17:
		return ([]byte)("\"TimerStarted\""), nil
	case 18:
		return ([]byte)("\"TimerFired\""), nil
	case 19:
		return ([]byte)("\"CancelTimerFailed\""), nil
	case 20:
		return ([]byte)("\"TimerCanceled\""), nil
	case 21:
		return ([]byte)("\"WorkflowExecutionCancelRequested\""), nil
	case 22:
		return ([]byte)("\"WorkflowExecutionCanceled\""), nil
	case 23:
		return ([]byte)("\"RequestCancelExternalWorkflowExecutionInitiated\""), nil
	case 24:
		return ([]byte)("\"RequestCancelExternalWorkflowExecutionFailed\""), nil
	case 25:
		return ([]byte)("\"ExternalWorkflowExecutionCancelRequested\""), nil
	case 26:
		return ([]byte)("\"MarkerRecorded\""), nil
	case 27:
		return ([]byte)("\"WorkflowExecutionSignaled\""), nil
	case 28:
		return ([]byte)("\"WorkflowExecutionTerminated\""), nil
	case 29:
		return ([]byte)("\"WorkflowExecutionContinuedAsNew\""), nil
	case 30:
		return ([]byte)("\"StartChildWorkflowExecutionInitiated\""), nil
	case 31:
		return ([]byte)("\"StartChildWorkflowExecutionFailed\""), nil
	case 32:
		return ([]byte)("\"ChildWorkflowExecutionStarted\""), nil
	case 33:
		return ([]byte)("\"ChildWorkflowExecutionCompleted\""), nil
	case 34:
		return ([]byte)("\"ChildWorkflowExecutionFailed\""), nil
	case 35:
		return ([]byte)("\"ChildWorkflowExecutionCanceled\""), nil
	case 36:
		return ([]byte)("\"ChildWorkflowExecutionTimedOut\""), nil
	case 37:
		return ([]byte)("\"ChildWorkflowExecutionTerminated\""), nil
	case 38:
		return ([]byte)("\"SignalExternalWorkflowExecutionInitiated\""), nil
	case 39:
		return ([]byte)("\"SignalExternalWorkflowExecutionFailed\""), nil
	case 40:
		return ([]byte)("\"ExternalWorkflowExecutionSignaled\""), nil
	case 41:
		return ([]byte)("\"UpsertWorkflowSearchAttributes\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode EventType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *EventType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "EventType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "EventType")
		}
		*v = (EventType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "EventType")
	}
}

type GetSearchAttributesResponse struct {
	Keys map[string]IndexedValueType `json:"keys,omitempty"`
}

type _Map_String_IndexedValueType_MapItemList map[string]IndexedValueType

func (m _Map_String_IndexedValueType_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_IndexedValueType_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_IndexedValueType_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_IndexedValueType_MapItemList) ValueType() wire.Type {
	return wire.TI32
}

func (_Map_String_IndexedValueType_MapItemList) Close() {}

// ToWire translates a GetSearchAttributesResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GetSearchAttributesResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Keys != nil {
		w, err = wire.NewValueMap(_Map_String_IndexedValueType_MapItemList(v.Keys)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _IndexedValueType_Read(w wire.Value) (IndexedValueType, error) {
	var v IndexedValueType
	err := v.FromWire(w)
	return v, err
}

func _Map_String_IndexedValueType_Read(m wire.MapItemList) (map[string]IndexedValueType, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[string]IndexedValueType, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := _IndexedValueType_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a GetSearchAttributesResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GetSearchAttributesResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GetSearchAttributesResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GetSearchAttributesResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TMap {
				v.Keys, err = _Map_String_IndexedValueType_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a GetSearchAttributesResponse
// struct.
func (v *GetSearchAttributesResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Keys != nil {
		fields[i] = fmt.Sprintf("Keys: %v", v.Keys)
		i++
	}

	return fmt.Sprintf("GetSearchAttributesResponse{%v}", strings.Join(fields[:i], ", "))
}

func _Map_String_IndexedValueType_Equals(lhs, rhs map[string]IndexedValueType) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this GetSearchAttributesResponse match the
// provided GetSearchAttributesResponse.
//
// This function performs a deep comparison.
func (v *GetSearchAttributesResponse) Equals(rhs *GetSearchAttributesResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Keys == nil && rhs.Keys == nil) || (v.Keys != nil && rhs.Keys != nil && _Map_String_IndexedValueType_Equals(v.Keys, rhs.Keys))) {
		return false
	}

	return true
}

type _Map_String_IndexedValueType_Zapper map[string]IndexedValueType

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_IndexedValueType_Zapper.
func (m _Map_String_IndexedValueType_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AddObject((string)(k), v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of GetSearchAttributesResponse.
func (v *GetSearchAttributesResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Keys != nil {
		err = multierr.Append(err, enc.AddObject("keys", (_Map_String_IndexedValueType_Zapper)(v.Keys)))
	}
	return err
}

// GetKeys returns the value of Keys if it is set or its
// zero value if it is unset.
func (v *GetSearchAttributesResponse) GetKeys() (o map[string]IndexedValueType) {
	if v != nil && v.Keys != nil {
		return v.Keys
	}

	return
}

// IsSetKeys returns true if Keys is not nil.
func (v *GetSearchAttributesResponse) IsSetKeys() bool {
	return v != nil && v.Keys != nil
}

type Header struct {
	Fields map[string][]byte `json:"fields,omitempty"`
}

type _Map_String_Binary_MapItemList map[string][]byte

func (m _Map_String_Binary_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueBinary(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_Binary_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_Binary_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Binary_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Binary_MapItemList) Close() {}

// ToWire translates a Header struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Header) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Fields != nil {
		w, err = wire.NewValueMap(_Map_String_Binary_MapItemList(v.Fields)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_String_Binary_Read(m wire.MapItemList) (map[string][]byte, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string][]byte, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetBinary(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a Header struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Header struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Header
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Header) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TMap {
				v.Fields, err = _Map_String_Binary_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Header
// struct.
func (v *Header) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Fields != nil {
		fields[i] = fmt.Sprintf("Fields: %v", v.Fields)
		i++
	}

	return fmt.Sprintf("Header{%v}", strings.Join(fields[:i], ", "))
}

func _Map_String_Binary_Equals(lhs, rhs map[string][]byte) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !bytes.Equal(lv, rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this Header match the
// provided Header.
//
// This function performs a deep comparison.
func (v *Header) Equals(rhs *Header) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Fields == nil && rhs.Fields == nil) || (v.Fields != nil && rhs.Fields != nil && _Map_String_Binary_Equals(v.Fields, rhs.Fields))) {
		return false
	}

	return true
}

type _Map_String_Binary_Zapper map[string][]byte

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_Binary_Zapper.
func (m _Map_String_Binary_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddString((string)(k), base64.StdEncoding.EncodeToString(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Header.
func (v *Header) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Fields != nil {
		err = multierr.Append(err, enc.AddObject("fields", (_Map_String_Binary_Zapper)(v.Fields)))
	}
	return err
}

// GetFields returns the value of Fields if it is set or its
// zero value if it is unset.
func (v *Header) GetFields() (o map[string][]byte) {
	if v != nil && v.Fields != nil {
		return v.Fields
	}

	return
}

// IsSetFields returns true if Fields is not nil.
func (v *Header) IsSetFields() bool {
	return v != nil && v.Fields != nil
}

type HistoryBranch struct {
	TreeID    *string               `json:"treeID,omitempty"`
	BranchID  *string               `json:"branchID,omitempty"`
	Ancestors []*HistoryBranchRange `json:"ancestors,omitempty"`
}

type _List_HistoryBranchRange_ValueList []*HistoryBranchRange

func (v _List_HistoryBranchRange_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_HistoryBranchRange_ValueList) Size() int {
	return len(v)
}

func (_List_HistoryBranchRange_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_HistoryBranchRange_ValueList) Close() {}

// ToWire translates a HistoryBranch struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *HistoryBranch) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TreeID != nil {
		w, err = wire.NewValueString(*(v.TreeID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.BranchID != nil {
		w, err = wire.NewValueString(*(v.BranchID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.Ancestors != nil {
		w, err = wire.NewValueList(_List_HistoryBranchRange_ValueList(v.Ancestors)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _HistoryBranchRange_Read(w wire.Value) (*HistoryBranchRange, error) {
	var v HistoryBranchRange
	err := v.FromWire(w)
	return &v, err
}

func _List_HistoryBranchRange_Read(l wire.ValueList) ([]*HistoryBranchRange, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*HistoryBranchRange, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _HistoryBranchRange_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a HistoryBranch struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a HistoryBranch struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v HistoryBranch
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *HistoryBranch) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.TreeID = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.BranchID = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TList {
				v.Ancestors, err = _List_HistoryBranchRange_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a HistoryBranch
// struct.
func (v *HistoryBranch) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.TreeID != nil {
		fields[i] = fmt.Sprintf("TreeID: %v", *(v.TreeID))
		i++
	}
	if v.BranchID != nil {
		fields[i] = fmt.Sprintf("BranchID: %v", *(v.BranchID))
		i++
	}
	if v.Ancestors != nil {
		fields[i] = fmt.Sprintf("Ancestors: %v", v.Ancestors)
		i++
	}

	return fmt.Sprintf("HistoryBranch{%v}", strings.Join(fields[:i], ", "))
}

func _List_HistoryBranchRange_Equals(lhs, rhs []*HistoryBranchRange) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this HistoryBranch match the
// provided HistoryBranch.
//
// This function performs a deep comparison.
func (v *HistoryBranch) Equals(rhs *HistoryBranch) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.TreeID, rhs.TreeID) {
		return false
	}
	if !_String_EqualsPtr(v.BranchID, rhs.BranchID) {
		return false
	}
	if !((v.Ancestors == nil && rhs.Ancestors == nil) || (v.Ancestors != nil && rhs.Ancestors != nil && _List_HistoryBranchRange_Equals(v.Ancestors, rhs.Ancestors))) {
		return false
	}

	return true
}

type _List_HistoryBranchRange_Zapper []*HistoryBranchRange

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_HistoryBranchRange_Zapper.
func (l _List_HistoryBranchRange_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of HistoryBranch.
func (v *HistoryBranch) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.TreeID != nil {
		enc.AddString("treeID", *v.TreeID)
	}
	if v.BranchID != nil {
		enc.AddString("branchID", *v.BranchID)
	}
	if v.Ancestors != nil {
		err = multierr.Append(err, enc.AddArray("ancestors", (_List_HistoryBranchRange_Zapper)(v.Ancestors)))
	}
	return err
}

// GetTreeID returns the value of TreeID if it is set or its
// zero value if it is unset.
func (v *HistoryBranch) GetTreeID() (o string) {
	if v != nil && v.TreeID != nil {
		return *v.TreeID
	}

	return
}

// IsSetTreeID returns true if TreeID is not nil.
func (v *HistoryBranch) IsSetTreeID() bool {
	return v != nil && v.TreeID != nil
}

// GetBranchID returns the value of BranchID if it is set or its
// zero value if it is unset.
func (v *HistoryBranch) GetBranchID() (o string) {
	if v != nil && v.BranchID != nil {
		return *v.BranchID
	}

	return
}

// IsSetBranchID returns true if BranchID is not nil.
func (v *HistoryBranch) IsSetBranchID() bool {
	return v != nil && v.BranchID != nil
}

// GetAncestors returns the value of Ancestors if it is set or its
// zero value if it is unset.
func (v *HistoryBranch) GetAncestors() (o []*HistoryBranchRange) {
	if v != nil && v.Ancestors != nil {
		return v.Ancestors
	}

	return
}

// IsSetAncestors returns true if Ancestors is not nil.
func (v *HistoryBranch) IsSetAncestors() bool {
	return v != nil && v.Ancestors != nil
}

type HistoryBranchRange struct {
	BranchID    *string `json:"branchID,omitempty"`
	BeginNodeID *int64  `json:"beginNodeID,omitempty"`
	EndNodeID   *int64  `json:"endNodeID,omitempty"`
}

// ToWire translates a HistoryBranchRange struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *HistoryBranchRange) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BranchID != nil {
		w, err = wire.NewValueString(*(v.BranchID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.BeginNodeID != nil {
		w, err = wire.NewValueI64(*(v.BeginNodeID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.EndNodeID != nil {
		w, err = wire.NewValueI64(*(v.EndNodeID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a HistoryBranchRange struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a HistoryBranchRange struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v HistoryBranchRange
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *HistoryBranchRange) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.BranchID = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.BeginNodeID = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.EndNodeID = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a HistoryBranchRange
// struct.
func (v *HistoryBranchRange) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.BranchID != nil {
		fields[i] = fmt.Sprintf("BranchID: %v", *(v.BranchID))
		i++
	}
	if v.BeginNodeID != nil {
		fields[i] = fmt.Sprintf("BeginNodeID: %v", *(v.BeginNodeID))
		i++
	}
	if v.EndNodeID != nil {
		fields[i] = fmt.Sprintf("EndNodeID: %v", *(v.EndNodeID))
		i++
	}

	return fmt.Sprintf("HistoryBranchRange{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this HistoryBranchRange match the
// provided HistoryBranchRange.
//
// This function performs a deep comparison.
func (v *HistoryBranchRange) Equals(rhs *HistoryBranchRange) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.BranchID, rhs.BranchID) {
		return false
	}
	if !_I64_EqualsPtr(v.BeginNodeID, rhs.BeginNodeID) {
		return false
	}
	if !_I64_EqualsPtr(v.EndNodeID, rhs.EndNodeID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of HistoryBranchRange.
func (v *HistoryBranchRange) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.BranchID != nil {
		enc.AddString("branchID", *v.BranchID)
	}
	if v.BeginNodeID != nil {
		enc.AddInt64("beginNodeID", *v.BeginNodeID)
	}
	if v.EndNodeID != nil {
		enc.AddInt64("endNodeID", *v.EndNodeID)
	}
	return err
}

// GetBranchID returns the value of BranchID if it is set or its
// zero value if it is unset.
func (v *HistoryBranchRange) GetBranchID() (o string) {
	if v != nil && v.BranchID != nil {
		return *v.BranchID
	}

	return
}

// IsSetBranchID returns true if BranchID is not nil.
func (v *HistoryBranchRange) IsSetBranchID() bool {
	return v != nil && v.BranchID != nil
}

// GetBeginNodeID returns the value of BeginNodeID if it is set or its
// zero value if it is unset.
func (v *HistoryBranchRange) GetBeginNodeID() (o int64) {
	if v != nil && v.BeginNodeID != nil {
		return *v.BeginNodeID
	}

	return
}

// IsSetBeginNodeID returns true if BeginNodeID is not nil.
func (v *HistoryBranchRange) IsSetBeginNodeID() bool {
	return v != nil && v.BeginNodeID != nil
}

// GetEndNodeID returns the value of EndNodeID if it is set or its
// zero value if it is unset.
func (v *HistoryBranchRange) GetEndNodeID() (o int64) {
	if v != nil && v.EndNodeID != nil {
		return *v.EndNodeID
	}

	return
}

// IsSetEndNodeID returns true if EndNodeID is not nil.
func (v *HistoryBranchRange) IsSetEndNodeID() bool {
	return v != nil && v.EndNodeID != nil
}

type HistoryEventFilterType int32

const (
	HistoryEventFilterTypeAllEvent   HistoryEventFilterType = 0
	HistoryEventFilterTypeCloseEvent HistoryEventFilterType = 1
)

// HistoryEventFilterType_Values returns all recognized values of HistoryEventFilterType.
func HistoryEventFilterType_Values() []HistoryEventFilterType {
	return []HistoryEventFilterType{
		HistoryEventFilterTypeAllEvent,
		HistoryEventFilterTypeCloseEvent,
	}
}

// UnmarshalText tries to decode HistoryEventFilterType from a byte slice
// containing its name.
//
//   var v HistoryEventFilterType
//   err := v.UnmarshalText([]byte("ALL_EVENT"))
func (v *HistoryEventFilterType) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "ALL_EVENT":
		*v = HistoryEventFilterTypeAllEvent
		return nil
	case "CLOSE_EVENT":
		*v = HistoryEventFilterTypeCloseEvent
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "HistoryEventFilterType", err)
		}
		*v = HistoryEventFilterType(val)
		return nil
	}
}

// MarshalText encodes HistoryEventFilterType to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v HistoryEventFilterType) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("ALL_EVENT"), nil
	case 1:
		return []byte("CLOSE_EVENT"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of HistoryEventFilterType.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v HistoryEventFilterType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "ALL_EVENT")
	case 1:
		enc.AddString("name", "CLOSE_EVENT")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v HistoryEventFilterType) Ptr() *HistoryEventFilterType {
	return &v
}

// ToWire translates HistoryEventFilterType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v HistoryEventFilterType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes HistoryEventFilterType from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return HistoryEventFilterType(0), err
//   }
//
//   var v HistoryEventFilterType
//   if err := v.FromWire(x); err != nil {
//     return HistoryEventFilterType(0), err
//   }
//   return v, nil
func (v *HistoryEventFilterType) FromWire(w wire.Value) error {
	*v = (HistoryEventFilterType)(w.GetI32())
	return nil
}

// String returns a readable string representation of HistoryEventFilterType.
func (v HistoryEventFilterType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "ALL_EVENT"
	case 1:
		return "CLOSE_EVENT"
	}
	return fmt.Sprintf("HistoryEventFilterType(%d)", w)
}

// Equals returns true if this HistoryEventFilterType value matches the provided
// value.
func (v HistoryEventFilterType) Equals(rhs HistoryEventFilterType) bool {
	return v == rhs
}

// MarshalJSON serializes HistoryEventFilterType into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v HistoryEventFilterType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"ALL_EVENT\""), nil
	case 1:
		return ([]byte)("\"CLOSE_EVENT\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode HistoryEventFilterType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *HistoryEventFilterType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "HistoryEventFilterType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "HistoryEventFilterType")
		}
		*v = (HistoryEventFilterType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "HistoryEventFilterType")
	}
}

type IndexedValueType int32

const (
	IndexedValueTypeString   IndexedValueType = 0
	IndexedValueTypeKeyword  IndexedValueType = 1
	IndexedValueTypeInt      IndexedValueType = 2
	IndexedValueTypeDouble   IndexedValueType = 3
	IndexedValueTypeBool     IndexedValueType = 4
	IndexedValueTypeDatetime IndexedValueType = 5
)

// IndexedValueType_Values returns all recognized values of IndexedValueType.
func IndexedValueType_Values() []IndexedValueType {
	return []IndexedValueType{
		IndexedValueTypeString,
		IndexedValueTypeKeyword,
		IndexedValueTypeInt,
		IndexedValueTypeDouble,
		IndexedValueTypeBool,
		IndexedValueTypeDatetime,
	}
}

// UnmarshalText tries to decode IndexedValueType from a byte slice
// containing its name.
//
//   var v IndexedValueType
//   err := v.UnmarshalText([]byte("STRING"))
func (v *IndexedValueType) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "STRING":
		*v = IndexedValueTypeString
		return nil
	case "KEYWORD":
		*v = IndexedValueTypeKeyword
		return nil
	case "INT":
		*v = IndexedValueTypeInt
		return nil
	case "DOUBLE":
		*v = IndexedValueTypeDouble
		return nil
	case "BOOL":
		*v = IndexedValueTypeBool
		return nil
	case "DATETIME":
		*v = IndexedValueTypeDatetime
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "IndexedValueType", err)
		}
		*v = IndexedValueType(val)
		return nil
	}
}

// MarshalText encodes IndexedValueType to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v IndexedValueType) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("STRING"), nil
	case 1:
		return []byte("KEYWORD"), nil
	case 2:
		return []byte("INT"), nil
	case 3:
		return []byte("DOUBLE"), nil
	case 4:
		return []byte("BOOL"), nil
	case 5:
		return []byte("DATETIME"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of IndexedValueType.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v IndexedValueType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "STRING")
	case 1:
		enc.AddString("name", "KEYWORD")
	case 2:
		enc.AddString("name", "INT")
	case 3:
		enc.AddString("name", "DOUBLE")
	case 4:
		enc.AddString("name", "BOOL")
	case 5:
		enc.AddString("name", "DATETIME")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v IndexedValueType) Ptr() *IndexedValueType {
	return &v
}

// ToWire translates IndexedValueType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v IndexedValueType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes IndexedValueType from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return IndexedValueType(0), err
//   }
//
//   var v IndexedValueType
//   if err := v.FromWire(x); err != nil {
//     return IndexedValueType(0), err
//   }
//   return v, nil
func (v *IndexedValueType) FromWire(w wire.Value) error {
	*v = (IndexedValueType)(w.GetI32())
	return nil
}

// String returns a readable string representation of IndexedValueType.
func (v IndexedValueType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "STRING"
	case 1:
		return "KEYWORD"
	case 2:
		return "INT"
	case 3:
		return "DOUBLE"
	case 4:
		return "BOOL"
	case 5:
		return "DATETIME"
	}
	return fmt.Sprintf("IndexedValueType(%d)", w)
}

// Equals returns true if this IndexedValueType value matches the provided
// value.
func (v IndexedValueType) Equals(rhs IndexedValueType) bool {
	return v == rhs
}

// MarshalJSON serializes IndexedValueType into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v IndexedValueType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"STRING\""), nil
	case 1:
		return ([]byte)("\"KEYWORD\""), nil
	case 2:
		return ([]byte)("\"INT\""), nil
	case 3:
		return ([]byte)("\"DOUBLE\""), nil
	case 4:
		return ([]byte)("\"BOOL\""), nil
	case 5:
		return ([]byte)("\"DATETIME\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode IndexedValueType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *IndexedValueType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "IndexedValueType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "IndexedValueType")
		}
		*v = (IndexedValueType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "IndexedValueType")
	}
}

type ListArchivedWorkflowExecutionsRequest struct {
	Domain        *string `json:"domain,omitempty"`
	PageSize      *int32  `json:"pageSize,omitempty"`
	NextPageToken []byte  `json:"nextPageToken,omitempty"`
	Query         *string `json:"query,omitempty"`
}

// ToWire translates a ListArchivedWorkflowExecutionsRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListArchivedWorkflowExecutionsRequest) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Domain != nil {
		w, err = wire.NewValueString(*(v.Domain)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.PageSize != nil {
		w, err = wire.NewValueI32(*(v.PageSize)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.NextPageToken != nil {
		w, err = wire.NewValueBinary(v.NextPageToken), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.Query != nil {
		w, err = wire.NewValueString(*(v.Query)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ListArchivedWorkflowExecutionsRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListArchivedWorkflowExecutionsRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListArchivedWorkflowExecutionsRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListArchivedWorkflowExecutionsRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Domain = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.PageSize = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				v.NextPageToken, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Query = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListArchivedWorkflowExecutionsRequest
// struct.
func (v *ListArchivedWorkflowExecutionsRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Domain != nil {
		fields[i] = fmt.Sprintf("Domain: %v", *(v.Domain))
		i++
	}
	if v.PageSize != nil {
		fields[i] = fmt.Sprintf("PageSize: %v", *(v.PageSize))
		i++
	}
	if v.NextPageToken != nil {
		fields[i] = fmt.Sprintf("NextPageToken: %v", v.NextPageToken)
		i++
	}
	if v.Query != nil {
		fields[i] = fmt.Sprintf("Query: %v", *(v.Query))
		i++
	}

	return fmt.Sprintf("ListArchivedWorkflowExecutionsRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ListArchivedWorkflowExecutionsRequest match the
// provided ListArchivedWorkflowExecutionsRequest.
//
// This function performs a deep comparison.
func (v *ListArchivedWorkflowExecutionsRequest) Equals(rhs *ListArchivedWorkflowExecutionsRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Domain, rhs.Domain) {
		return false
	}
	if !_I32_EqualsPtr(v.PageSize, rhs.PageSize) {
		return false
	}
	if !((v.NextPageToken == nil && rhs.NextPageToken == nil) || (v.NextPageToken != nil && rhs.NextPageToken != nil && bytes.Equal(v.NextPageToken, rhs.NextPageToken))) {
		return false
	}
	if !_String_EqualsPtr(v.Query, rhs.Query) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ListArchivedWorkflowExecutionsRequest.
func (v *ListArchivedWorkflowExecutionsRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Domain != nil {
		enc.AddString("domain", *v.Domain)
	}
	if v.PageSize != nil {
		enc.AddInt32("pageSize", *v.PageSize)
	}
	if v.NextPageToken != nil {
		enc.AddString("nextPageToken", base64.StdEncoding.EncodeToString(v.NextPageToken))
	}
	if v.Query != nil {
		enc.AddString("query", *v.Query)
	}
	return err
}

// GetDomain returns the value of Domain if it is set or its
// zero value if it is unset.
func (v *ListArchivedWorkflowExecutionsRequest) GetDomain() (o string) {
	if v != nil && v.Domain != nil {
		return *v.Domain
	}

	return
}

// IsSetDomain returns true if Domain is not nil.
func (v *ListArchivedWorkflowExecutionsRequest) IsSetDomain() bool {
	return v != nil && v.Domain != nil
}

// GetPageSize returns the value of PageSize if it is set or its
// zero value if it is unset.
func (v *ListArchivedWorkflowExecutionsRequest) GetPageSize() (o int32) {
	if v != nil && v.PageSize != nil {
		return *v.PageSize
	}

	return
}

// IsSetPageSize returns true if PageSize is not nil.
func (v *ListArchivedWorkflowExecutionsRequest) IsSetPageSize() bool {
	return v != nil && v.PageSize != nil
}

// GetNextPageToken returns the value of NextPageToken if it is set or its
// zero value if it is unset.
func (v *ListArchivedWorkflowExecutionsRequest) GetNextPageToken() (o []byte) {
	if v != nil && v.NextPageToken != nil {
		return v.NextPageToken
	}

	return
}

// IsSetNextPageToken returns true if NextPageToken is not nil.
func (v *ListArchivedWorkflowExecutionsRequest) IsSetNextPageToken() bool {
	return v != nil && v.NextPageToken != nil
}

// GetQuery returns the value of Query if it is set or its
// zero value if it is unset.
func (v *ListArchivedWorkflowExecutionsRequest) GetQuery() (o string) {
	if v != nil && v.Query != nil {
		return *v.Query
	}

	return
}

// IsSetQuery returns true if Query is not nil.
func (v *ListArchivedWorkflowExecutionsRequest) IsSetQuery() bool {
	return v != nil && v.Query != nil
}

type ListClosedWorkflowExecutionsRequest struct {
	Domain          *string                       `json:"domain,omitempty"`
	MaximumPageSize *int32                        `json:"maximumPageSize,omitempty"`
	NextPageToken   []byte                        `json:"nextPageToken,omitempty"`
	StartTimeFilter *StartTimeFilter              `json:"StartTimeFilter,omitempty"`
	ExecutionFilter *WorkflowExecutionFilter      `json:"executionFilter,omitempty"`
	TypeFilter      *WorkflowTypeFilter           `json:"typeFilter,omitempty"`
	StatusFilter    *WorkflowExecutionCloseStatus `json:"statusFilter,omitempty"`
}

// ToWire translates a ListClosedWorkflowExecutionsRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListClosedWorkflowExecutionsRequest) ToWire() (wire.Value, error) {
	var (
		fields [7]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Domain != nil {
		w, err = wire.NewValueString(*(v.Domain)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.MaximumPageSize != nil {
		w, err = wire.NewValueI32(*(v.MaximumPageSize)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.NextPageToken != nil {
		w, err = wire.NewValueBinary(v.NextPageToken), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.StartTimeFilter != nil {
		w, err = v.StartTimeFilter.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.ExecutionFilter != nil {
		w, err = v.ExecutionFilter.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.TypeFilter != nil {
		w, err = v.TypeFilter.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}
	if v.StatusFilter != nil {
		w, err = v.StatusFilter.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 70, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _StartTimeFilter_Read(w wire.Value) (*StartTimeFilter, error) {
	var v StartTimeFilter
	err := v.FromWire(w)
	return &v, err
}

func _WorkflowExecutionFilter_Read(w wire.Value) (*WorkflowExecutionFilter, error) {
	var v WorkflowExecutionFilter
	err := v.FromWire(w)
	return &v, err
}

func _WorkflowTypeFilter_Read(w wire.Value) (*WorkflowTypeFilter, error) {
	var v WorkflowTypeFilter
	err := v.FromWire(w)
	return &v, err
}

func _WorkflowExecutionCloseStatus_Read(w wire.Value) (WorkflowExecutionCloseStatus, error) {
	var v WorkflowExecutionCloseStatus
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a ListClosedWorkflowExecutionsRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListClosedWorkflowExecutionsRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListClosedWorkflowExecutionsRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListClosedWorkflowExecutionsRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Domain = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.MaximumPageSize = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				v.NextPageToken, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TStruct {
				v.StartTimeFilter, err = _StartTimeFilter_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TStruct {
				v.ExecutionFilter, err = _WorkflowExecutionFilter_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TStruct {
				v.TypeFilter, err = _WorkflowTypeFilter_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 70:
			if field.Value.Type() == wire.TI32 {
				var x WorkflowExecutionCloseStatus
				x, err = _WorkflowExecutionCloseStatus_Read(field.Value)
				v.StatusFilter = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListClosedWorkflowExecutionsRequest
// struct.
func (v *ListClosedWorkflowExecutionsRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [7]string
	i := 0
	if v.Domain != nil {
		fields[i] = fmt.Sprintf("Domain: %v", *(v.Domain))
		i++
	}
	if v.MaximumPageSize != nil {
		fields[i] = fmt.Sprintf("MaximumPageSize: %v", *(v.MaximumPageSize))
		i++
	}
	if v.NextPageToken != nil {
		fields[i] = fmt.Sprintf("NextPageToken: %v", v.NextPageToken)
		i++
	}
	if v.StartTimeFilter != nil {
		fields[i] = fmt.Sprintf("StartTimeFilter: %v", v.StartTimeFilter)
		i++
	}
	if v.ExecutionFilter != nil {
		fields[i] = fmt.Sprintf("ExecutionFilter: %v", v.ExecutionFilter)
		i++
	}
	if v.TypeFilter != nil {
		fields[i] = fmt.Sprintf("TypeFilter: %v", v.TypeFilter)
		i++
	}
	if v.StatusFilter != nil {
		fields[i] = fmt.Sprintf("StatusFilter: %v", *(v.StatusFilter))
		i++
	}

	return fmt.Sprintf("ListClosedWorkflowExecutionsRequest{%v}", strings.Join(fields[:i], ", "))
}

func _WorkflowExecutionCloseStatus_EqualsPtr(lhs, rhs *WorkflowExecutionCloseStatus) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this ListClosedWorkflowExecutionsRequest match the
// provided ListClosedWorkflowExecutionsRequest.
//
// This function performs a deep comparison.
func (v *ListClosedWorkflowExecutionsRequest) Equals(rhs *ListClosedWorkflowExecutionsRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Domain, rhs.Domain) {
		return false
	}
	if !_I32_EqualsPtr(v.MaximumPageSize, rhs.MaximumPageSize) {
		return false
	}
	if !((v.NextPageToken == nil && rhs.NextPageToken == nil) || (v.NextPageToken != nil && rhs.NextPageToken != nil && bytes.Equal(v.NextPageToken, rhs.NextPageToken))) {
		return false
	}
	if !((v.StartTimeFilter == nil && rhs.StartTimeFilter == nil) || (v.StartTimeFilter != nil && rhs.StartTimeFilter != nil && v.StartTimeFilter.Equals(rhs.StartTimeFilter))) {
		return false
	}
	if !((v.ExecutionFilter == nil && rhs.ExecutionFilter == nil) || (v.ExecutionFilter != nil && rhs.ExecutionFilter != nil && v.ExecutionFilter.Equals(rhs.ExecutionFilter))) {
		return false
	}
	if !((v.TypeFilter == nil && rhs.TypeFilter == nil) || (v.TypeFilter != nil && rhs.TypeFilter != nil && v.TypeFilter.Equals(rhs.TypeFilter))) {
		return false
	}
	if !_WorkflowExecutionCloseStatus_EqualsPtr(v.StatusFilter, rhs.StatusFilter) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ListClosedWorkflowExecutionsRequest.
func (v *ListClosedWorkflowExecutionsRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Domain != nil {
		enc.AddString("domain", *v.Domain)
	}
	if v.MaximumPageSize != nil {
		enc.AddInt32("maximumPageSize", *v.MaximumPageSize)
	}
	if v.NextPageToken != nil {
		enc.AddString("nextPageToken", base64.StdEncoding.EncodeToString(v.NextPageToken))
	}
	if v.StartTimeFilter != nil {
		err = multierr.Append(err, enc.AddObject("StartTimeFilter", v.StartTimeFilter))
	}
	if v.ExecutionFilter != nil {
		err = multierr.Append(err, enc.AddObject("executionFilter", v.ExecutionFilter))
	}
	if v.TypeFilter != nil {
		err = multierr.Append(err, enc.AddObject("typeFilter", v.TypeFilter))
	}
	if v.StatusFilter != nil {
		err = multierr.Append(err, enc.AddObject("statusFilter", *v.StatusFilter))
	}
	return err
}

// GetDomain returns the value of Domain if it is set or its
// zero value if it is unset.
func (v *ListClosedWorkflowExecutionsRequest) GetDomain() (o string) {
	if v != nil && v.Domain != nil {
		return *v.Domain
	}

	return
}

// IsSetDomain returns true if Domain is not nil.
func (v *ListClosedWorkflowExecutionsRequest) IsSetDomain() bool {
	return v != nil && v.Domain != nil
}

// GetMaximumPageSize returns the value of MaximumPageSize if it is set or its
// zero value if it is unset.
func (v *ListClosedWorkflowExecutionsRequest) GetMaximumPageSize() (o int32) {
	if v != nil && v.MaximumPageSize != nil {
		return *v.MaximumPageSize
	}

	return
}

// IsSetMaximumPageSize returns true if MaximumPageSize is not nil.
func (v *ListClosedWorkflowExecutionsRequest) IsSetMaximumPageSize() bool {
	return v != nil && v.MaximumPageSize != nil
}

// GetNextPageToken returns the value of NextPageToken if it is set or its
// zero value if it is unset.
func (v *ListClosedWorkflowExecutionsRequest) GetNextPageToken() (o []byte) {
	if v != nil && v.NextPageToken != nil {
		return v.NextPageToken
	}

	return
}

// IsSetNextPageToken returns true if NextPageToken is not nil.
func (v *ListClosedWorkflowExecutionsRequest) IsSetNextPageToken() bool {
	return v != nil && v.NextPageToken != nil
}

// GetStartTimeFilter returns the value of StartTimeFilter if it is set or its
// zero value if it is unset.
func (v *ListClosedWorkflowExecutionsRequest) GetStartTimeFilter() (o *StartTimeFilter) {
	if v != nil && v.StartTimeFilter != nil {
		return v.StartTimeFilter
	}

	return
}

// IsSetStartTimeFilter returns true if StartTimeFilter is not nil.
func (v *ListClosedWorkflowExecutionsRequest) IsSetStartTimeFilter() bool {
	return v != nil && v.StartTimeFilter != nil
}

// GetExecutionFilter returns the value of ExecutionFilter if it is set or its
// zero value if it is unset.
func (v *ListClosedWorkflowExecutionsRequest) GetExecutionFilter() (o *WorkflowExecutionFilter) {
	if v != nil && v.ExecutionFilter != nil {
		return v.ExecutionFilter
	}

	return
}

// IsSetExecutionFilter returns true if ExecutionFilter is not nil.
func (v *ListClosedWorkflowExecutionsRequest) IsSetExecutionFilter() bool {
	return v != nil && v.ExecutionFilter != nil
}

// GetTypeFilter returns the value of TypeFilter if it is set or its
// zero value if it is unset.
func (v *ListClosedWorkflowExecutionsRequest) GetTypeFilter() (o *WorkflowTypeFilter) {
	if v != nil && v.TypeFilter != nil {
		return v.TypeFilter
	}

	return
}

// IsSetTypeFilter returns true if TypeFilter is not nil.
func (v *ListClosedWorkflowExecutionsRequest) IsSetTypeFilter() bool {
	return v != nil && v.TypeFilter != nil
}

// GetStatusFilter returns the value of StatusFilter if it is set or its
// zero value if it is unset.
func (v *ListClosedWorkflowExecutionsRequest) GetStatusFilter() (o WorkflowExecutionCloseStatus) {
	if v != nil && v.StatusFilter != nil {
		return *v.StatusFilter
	}

	return
}

// IsSetStatusFilter returns true if StatusFilter is not nil.
func (v *ListClosedWorkflowExecutionsRequest) IsSetStatusFilter() bool {
	return v != nil && v.StatusFilter != nil
}

type ListOpenWorkflowExecutionsRequest struct {
	Domain          *string                  `json:"domain,omitempty"`
	MaximumPageSize *int32                   `json:"maximumPageSize,omitempty"`
	NextPageToken   []byte                   `json:"nextPageToken,omitempty"`
	StartTimeFilter *StartTimeFilter         `json:"StartTimeFilter,omitempty"`
	ExecutionFilter *WorkflowExecutionFilter `json:"executionFilter,omitempty"`
	TypeFilter      *WorkflowTypeFilter      `json:"typeFilter,omitempty"`
}

// ToWire translates a ListOpenWorkflowExecutionsRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListOpenWorkflowExecutionsRequest) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Domain != nil {
		w, err = wire.NewValueString(*(v.Domain)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.MaximumPageSize != nil {
		w, err = wire.NewValueI32(*(v.MaximumPageSize)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.NextPageToken != nil {
		w, err = wire.NewValueBinary(v.NextPageToken), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.StartTimeFilter != nil {
		w, err = v.StartTimeFilter.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.ExecutionFilter != nil {
		w, err = v.ExecutionFilter.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.TypeFilter != nil {
		w, err = v.TypeFilter.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ListOpenWorkflowExecutionsRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListOpenWorkflowExecutionsRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListOpenWorkflowExecutionsRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListOpenWorkflowExecutionsRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Domain = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.MaximumPageSize = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				v.NextPageToken, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TStruct {
				v.StartTimeFilter, err = _StartTimeFilter_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TStruct {
				v.ExecutionFilter, err = _WorkflowExecutionFilter_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TStruct {
				v.TypeFilter, err = _WorkflowTypeFilter_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListOpenWorkflowExecutionsRequest
// struct.
func (v *ListOpenWorkflowExecutionsRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.Domain != nil {
		fields[i] = fmt.Sprintf("Domain: %v", *(v.Domain))
		i++
	}
	if v.MaximumPageSize != nil {
		fields[i] = fmt.Sprintf("MaximumPageSize: %v", *(v.MaximumPageSize))
		i++
	}
	if v.NextPageToken != nil {
		fields[i] = fmt.Sprintf("NextPageToken: %v", v.NextPageToken)
		i++
	}
	if v.StartTimeFilter != nil {
		fields[i] = fmt.Sprintf("StartTimeFilter: %v", v.StartTimeFilter)
		i++
	}
	if v.ExecutionFilter != nil {
		fields[i] = fmt.Sprintf("ExecutionFilter: %v", v.ExecutionFilter)
		i++
	}
	if v.TypeFilter != nil {
		fields[i] = fmt.Sprintf("TypeFilter: %v", v.TypeFilter)
		i++
	}

	return fmt.Sprintf("ListOpenWorkflowExecutionsRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ListOpenWorkflowExecutionsRequest match the
// provided ListOpenWorkflowExecutionsRequest.
//
// This function performs a deep comparison.
func (v *ListOpenWorkflowExecutionsRequest) Equals(rhs *ListOpenWorkflowExecutionsRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Domain, rhs.Domain) {
		return false
	}
	if !_I32_EqualsPtr(v.MaximumPageSize, rhs.MaximumPageSize) {
		return false
	}
	if !((v.NextPageToken == nil && rhs.NextPageToken == nil) || (v.NextPageToken != nil && rhs.NextPageToken != nil && bytes.Equal(v.NextPageToken, rhs.NextPageToken))) {
		return false
	}
	if !((v.StartTimeFilter == nil && rhs.StartTimeFilter == nil) || (v.StartTimeFilter != nil && rhs.StartTimeFilter != nil && v.StartTimeFilter.Equals(rhs.StartTimeFilter))) {
		return false
	}
	if !((v.ExecutionFilter == nil && rhs.ExecutionFilter == nil) || (v.ExecutionFilter != nil && rhs.ExecutionFilter != nil && v.ExecutionFilter.Equals(rhs.ExecutionFilter))) {
		return false
	}
	if !((v.TypeFilter == nil && rhs.TypeFilter == nil) || (v.TypeFilter != nil && rhs.TypeFilter != nil && v.TypeFilter.Equals(rhs.TypeFilter))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ListOpenWorkflowExecutionsRequest.
func (v *ListOpenWorkflowExecutionsRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Domain != nil {
		enc.AddString("domain", *v.Domain)
	}
	if v.MaximumPageSize != nil {
		enc.AddInt32("maximumPageSize", *v.MaximumPageSize)
	}
	if v.NextPageToken != nil {
		enc.AddString("nextPageToken", base64.StdEncoding.EncodeToString(v.NextPageToken))
	}
	if v.StartTimeFilter != nil {
		err = multierr.Append(err, enc.AddObject("StartTimeFilter", v.StartTimeFilter))
	}
	if v.ExecutionFilter != nil {
		err = multierr.Append(err, enc.AddObject("executionFilter", v.ExecutionFilter))
	}
	if v.TypeFilter != nil {
		err = multierr.Append(err, enc.AddObject("typeFilter", v.TypeFilter))
	}
	return err
}

// GetDomain returns the value of Domain if it is set or its
// zero value if it is unset.
func (v *ListOpenWorkflowExecutionsRequest) GetDomain() (o string) {
	if v != nil && v.Domain != nil {
		return *v.Domain
	}

	return
}

// IsSetDomain returns true if Domain is not nil.
func (v *ListOpenWorkflowExecutionsRequest) IsSetDomain() bool {
	return v != nil && v.Domain != nil
}

// GetMaximumPageSize returns the value of MaximumPageSize if it is set or its
// zero value if it is unset.
func (v *ListOpenWorkflowExecutionsRequest) GetMaximumPageSize() (o int32) {
	if v != nil && v.MaximumPageSize != nil {
		return *v.MaximumPageSize
	}

	return
}

// IsSetMaximumPageSize returns true if MaximumPageSize is not nil.
func (v *ListOpenWorkflowExecutionsRequest) IsSetMaximumPageSize() bool {
	return v != nil && v.MaximumPageSize != nil
}

// GetNextPageToken returns the value of NextPageToken if it is set or its
// zero value if it is unset.
func (v *ListOpenWorkflowExecutionsRequest) GetNextPageToken() (o []byte) {
	if v != nil && v.NextPageToken != nil {
		return v.NextPageToken
	}

	return
}

// IsSetNextPageToken returns true if NextPageToken is not nil.
func (v *ListOpenWorkflowExecutionsRequest) IsSetNextPageToken() bool {
	return v != nil && v.NextPageToken != nil
}

// GetStartTimeFilter returns the value of StartTimeFilter if it is set or its
// zero value if it is unset.
func (v *ListOpenWorkflowExecutionsRequest) GetStartTimeFilter() (o *StartTimeFilter) {
	if v != nil && v.StartTimeFilter != nil {
		return v.StartTimeFilter
	}

	return
}

// IsSetStartTimeFilter returns true if StartTimeFilter is not nil.
func (v *ListOpenWorkflowExecutionsRequest) IsSetStartTimeFilter() bool {
	return v != nil && v.StartTimeFilter != nil
}

// GetExecutionFilter returns the value of ExecutionFilter if it is set or its
// zero value if it is unset.
func (v *ListOpenWorkflowExecutionsRequest) GetExecutionFilter() (o *WorkflowExecutionFilter) {
	if v != nil && v.ExecutionFilter != nil {
		return v.ExecutionFilter
	}

	return
}

// IsSetExecutionFilter returns true if ExecutionFilter is not nil.
func (v *ListOpenWorkflowExecutionsRequest) IsSetExecutionFilter() bool {
	return v != nil && v.ExecutionFilter != nil
}

// GetTypeFilter returns the value of TypeFilter if it is set or its
// zero value if it is unset.
func (v *ListOpenWorkflowExecutionsRequest) GetTypeFilter() (o *WorkflowTypeFilter) {
	if v != nil && v.TypeFilter != nil {
		return v.TypeFilter
	}

	return
}

// IsSetTypeFilter returns true if TypeFilter is not nil.
func (v *ListOpenWorkflowExecutionsRequest) IsSetTypeFilter() bool {
	return v != nil && v.TypeFilter != nil
}

type ListTaskListPartitionsRequest struct {
	Domain   *string   `json:"domain,omitempty"`
	TaskList *TaskList `json:"taskList,omitempty"`
}

// ToWire translates a ListTaskListPartitionsRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListTaskListPartitionsRequest) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Domain != nil {
		w, err = wire.NewValueString(*(v.Domain)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.TaskList != nil {
		w, err = v.TaskList.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ListTaskListPartitionsRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListTaskListPartitionsRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListTaskListPartitionsRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListTaskListPartitionsRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Domain = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TStruct {
				v.TaskList, err = _TaskList_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListTaskListPartitionsRequest
// struct.
func (v *ListTaskListPartitionsRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Domain != nil {
		fields[i] = fmt.Sprintf("Domain: %v", *(v.Domain))
		i++
	}
	if v.TaskList != nil {
		fields[i] = fmt.Sprintf("TaskList: %v", v.TaskList)
		i++
	}

	return fmt.Sprintf("ListTaskListPartitionsRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ListTaskListPartitionsRequest match the
// provided ListTaskListPartitionsRequest.
//
// This function performs a deep comparison.
func (v *ListTaskListPartitionsRequest) Equals(rhs *ListTaskListPartitionsRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Domain, rhs.Domain) {
		return false
	}
	if !((v.TaskList == nil && rhs.TaskList == nil) || (v.TaskList != nil && rhs.TaskList != nil && v.TaskList.Equals(rhs.TaskList))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ListTaskListPartitionsRequest.
func (v *ListTaskListPartitionsRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Domain != nil {
		enc.AddString("domain", *v.Domain)
	}
	if v.TaskList != nil {
		err = multierr.Append(err, enc.AddObject("taskList", v.TaskList))
	}
	return err
}

// GetDomain returns the value of Domain if it is set or its
// zero value if it is unset.
func (v *ListTaskListPartitionsRequest) GetDomain() (o string) {
	if v != nil && v.Domain != nil {
		return *v.Domain
	}

	return
}

// IsSetDomain returns true if Domain is not nil.
func (v *ListTaskListPartitionsRequest) IsSetDomain() bool {
	return v != nil && v.Domain != nil
}

// GetTaskList returns the value of TaskList if it is set or its
// zero value if it is unset.
func (v *ListTaskListPartitionsRequest) GetTaskList() (o *TaskList) {
	if v != nil && v.TaskList != nil {
		return v.TaskList
	}

	return
}

// IsSetTaskList returns true if TaskList is not nil.
func (v *ListTaskListPartitionsRequest) IsSetTaskList() bool {
	return v != nil && v.TaskList != nil
}

type ListTaskListPartitionsResponse struct {
	ActivityTaskListPartitions []*TaskListPartitionMetadata `json:"activityTaskListPartitions,omitempty"`
	DecisionTaskListPartitions []*TaskListPartitionMetadata `json:"decisionTaskListPartitions,omitempty"`
}

type _List_TaskListPartitionMetadata_ValueList []*TaskListPartitionMetadata

func (v _List_TaskListPartitionMetadata_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_TaskListPartitionMetadata_ValueList) Size() int {
	return len(v)
}

func (_List_TaskListPartitionMetadata_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_TaskListPartitionMetadata_ValueList) Close() {}

// ToWire translates a ListTaskListPartitionsResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListTaskListPartitionsResponse) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ActivityTaskListPartitions != nil {
		w, err = wire.NewValueList(_List_TaskListPartitionMetadata_ValueList(v.ActivityTaskListPartitions)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.DecisionTaskListPartitions != nil {
		w, err = wire.NewValueList(_List_TaskListPartitionMetadata_ValueList(v.DecisionTaskListPartitions)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _TaskListPartitionMetadata_Read(w wire.Value) (*TaskListPartitionMetadata, error) {
	var v TaskListPartitionMetadata
	err := v.FromWire(w)
	return &v, err
}

func _List_TaskListPartitionMetadata_Read(l wire.ValueList) ([]*TaskListPartitionMetadata, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*TaskListPartitionMetadata, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _TaskListPartitionMetadata_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a ListTaskListPartitionsResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListTaskListPartitionsResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListTaskListPartitionsResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListTaskListPartitionsResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TList {
				v.ActivityTaskListPartitions, err = _List_TaskListPartitionMetadata_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TList {
				v.DecisionTaskListPartitions, err = _List_TaskListPartitionMetadata_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListTaskListPartitionsResponse
// struct.
func (v *ListTaskListPartitionsResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.ActivityTaskListPartitions != nil {
		fields[i] = fmt.Sprintf("ActivityTaskListPartitions: %v", v.ActivityTaskListPartitions)
		i++
	}
	if v.DecisionTaskListPartitions != nil {
		fields[i] = fmt.Sprintf("DecisionTaskListPartitions: %v", v.DecisionTaskListPartitions)
		i++
	}

	return fmt.Sprintf("ListTaskListPartitionsResponse{%v}", strings.Join(fields[:i], ", "))
}

func _List_TaskListPartitionMetadata_Equals(lhs, rhs []*TaskListPartitionMetadata) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ListTaskListPartitionsResponse match the
// provided ListTaskListPartitionsResponse.
//
// This function performs a deep comparison.
func (v *ListTaskListPartitionsResponse) Equals(rhs *ListTaskListPartitionsResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.ActivityTaskListPartitions == nil && rhs.ActivityTaskListPartitions == nil) || (v.ActivityTaskListPartitions != nil && rhs.ActivityTaskListPartitions != nil && _List_TaskListPartitionMetadata_Equals(v.ActivityTaskListPartitions, rhs.ActivityTaskListPartitions))) {
		return false
	}
	if !((v.DecisionTaskListPartitions == nil && rhs.DecisionTaskListPartitions == nil) || (v.DecisionTaskListPartitions != nil && rhs.DecisionTaskListPartitions != nil && _List_TaskListPartitionMetadata_Equals(v.DecisionTaskListPartitions, rhs.DecisionTaskListPartitions))) {
		return false
	}

	return true
}

type _List_TaskListPartitionMetadata_Zapper []*TaskListPartitionMetadata

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_TaskListPartitionMetadata_Zapper.
func (l _List_TaskListPartitionMetadata_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ListTaskListPartitionsResponse.
func (v *ListTaskListPartitionsResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ActivityTaskListPartitions != nil {
		err = multierr.Append(err, enc.AddArray("activityTaskListPartitions", (_List_TaskListPartitionMetadata_Zapper)(v.ActivityTaskListPartitions)))
	}
	if v.DecisionTaskListPartitions != nil {
		err = multierr.Append(err, enc.AddArray("decisionTaskListPartitions", (_List_TaskListPartitionMetadata_Zapper)(v.DecisionTaskListPartitions)))
	}
	return err
}

// GetActivityTaskListPartitions returns the value of ActivityTaskListPartitions if it is set or its
// zero value if it is unset.
func (v *ListTaskListPartitionsResponse) GetActivityTaskListPartitions() (o []*TaskListPartitionMetadata) {
	if v != nil && v.ActivityTaskListPartitions != nil {
		return v.ActivityTaskListPartitions
	}

	return
}

// IsSetActivityTaskListPartitions returns true if ActivityTaskListPartitions is not nil.
func (v *ListTaskListPartitionsResponse) IsSetActivityTaskListPartitions() bool {
	return v != nil && v.ActivityTaskListPartitions != nil
}

// GetDecisionTaskListPartitions returns the value of DecisionTaskListPartitions if it is set or its
// zero value if it is unset.
func (v *ListTaskListPartitionsResponse) GetDecisionTaskListPartitions() (o []*TaskListPartitionMetadata) {
	if v != nil && v.DecisionTaskListPartitions != nil {
		return v.DecisionTaskListPartitions
	}

	return
}

// IsSetDecisionTaskListPartitions returns true if DecisionTaskListPartitions is not nil.
func (v *ListTaskListPartitionsResponse) IsSetDecisionTaskListPartitions() bool {
	return v != nil && v.DecisionTaskListPartitions != nil
}

type ListWorkflowExecutionsRequest struct {
	Domain        *string `json:"domain,omitempty"`
	PageSize      *int32  `json:"pageSize,omitempty"`
	NextPageToken []byte  `json:"nextPageToken,omitempty"`
	Query         *string `json:"query,omitempty"`
}

// ToWire translates a ListWorkflowExecutionsRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListWorkflowExecutionsRequest) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Domain != nil {
		w, err = wire.NewValueString(*(v.Domain)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.PageSize != nil {
		w, err = wire.NewValueI32(*(v.PageSize)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.NextPageToken != nil {
		w, err = wire.NewValueBinary(v.NextPageToken), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.Query != nil {
		w, err = wire.NewValueString(*(v.Query)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ListWorkflowExecutionsRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListWorkflowExecutionsRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListWorkflowExecutionsRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListWorkflowExecutionsRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Domain = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.PageSize = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				v.NextPageToken, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Query = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListWorkflowExecutionsRequest
// struct.
func (v *ListWorkflowExecutionsRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Domain != nil {
		fields[i] = fmt.Sprintf("Domain: %v", *(v.Domain))
		i++
	}
	if v.PageSize != nil {
		fields[i] = fmt.Sprintf("PageSize: %v", *(v.PageSize))
		i++
	}
	if v.NextPageToken != nil {
		fields[i] = fmt.Sprintf("NextPageToken: %v", v.NextPageToken)
		i++
	}
	if v.Query != nil {
		fields[i] = fmt.Sprintf("Query: %v", *(v.Query))
		i++
	}

	return fmt.Sprintf("ListWorkflowExecutionsRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ListWorkflowExecutionsRequest match the
// provided ListWorkflowExecutionsRequest.
//
// This function performs a deep comparison.
func (v *ListWorkflowExecutionsRequest) Equals(rhs *ListWorkflowExecutionsRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Domain, rhs.Domain) {
		return false
	}
	if !_I32_EqualsPtr(v.PageSize, rhs.PageSize) {
		return false
	}
	if !((v.NextPageToken == nil && rhs.NextPageToken == nil) || (v.NextPageToken != nil && rhs.NextPageToken != nil && bytes.Equal(v.NextPageToken, rhs.NextPageToken))) {
		return false
	}
	if !_String_EqualsPtr(v.Query, rhs.Query) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ListWorkflowExecutionsRequest.
func (v *ListWorkflowExecutionsRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Domain != nil {
		enc.AddString("domain", *v.Domain)
	}
	if v.PageSize != nil {
		enc.AddInt32("pageSize", *v.PageSize)
	}
	if v.NextPageToken != nil {
		enc.AddString("nextPageToken", base64.StdEncoding.EncodeToString(v.NextPageToken))
	}
	if v.Query != nil {
		enc.AddString("query", *v.Query)
	}
	return err
}

// GetDomain returns the value of Domain if it is set or its
// zero value if it is unset.
func (v *ListWorkflowExecutionsRequest) GetDomain() (o string) {
	if v != nil && v.Domain != nil {
		return *v.Domain
	}

	return
}

// IsSetDomain returns true if Domain is not nil.
func (v *ListWorkflowExecutionsRequest) IsSetDomain() bool {
	return v != nil && v.Domain != nil
}

// GetPageSize returns the value of PageSize if it is set or its
// zero value if it is unset.
func (v *ListWorkflowExecutionsRequest) GetPageSize() (o int32) {
	if v != nil && v.PageSize != nil {
		return *v.PageSize
	}

	return
}

// IsSetPageSize returns true if PageSize is not nil.
func (v *ListWorkflowExecutionsRequest) IsSetPageSize() bool {
	return v != nil && v.PageSize != nil
}

// GetNextPageToken returns the value of NextPageToken if it is set or its
// zero value if it is unset.
func (v *ListWorkflowExecutionsRequest) GetNextPageToken() (o []byte) {
	if v != nil && v.NextPageToken != nil {
		return v.NextPageToken
	}

	return
}

// IsSetNextPageToken returns true if NextPageToken is not nil.
func (v *ListWorkflowExecutionsRequest) IsSetNextPageToken() bool {
	return v != nil && v.NextPageToken != nil
}

// GetQuery returns the value of Query if it is set or its
// zero value if it is unset.
func (v *ListWorkflowExecutionsRequest) GetQuery() (o string) {
	if v != nil && v.Query != nil {
		return *v.Query
	}

	return
}

// IsSetQuery returns true if Query is not nil.
func (v *ListWorkflowExecutionsRequest) IsSetQuery() bool {
	return v != nil && v.Query != nil
}

type ParentClosePolicy int32

const (
	ParentClosePolicyAbandon       ParentClosePolicy = 0
	ParentClosePolicyRequestCancel ParentClosePolicy = 1
	ParentClosePolicyTerminate     ParentClosePolicy = 2
)

// ParentClosePolicy_Values returns all recognized values of ParentClosePolicy.
func ParentClosePolicy_Values() []ParentClosePolicy {
	return []ParentClosePolicy{
		ParentClosePolicyAbandon,
		ParentClosePolicyRequestCancel,
		ParentClosePolicyTerminate,
	}
}

// UnmarshalText tries to decode ParentClosePolicy from a byte slice
// containing its name.
//
//   var v ParentClosePolicy
//   err := v.UnmarshalText([]byte("ABANDON"))
func (v *ParentClosePolicy) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "ABANDON":
		*v = ParentClosePolicyAbandon
		return nil
	case "REQUEST_CANCEL":
		*v = ParentClosePolicyRequestCancel
		return nil
	case "TERMINATE":
		*v = ParentClosePolicyTerminate
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "ParentClosePolicy", err)
		}
		*v = ParentClosePolicy(val)
		return nil
	}
}

// MarshalText encodes ParentClosePolicy to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v ParentClosePolicy) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("ABANDON"), nil
	case 1:
		return []byte("REQUEST_CANCEL"), nil
	case 2:
		return []byte("TERMINATE"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ParentClosePolicy.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v ParentClosePolicy) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "ABANDON")
	case 1:
		enc.AddString("name", "REQUEST_CANCEL")
	case 2:
		enc.AddString("name", "TERMINATE")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v ParentClosePolicy) Ptr() *ParentClosePolicy {
	return &v
}

// ToWire translates ParentClosePolicy into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v ParentClosePolicy) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes ParentClosePolicy from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return ParentClosePolicy(0), err
//   }
//
//   var v ParentClosePolicy
//   if err := v.FromWire(x); err != nil {
//     return ParentClosePolicy(0), err
//   }
//   return v, nil
func (v *ParentClosePolicy) FromWire(w wire.Value) error {
	*v = (ParentClosePolicy)(w.GetI32())
	return nil
}

// String returns a readable string representation of ParentClosePolicy.
func (v ParentClosePolicy) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "ABANDON"
	case 1:
		return "REQUEST_CANCEL"
	case 2:
		return "TERMINATE"
	}
	return fmt.Sprintf("ParentClosePolicy(%d)", w)
}

// Equals returns true if this ParentClosePolicy value matches the provided
// value.
func (v ParentClosePolicy) Equals(rhs ParentClosePolicy) bool {
	return v == rhs
}

// MarshalJSON serializes ParentClosePolicy into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v ParentClosePolicy) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"ABANDON\""), nil
	case 1:
		return ([]byte)("\"REQUEST_CANCEL\""), nil
	case 2:
		return ([]byte)("\"TERMINATE\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode ParentClosePolicy from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *ParentClosePolicy) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "ParentClosePolicy")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "ParentClosePolicy")
		}
		*v = (ParentClosePolicy)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "ParentClosePolicy")
	}
}

type PendingActivityInfo struct {
	ActivityID             *string               `json:"activityID,omitempty"`
	ActivityType           *ActivityType         `json:"activityType,omitempty"`
	State                  *PendingActivityState `json:"state,omitempty"`
	HeartbeatDetails       []byte                `json:"heartbeatDetails,omitempty"`
	LastHeartbeatTimestamp *int64                `json:"lastHeartbeatTimestamp,omitempty"`
	LastStartedTimestamp   *int64                `json:"lastStartedTimestamp,omitempty"`
	Attempt                *int32                `json:"attempt,omitempty"`
	MaximumAttempts        *int32                `json:"maximumAttempts,omitempty"`
	ScheduledTimestamp     *int64                `json:"scheduledTimestamp,omitempty"`
	ExpirationTimestamp    *int64                `json:"expirationTimestamp,omitempty"`
	LastFailureReason      *string               `json:"lastFailureReason,omitempty"`
	LastWorkerIdentity     *string               `json:"lastWorkerIdentity,omitempty"`
	LastFailureDetails     []byte                `json:"lastFailureDetails,omitempty"`
}

// ToWire translates a PendingActivityInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PendingActivityInfo) ToWire() (wire.Value, error) {
	var (
		fields [13]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ActivityID != nil {
		w, err = wire.NewValueString(*(v.ActivityID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.ActivityType != nil {
		w, err = v.ActivityType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.State != nil {
		w, err = v.State.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.HeartbeatDetails != nil {
		w, err = wire.NewValueBinary(v.HeartbeatDetails), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.LastHeartbeatTimestamp != nil {
		w, err = wire.NewValueI64(*(v.LastHeartbeatTimestamp)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.LastStartedTimestamp != nil {
		w, err = wire.NewValueI64(*(v.LastStartedTimestamp)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}
	if v.Attempt != nil {
		w, err = wire.NewValueI32(*(v.Attempt)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 70, Value: w}
		i++
	}
	if v.MaximumAttempts != nil {
		w, err = wire.NewValueI32(*(v.MaximumAttempts)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 80, Value: w}
		i++
	}
	if v.ScheduledTimestamp != nil {
		w, err = wire.NewValueI64(*(v.ScheduledTimestamp)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 90, Value: w}
		i++
	}
	if v.ExpirationTimestamp != nil {
		w, err = wire.NewValueI64(*(v.ExpirationTimestamp)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 100, Value: w}
		i++
	}
	if v.LastFailureReason != nil {
		w, err = wire.NewValueString(*(v.LastFailureReason)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 110, Value: w}
		i++
	}
	if v.LastWorkerIdentity != nil {
		w, err = wire.NewValueString(*(v.LastWorkerIdentity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 120, Value: w}
		i++
	}
	if v.LastFailureDetails != nil {
		w, err = wire.NewValueBinary(v.LastFailureDetails), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 130, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ActivityType_Read(w wire.Value) (*ActivityType, error) {
	var v ActivityType
	err := v.FromWire(w)
	return &v, err
}

func _PendingActivityState_Read(w wire.Value) (PendingActivityState, error) {
	var v PendingActivityState
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a PendingActivityInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PendingActivityInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PendingActivityInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PendingActivityInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ActivityID = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TStruct {
				v.ActivityType, err = _ActivityType_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TI32 {
				var x PendingActivityState
				x, err = _PendingActivityState_Read(field.Value)
				v.State = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				v.HeartbeatDetails, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.LastHeartbeatTimestamp = &x
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.LastStartedTimestamp = &x
				if err != nil {
					return err
				}

			}
		case 70:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Attempt = &x
				if err != nil {
					return err
				}

			}
		case 80:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.MaximumAttempts = &x
				if err != nil {
					return err
				}

			}
		case 90:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ScheduledTimestamp = &x
				if err != nil {
					return err
				}

			}
		case 100:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ExpirationTimestamp = &x
				if err != nil {
					return err
				}

			}
		case 110:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.LastFailureReason = &x
				if err != nil {
					return err
				}

			}
		case 120:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.LastWorkerIdentity = &x
				if err != nil {
					return err
				}

			}
		case 130:
			if field.Value.Type() == wire.TBinary {
				v.LastFailureDetails, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a PendingActivityInfo
// struct.
func (v *PendingActivityInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [13]string
	i := 0
	if v.ActivityID != nil {
		fields[i] = fmt.Sprintf("ActivityID: %v", *(v.ActivityID))
		i++
	}
	if v.ActivityType != nil {
		fields[i] = fmt.Sprintf("ActivityType: %v", v.ActivityType)
		i++
	}
	if v.State != nil {
		fields[i] = fmt.Sprintf("State: %v", *(v.State))
		i++
	}
	if v.HeartbeatDetails != nil {
		fields[i] = fmt.Sprintf("HeartbeatDetails: %v", v.HeartbeatDetails)
		i++
	}
	if v.LastHeartbeatTimestamp != nil {
		fields[i] = fmt.Sprintf("LastHeartbeatTimestamp: %v", *(v.LastHeartbeatTimestamp))
		i++
	}
	if v.LastStartedTimestamp != nil {
		fields[i] = fmt.Sprintf("LastStartedTimestamp: %v", *(v.LastStartedTimestamp))
		i++
	}
	if v.Attempt != nil {
		fields[i] = fmt.Sprintf("Attempt: %v", *(v.Attempt))
		i++
	}
	if v.MaximumAttempts != nil {
		fields[i] = fmt.Sprintf("MaximumAttempts: %v", *(v.MaximumAttempts))
		i++
	}
	if v.ScheduledTimestamp != nil {
		fields[i] = fmt.Sprintf("ScheduledTimestamp: %v", *(v.ScheduledTimestamp))
		i++
	}
	if v.ExpirationTimestamp != nil {
		fields[i] = fmt.Sprintf("ExpirationTimestamp: %v", *(v.ExpirationTimestamp))
		i++
	}
	if v.LastFailureReason != nil {
		fields[i] = fmt.Sprintf("LastFailureReason: %v", *(v.LastFailureReason))
		i++
	}
	if v.LastWorkerIdentity != nil {
		fields[i] = fmt.Sprintf("LastWorkerIdentity: %v", *(v.LastWorkerIdentity))
		i++
	}
	if v.LastFailureDetails != nil {
		fields[i] = fmt.Sprintf("LastFailureDetails: %v", v.LastFailureDetails)
		i++
	}

	return fmt.Sprintf("PendingActivityInfo{%v}", strings.Join(fields[:i], ", "))
}

func _PendingActivityState_EqualsPtr(lhs, rhs *PendingActivityState) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this PendingActivityInfo match the
// provided PendingActivityInfo.
//
// This function performs a deep comparison.
func (v *PendingActivityInfo) Equals(rhs *PendingActivityInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.ActivityID, rhs.ActivityID) {
		return false
	}
	if !((v.ActivityType == nil && rhs.ActivityType == nil) || (v.ActivityType != nil && rhs.ActivityType != nil && v.ActivityType.Equals(rhs.ActivityType))) {
		return false
	}
	if !_PendingActivityState_EqualsPtr(v.State, rhs.State) {
		return false
	}
	if !((v.HeartbeatDetails == nil && rhs.HeartbeatDetails == nil) || (v.HeartbeatDetails != nil && rhs.HeartbeatDetails != nil && bytes.Equal(v.HeartbeatDetails, rhs.HeartbeatDetails))) {
		return false
	}
	if !_I64_EqualsPtr(v.LastHeartbeatTimestamp, rhs.LastHeartbeatTimestamp) {
		return false
	}
	if !_I64_EqualsPtr(v.LastStartedTimestamp, rhs.LastStartedTimestamp) {
		return false
	}
	if !_I32_EqualsPtr(v.Attempt, rhs.Attempt) {
		return false
	}
	if !_I32_EqualsPtr(v.MaximumAttempts, rhs.MaximumAttempts) {
		return false
	}
	if !_I64_EqualsPtr(v.ScheduledTimestamp, rhs.ScheduledTimestamp) {
		return false
	}
	if !_I64_EqualsPtr(v.ExpirationTimestamp, rhs.ExpirationTimestamp) {
		return false
	}
	if !_String_EqualsPtr(v.LastFailureReason, rhs.LastFailureReason) {
		return false
	}
	if !_String_EqualsPtr(v.LastWorkerIdentity, rhs.LastWorkerIdentity) {
		return false
	}
	if !((v.LastFailureDetails == nil && rhs.LastFailureDetails == nil) || (v.LastFailureDetails != nil && rhs.LastFailureDetails != nil && bytes.Equal(v.LastFailureDetails, rhs.LastFailureDetails))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of PendingActivityInfo.
func (v *PendingActivityInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ActivityID != nil {
		enc.AddString("activityID", *v.ActivityID)
	}
	if v.ActivityType != nil {
		err = multierr.Append(err, enc.AddObject("activityType", v.ActivityType))
	}
	if v.State != nil {
		err = multierr.Append(err, enc.AddObject("state", *v.State))
	}
	if v.HeartbeatDetails != nil {
		enc.AddString("heartbeatDetails", base64.StdEncoding.EncodeToString(v.HeartbeatDetails))
	}
	if v.LastHeartbeatTimestamp != nil {
		enc.AddInt64("lastHeartbeatTimestamp", *v.LastHeartbeatTimestamp)
	}
	if v.LastStartedTimestamp != nil {
		enc.AddInt64("lastStartedTimestamp", *v.LastStartedTimestamp)
	}
	if v.Attempt != nil {
		enc.AddInt32("attempt", *v.Attempt)
	}
	if v.MaximumAttempts != nil {
		enc.AddInt32("maximumAttempts", *v.MaximumAttempts)
	}
	if v.ScheduledTimestamp != nil {
		enc.AddInt64("scheduledTimestamp", *v.ScheduledTimestamp)
	}
	if v.ExpirationTimestamp != nil {
		enc.AddInt64("expirationTimestamp", *v.ExpirationTimestamp)
	}
	if v.LastFailureReason != nil {
		enc.AddString("lastFailureReason", *v.LastFailureReason)
	}
	if v.LastWorkerIdentity != nil {
		enc.AddString("lastWorkerIdentity", *v.LastWorkerIdentity)
	}
	if v.LastFailureDetails != nil {
		enc.AddString("lastFailureDetails", base64.StdEncoding.EncodeToString(v.LastFailureDetails))
	}
	return err
}

// GetActivityID returns the value of ActivityID if it is set or its
// zero value if it is unset.
func (v *PendingActivityInfo) GetActivityID() (o string) {
	if v != nil && v.ActivityID != nil {
		return *v.ActivityID
	}

	return
}

// IsSetActivityID returns true if ActivityID is not nil.
func (v *PendingActivityInfo) IsSetActivityID() bool {
	return v != nil && v.ActivityID != nil
}

// GetActivityType returns the value of ActivityType if it is set or its
// zero value if it is unset.
func (v *PendingActivityInfo) GetActivityType() (o *ActivityType) {
	if v != nil && v.ActivityType != nil {
		return v.ActivityType
	}

	return
}

// IsSetActivityType returns true if ActivityType is not nil.
func (v *PendingActivityInfo) IsSetActivityType() bool {
	return v != nil && v.ActivityType != nil
}

// GetState returns the value of State if it is set or its
// zero value if it is unset.
func (v *PendingActivityInfo) GetState() (o PendingActivityState) {
	if v != nil && v.State != nil {
		return *v.State
	}

	return
}

// IsSetState returns true if State is not nil.
func (v *PendingActivityInfo) IsSetState() bool {
	return v != nil && v.State != nil
}

// GetHeartbeatDetails returns the value of HeartbeatDetails if it is set or its
// zero value if it is unset.
func (v *PendingActivityInfo) GetHeartbeatDetails() (o []byte) {
	if v != nil && v.HeartbeatDetails != nil {
		return v.HeartbeatDetails
	}

	return
}

// IsSetHeartbeatDetails returns true if HeartbeatDetails is not nil.
func (v *PendingActivityInfo) IsSetHeartbeatDetails() bool {
	return v != nil && v.HeartbeatDetails != nil
}

// GetLastHeartbeatTimestamp returns the value of LastHeartbeatTimestamp if it is set or its
// zero value if it is unset.
func (v *PendingActivityInfo) GetLastHeartbeatTimestamp() (o int64) {
	if v != nil && v.LastHeartbeatTimestamp != nil {
		return *v.LastHeartbeatTimestamp
	}

	return
}

// IsSetLastHeartbeatTimestamp returns true if LastHeartbeatTimestamp is not nil.
func (v *PendingActivityInfo) IsSetLastHeartbeatTimestamp() bool {
	return v != nil && v.LastHeartbeatTimestamp != nil
}

// GetLastStartedTimestamp returns the value of LastStartedTimestamp if it is set or its
// zero value if it is unset.
func (v *PendingActivityInfo) GetLastStartedTimestamp() (o int64) {
	if v != nil && v.LastStartedTimestamp != nil {
		return *v.LastStartedTimestamp
	}

	return
}

// IsSetLastStartedTimestamp returns true if LastStartedTimestamp is not nil.
func (v *PendingActivityInfo) IsSetLastStartedTimestamp() bool {
	return v != nil && v.LastStartedTimestamp != nil
}

// GetAttempt returns the value of Attempt if it is set or its
// zero value if it is unset.
func (v *PendingActivityInfo) GetAttempt() (o int32) {
	if v != nil && v.Attempt != nil {
		return *v.Attempt
	}

	return
}

// IsSetAttempt returns true if Attempt is not nil.
func (v *PendingActivityInfo) IsSetAttempt() bool {
	return v != nil && v.Attempt != nil
}

// GetMaximumAttempts returns the value of MaximumAttempts if it is set or its
// zero value if it is unset.
func (v *PendingActivityInfo) GetMaximumAttempts() (o int32) {
	if v != nil && v.MaximumAttempts != nil {
		return *v.MaximumAttempts
	}

	return
}

// IsSetMaximumAttempts returns true if MaximumAttempts is not nil.
func (v *PendingActivityInfo) IsSetMaximumAttempts() bool {
	return v != nil && v.MaximumAttempts != nil
}

// GetScheduledTimestamp returns the value of ScheduledTimestamp if it is set or its
// zero value if it is unset.
func (v *PendingActivityInfo) GetScheduledTimestamp() (o int64) {
	if v != nil && v.ScheduledTimestamp != nil {
		return *v.ScheduledTimestamp
	}

	return
}

// IsSetScheduledTimestamp returns true if ScheduledTimestamp is not nil.
func (v *PendingActivityInfo) IsSetScheduledTimestamp() bool {
	return v != nil && v.ScheduledTimestamp != nil
}

// GetExpirationTimestamp returns the value of ExpirationTimestamp if it is set or its
// zero value if it is unset.
func (v *PendingActivityInfo) GetExpirationTimestamp() (o int64) {
	if v != nil && v.ExpirationTimestamp != nil {
		return *v.ExpirationTimestamp
	}

	return
}

// IsSetExpirationTimestamp returns true if ExpirationTimestamp is not nil.
func (v *PendingActivityInfo) IsSetExpirationTimestamp() bool {
	return v != nil && v.ExpirationTimestamp != nil
}

// GetLastFailureReason returns the value of LastFailureReason if it is set or its
// zero value if it is unset.
func (v *PendingActivityInfo) GetLastFailureReason() (o string) {
	if v != nil && v.LastFailureReason != nil {
		return *v.LastFailureReason
	}

	return
}

// IsSetLastFailureReason returns true if LastFailureReason is not nil.
func (v *PendingActivityInfo) IsSetLastFailureReason() bool {
	return v != nil && v.LastFailureReason != nil
}

// GetLastWorkerIdentity returns the value of LastWorkerIdentity if it is set or its
// zero value if it is unset.
func (v *PendingActivityInfo) GetLastWorkerIdentity() (o string) {
	if v != nil && v.LastWorkerIdentity != nil {
		return *v.LastWorkerIdentity
	}

	return
}

// IsSetLastWorkerIdentity returns true if LastWorkerIdentity is not nil.
func (v *PendingActivityInfo) IsSetLastWorkerIdentity() bool {
	return v != nil && v.LastWorkerIdentity != nil
}

// GetLastFailureDetails returns the value of LastFailureDetails if it is set or its
// zero value if it is unset.
func (v *PendingActivityInfo) GetLastFailureDetails() (o []byte) {
	if v != nil && v.LastFailureDetails != nil {
		return v.LastFailureDetails
	}

	return
}

// IsSetLastFailureDetails returns true if LastFailureDetails is not nil.
func (v *PendingActivityInfo) IsSetLastFailureDetails() bool {
	return v != nil && v.LastFailureDetails != nil
}

type PendingActivityState int32

const (
	PendingActivityStateScheduled       PendingActivityState = 0
	PendingActivityStateStarted         PendingActivityState = 1
	PendingActivityStateCancelRequested PendingActivityState = 2
)

// PendingActivityState_Values returns all recognized values of PendingActivityState.
func PendingActivityState_Values() []PendingActivityState {
	return []PendingActivityState{
		PendingActivityStateScheduled,
		PendingActivityStateStarted,
		PendingActivityStateCancelRequested,
	}
}

// UnmarshalText tries to decode PendingActivityState from a byte slice
// containing its name.
//
//   var v PendingActivityState
//   err := v.UnmarshalText([]byte("SCHEDULED"))
func (v *PendingActivityState) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "SCHEDULED":
		*v = PendingActivityStateScheduled
		return nil
	case "STARTED":
		*v = PendingActivityStateStarted
		return nil
	case "CANCEL_REQUESTED":
		*v = PendingActivityStateCancelRequested
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "PendingActivityState", err)
		}
		*v = PendingActivityState(val)
		return nil
	}
}

// MarshalText encodes PendingActivityState to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v PendingActivityState) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("SCHEDULED"), nil
	case 1:
		return []byte("STARTED"), nil
	case 2:
		return []byte("CANCEL_REQUESTED"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of PendingActivityState.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v PendingActivityState) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "SCHEDULED")
	case 1:
		enc.AddString("name", "STARTED")
	case 2:
		enc.AddString("name", "CANCEL_REQUESTED")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v PendingActivityState) Ptr() *PendingActivityState {
	return &v
}

// ToWire translates PendingActivityState into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v PendingActivityState) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes PendingActivityState from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return PendingActivityState(0), err
//   }
//
//   var v PendingActivityState
//   if err := v.FromWire(x); err != nil {
//     return PendingActivityState(0), err
//   }
//   return v, nil
func (v *PendingActivityState) FromWire(w wire.Value) error {
	*v = (PendingActivityState)(w.GetI32())
	return nil
}

// String returns a readable string representation of PendingActivityState.
func (v PendingActivityState) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "SCHEDULED"
	case 1:
		return "STARTED"
	case 2:
		return "CANCEL_REQUESTED"
	}
	return fmt.Sprintf("PendingActivityState(%d)", w)
}

// Equals returns true if this PendingActivityState value matches the provided
// value.
func (v PendingActivityState) Equals(rhs PendingActivityState) bool {
	return v == rhs
}

// MarshalJSON serializes PendingActivityState into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v PendingActivityState) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"SCHEDULED\""), nil
	case 1:
		return ([]byte)("\"STARTED\""), nil
	case 2:
		return ([]byte)("\"CANCEL_REQUESTED\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode PendingActivityState from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *PendingActivityState) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "PendingActivityState")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "PendingActivityState")
		}
		*v = (PendingActivityState)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "PendingActivityState")
	}
}

type PendingChildExecutionInfo struct {
	WorkflowID        *string            `json:"workflowID,omitempty"`
	RunID             *string            `json:"runID,omitempty"`
	WorkflowTypName   *string            `json:"workflowTypName,omitempty"`
	InitiatedID       *int64             `json:"initiatedID,omitempty"`
	ParentClosePolicy *ParentClosePolicy `json:"parentClosePolicy,omitempty"`
}

// ToWire translates a PendingChildExecutionInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PendingChildExecutionInfo) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.WorkflowID != nil {
		w, err = wire.NewValueString(*(v.WorkflowID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.RunID != nil {
		w, err = wire.NewValueString(*(v.RunID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.WorkflowTypName != nil {
		w, err = wire.NewValueString(*(v.WorkflowTypName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.InitiatedID != nil {
		w, err = wire.NewValueI64(*(v.InitiatedID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.ParentClosePolicy != nil {
		w, err = v.ParentClosePolicy.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ParentClosePolicy_Read(w wire.Value) (ParentClosePolicy, error) {
	var v ParentClosePolicy
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a PendingChildExecutionInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PendingChildExecutionInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PendingChildExecutionInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PendingChildExecutionInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.WorkflowID = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RunID = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.WorkflowTypName = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.InitiatedID = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TI32 {
				var x ParentClosePolicy
				x, err = _ParentClosePolicy_Read(field.Value)
				v.ParentClosePolicy = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a PendingChildExecutionInfo
// struct.
func (v *PendingChildExecutionInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.WorkflowID != nil {
		fields[i] = fmt.Sprintf("WorkflowID: %v", *(v.WorkflowID))
		i++
	}
	if v.RunID != nil {
		fields[i] = fmt.Sprintf("RunID: %v", *(v.RunID))
		i++
	}
	if v.WorkflowTypName != nil {
		fields[i] = fmt.Sprintf("WorkflowTypName: %v", *(v.WorkflowTypName))
		i++
	}
	if v.InitiatedID != nil {
		fields[i] = fmt.Sprintf("InitiatedID: %v", *(v.InitiatedID))
		i++
	}
	if v.ParentClosePolicy != nil {
		fields[i] = fmt.Sprintf("ParentClosePolicy: %v", *(v.ParentClosePolicy))
		i++
	}

	return fmt.Sprintf("PendingChildExecutionInfo{%v}", strings.Join(fields[:i], ", "))
}

func _ParentClosePolicy_EqualsPtr(lhs, rhs *ParentClosePolicy) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this PendingChildExecutionInfo match the
// provided PendingChildExecutionInfo.
//
// This function performs a deep comparison.
func (v *PendingChildExecutionInfo) Equals(rhs *PendingChildExecutionInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.WorkflowID, rhs.WorkflowID) {
		return false
	}
	if !_String_EqualsPtr(v.RunID, rhs.RunID) {
		return false
	}
	if !_String_EqualsPtr(v.WorkflowTypName, rhs.WorkflowTypName) {
		return false
	}
	if !_I64_EqualsPtr(v.InitiatedID, rhs.InitiatedID) {
		return false
	}
	if !_ParentClosePolicy_EqualsPtr(v.ParentClosePolicy, rhs.ParentClosePolicy) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of PendingChildExecutionInfo.
func (v *PendingChildExecutionInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.WorkflowID != nil {
		enc.AddString("workflowID", *v.WorkflowID)
	}
	if v.RunID != nil {
		enc.AddString("runID", *v.RunID)
	}
	if v.WorkflowTypName != nil {
		enc.AddString("workflowTypName", *v.WorkflowTypName)
	}
	if v.InitiatedID != nil {
		enc.AddInt64("initiatedID", *v.InitiatedID)
	}
	if v.ParentClosePolicy != nil {
		err = multierr.Append(err, enc.AddObject("parentClosePolicy", *v.ParentClosePolicy))
	}
	return err
}

// GetWorkflowID returns the value of WorkflowID if it is set or its
// zero value if it is unset.
func (v *PendingChildExecutionInfo) GetWorkflowID() (o string) {
	if v != nil && v.WorkflowID != nil {
		return *v.WorkflowID
	}

	return
}

// IsSetWorkflowID returns true if WorkflowID is not nil.
func (v *PendingChildExecutionInfo) IsSetWorkflowID() bool {
	return v != nil && v.WorkflowID != nil
}

// GetRunID returns the value of RunID if it is set or its
// zero value if it is unset.
func (v *PendingChildExecutionInfo) GetRunID() (o string) {
	if v != nil && v.RunID != nil {
		return *v.RunID
	}

	return
}

// IsSetRunID returns true if RunID is not nil.
func (v *PendingChildExecutionInfo) IsSetRunID() bool {
	return v != nil && v.RunID != nil
}

// GetWorkflowTypName returns the value of WorkflowTypName if it is set or its
// zero value if it is unset.
func (v *PendingChildExecutionInfo) GetWorkflowTypName() (o string) {
	if v != nil && v.WorkflowTypName != nil {
		return *v.WorkflowTypName
	}

	return
}

// IsSetWorkflowTypName returns true if WorkflowTypName is not nil.
func (v *PendingChildExecutionInfo) IsSetWorkflowTypName() bool {
	return v != nil && v.WorkflowTypName != nil
}

// GetInitiatedID returns the value of InitiatedID if it is set or its
// zero value if it is unset.
func (v *PendingChildExecutionInfo) GetInitiatedID() (o int64) {
	if v != nil && v.InitiatedID != nil {
		return *v.InitiatedID
	}

	return
}

// IsSetInitiatedID returns true if InitiatedID is not nil.
func (v *PendingChildExecutionInfo) IsSetInitiatedID() bool {
	return v != nil && v.InitiatedID != nil
}

// GetParentClosePolicy returns the value of ParentClosePolicy if it is set or its
// zero value if it is unset.
func (v *PendingChildExecutionInfo) GetParentClosePolicy() (o ParentClosePolicy) {
	if v != nil && v.ParentClosePolicy != nil {
		return *v.ParentClosePolicy
	}

	return
}

// IsSetParentClosePolicy returns true if ParentClosePolicy is not nil.
func (v *PendingChildExecutionInfo) IsSetParentClosePolicy() bool {
	return v != nil && v.ParentClosePolicy != nil
}

type PollForActivityTaskRequest struct {
	Domain           *string           `json:"domain,omitempty"`
	TaskList         *TaskList         `json:"taskList,omitempty"`
	Identity         *string           `json:"identity,omitempty"`
	TaskListMetadata *TaskListMetadata `json:"taskListMetadata,omitempty"`
}

// ToWire translates a PollForActivityTaskRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PollForActivityTaskRequest) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Domain != nil {
		w, err = wire.NewValueString(*(v.Domain)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.TaskList != nil {
		w, err = v.TaskList.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.Identity != nil {
		w, err = wire.NewValueString(*(v.Identity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.TaskListMetadata != nil {
		w, err = v.TaskListMetadata.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _TaskListMetadata_Read(w wire.Value) (*TaskListMetadata, error) {
	var v TaskListMetadata
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a PollForActivityTaskRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PollForActivityTaskRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PollForActivityTaskRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PollForActivityTaskRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Domain = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TStruct {
				v.TaskList, err = _TaskList_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Identity = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TStruct {
				v.TaskListMetadata, err = _TaskListMetadata_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a PollForActivityTaskRequest
// struct.
func (v *PollForActivityTaskRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Domain != nil {
		fields[i] = fmt.Sprintf("Domain: %v", *(v.Domain))
		i++
	}
	if v.TaskList != nil {
		fields[i] = fmt.Sprintf("TaskList: %v", v.TaskList)
		i++
	}
	if v.Identity != nil {
		fields[i] = fmt.Sprintf("Identity: %v", *(v.Identity))
		i++
	}
	if v.TaskListMetadata != nil {
		fields[i] = fmt.Sprintf("TaskListMetadata: %v", v.TaskListMetadata)
		i++
	}

	return fmt.Sprintf("PollForActivityTaskRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this PollForActivityTaskRequest match the
// provided PollForActivityTaskRequest.
//
// This function performs a deep comparison.
func (v *PollForActivityTaskRequest) Equals(rhs *PollForActivityTaskRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Domain, rhs.Domain) {
		return false
	}
	if !((v.TaskList == nil && rhs.TaskList == nil) || (v.TaskList != nil && rhs.TaskList != nil && v.TaskList.Equals(rhs.TaskList))) {
		return false
	}
	if !_String_EqualsPtr(v.Identity, rhs.Identity) {
		return false
	}
	if !((v.TaskListMetadata == nil && rhs.TaskListMetadata == nil) || (v.TaskListMetadata != nil && rhs.TaskListMetadata != nil && v.TaskListMetadata.Equals(rhs.TaskListMetadata))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of PollForActivityTaskRequest.
func (v *PollForActivityTaskRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Domain != nil {
		enc.AddString("domain", *v.Domain)
	}
	if v.TaskList != nil {
		err = multierr.Append(err, enc.AddObject("taskList", v.TaskList))
	}
	if v.Identity != nil {
		enc.AddString("identity", *v.Identity)
	}
	if v.TaskListMetadata != nil {
		err = multierr.Append(err, enc.AddObject("taskListMetadata", v.TaskListMetadata))
	}
	return err
}

// GetDomain returns the value of Domain if it is set or its
// zero value if it is unset.
func (v *PollForActivityTaskRequest) GetDomain() (o string) {
	if v != nil && v.Domain != nil {
		return *v.Domain
	}

	return
}

// IsSetDomain returns true if Domain is not nil.
func (v *PollForActivityTaskRequest) IsSetDomain() bool {
	return v != nil && v.Domain != nil
}

// GetTaskList returns the value of TaskList if it is set or its
// zero value if it is unset.
func (v *PollForActivityTaskRequest) GetTaskList() (o *TaskList) {
	if v != nil && v.TaskList != nil {
		return v.TaskList
	}

	return
}

// IsSetTaskList returns true if TaskList is not nil.
func (v *PollForActivityTaskRequest) IsSetTaskList() bool {
	return v != nil && v.TaskList != nil
}

// GetIdentity returns the value of Identity if it is set or its
// zero value if it is unset.
func (v *PollForActivityTaskRequest) GetIdentity() (o string) {
	if v != nil && v.Identity != nil {
		return *v.Identity
	}

	return
}

// IsSetIdentity returns true if Identity is not nil.
func (v *PollForActivityTaskRequest) IsSetIdentity() bool {
	return v != nil && v.Identity != nil
}

// GetTaskListMetadata returns the value of TaskListMetadata if it is set or its
// zero value if it is unset.
func (v *PollForActivityTaskRequest) GetTaskListMetadata() (o *TaskListMetadata) {
	if v != nil && v.TaskListMetadata != nil {
		return v.TaskListMetadata
	}

	return
}

// IsSetTaskListMetadata returns true if TaskListMetadata is not nil.
func (v *PollForActivityTaskRequest) IsSetTaskListMetadata() bool {
	return v != nil && v.TaskListMetadata != nil
}

type PollForDecisionTaskRequest struct {
	Domain         *string   `json:"domain,omitempty"`
	TaskList       *TaskList `json:"taskList,omitempty"`
	Identity       *string   `json:"identity,omitempty"`
	BinaryChecksum *string   `json:"binaryChecksum,omitempty"`
}

// ToWire translates a PollForDecisionTaskRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PollForDecisionTaskRequest) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Domain != nil {
		w, err = wire.NewValueString(*(v.Domain)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.TaskList != nil {
		w, err = v.TaskList.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.Identity != nil {
		w, err = wire.NewValueString(*(v.Identity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.BinaryChecksum != nil {
		w, err = wire.NewValueString(*(v.BinaryChecksum)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a PollForDecisionTaskRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PollForDecisionTaskRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PollForDecisionTaskRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PollForDecisionTaskRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Domain = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TStruct {
				v.TaskList, err = _TaskList_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Identity = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.BinaryChecksum = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a PollForDecisionTaskRequest
// struct.
func (v *PollForDecisionTaskRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.Domain != nil {
		fields[i] = fmt.Sprintf("Domain: %v", *(v.Domain))
		i++
	}
	if v.TaskList != nil {
		fields[i] = fmt.Sprintf("TaskList: %v", v.TaskList)
		i++
	}
	if v.Identity != nil {
		fields[i] = fmt.Sprintf("Identity: %v", *(v.Identity))
		i++
	}
	if v.BinaryChecksum != nil {
		fields[i] = fmt.Sprintf("BinaryChecksum: %v", *(v.BinaryChecksum))
		i++
	}

	return fmt.Sprintf("PollForDecisionTaskRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this PollForDecisionTaskRequest match the
// provided PollForDecisionTaskRequest.
//
// This function performs a deep comparison.
func (v *PollForDecisionTaskRequest) Equals(rhs *PollForDecisionTaskRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Domain, rhs.Domain) {
		return false
	}
	if !((v.TaskList == nil && rhs.TaskList == nil) || (v.TaskList != nil && rhs.TaskList != nil && v.TaskList.Equals(rhs.TaskList))) {
		return false
	}
	if !_String_EqualsPtr(v.Identity, rhs.Identity) {
		return false
	}
	if !_String_EqualsPtr(v.BinaryChecksum, rhs.BinaryChecksum) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of PollForDecisionTaskRequest.
func (v *PollForDecisionTaskRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Domain != nil {
		enc.AddString("domain", *v.Domain)
	}
	if v.TaskList != nil {
		err = multierr.Append(err, enc.AddObject("taskList", v.TaskList))
	}
	if v.Identity != nil {
		enc.AddString("identity", *v.Identity)
	}
	if v.BinaryChecksum != nil {
		enc.AddString("binaryChecksum", *v.BinaryChecksum)
	}
	return err
}

// GetDomain returns the value of Domain if it is set or its
// zero value if it is unset.
func (v *PollForDecisionTaskRequest) GetDomain() (o string) {
	if v != nil && v.Domain != nil {
		return *v.Domain
	}

	return
}

// IsSetDomain returns true if Domain is not nil.
func (v *PollForDecisionTaskRequest) IsSetDomain() bool {
	return v != nil && v.Domain != nil
}

// GetTaskList returns the value of TaskList if it is set or its
// zero value if it is unset.
func (v *PollForDecisionTaskRequest) GetTaskList() (o *TaskList) {
	if v != nil && v.TaskList != nil {
		return v.TaskList
	}

	return
}

// IsSetTaskList returns true if TaskList is not nil.
func (v *PollForDecisionTaskRequest) IsSetTaskList() bool {
	return v != nil && v.TaskList != nil
}

// GetIdentity returns the value of Identity if it is set or its
// zero value if it is unset.
func (v *PollForDecisionTaskRequest) GetIdentity() (o string) {
	if v != nil && v.Identity != nil {
		return *v.Identity
	}

	return
}

// IsSetIdentity returns true if Identity is not nil.
func (v *PollForDecisionTaskRequest) IsSetIdentity() bool {
	return v != nil && v.Identity != nil
}

// GetBinaryChecksum returns the value of BinaryChecksum if it is set or its
// zero value if it is unset.
func (v *PollForDecisionTaskRequest) GetBinaryChecksum() (o string) {
	if v != nil && v.BinaryChecksum != nil {
		return *v.BinaryChecksum
	}

	return
}

// IsSetBinaryChecksum returns true if BinaryChecksum is not nil.
func (v *PollForDecisionTaskRequest) IsSetBinaryChecksum() bool {
	return v != nil && v.BinaryChecksum != nil
}

type PollerInfo struct {
	LastAccessTime *int64   `json:"lastAccessTime,omitempty"`
	Identity       *string  `json:"identity,omitempty"`
	RatePerSecond  *float64 `json:"ratePerSecond,omitempty"`
}

// ToWire translates a PollerInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *PollerInfo) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.LastAccessTime != nil {
		w, err = wire.NewValueI64(*(v.LastAccessTime)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Identity != nil {
		w, err = wire.NewValueString(*(v.Identity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.RatePerSecond != nil {
		w, err = wire.NewValueDouble(*(v.RatePerSecond)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a PollerInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a PollerInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v PollerInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *PollerInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.LastAccessTime = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Identity = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.RatePerSecond = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a PollerInfo
// struct.
func (v *PollerInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.LastAccessTime != nil {
		fields[i] = fmt.Sprintf("LastAccessTime: %v", *(v.LastAccessTime))
		i++
	}
	if v.Identity != nil {
		fields[i] = fmt.Sprintf("Identity: %v", *(v.Identity))
		i++
	}
	if v.RatePerSecond != nil {
		fields[i] = fmt.Sprintf("RatePerSecond: %v", *(v.RatePerSecond))
		i++
	}

	return fmt.Sprintf("PollerInfo{%v}", strings.Join(fields[:i], ", "))
}

func _Double_EqualsPtr(lhs, rhs *float64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this PollerInfo match the
// provided PollerInfo.
//
// This function performs a deep comparison.
func (v *PollerInfo) Equals(rhs *PollerInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.LastAccessTime, rhs.LastAccessTime) {
		return false
	}
	if !_String_EqualsPtr(v.Identity, rhs.Identity) {
		return false
	}
	if !_Double_EqualsPtr(v.RatePerSecond, rhs.RatePerSecond) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of PollerInfo.
func (v *PollerInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.LastAccessTime != nil {
		enc.AddInt64("lastAccessTime", *v.LastAccessTime)
	}
	if v.Identity != nil {
		enc.AddString("identity", *v.Identity)
	}
	if v.RatePerSecond != nil {
		enc.AddFloat64("ratePerSecond", *v.RatePerSecond)
	}
	return err
}

// GetLastAccessTime returns the value of LastAccessTime if it is set or its
// zero value if it is unset.
func (v *PollerInfo) GetLastAccessTime() (o int64) {
	if v != nil && v.LastAccessTime != nil {
		return *v.LastAccessTime
	}

	return
}

// IsSetLastAccessTime returns true if LastAccessTime is not nil.
func (v *PollerInfo) IsSetLastAccessTime() bool {
	return v != nil && v.LastAccessTime != nil
}

// GetIdentity returns the value of Identity if it is set or its
// zero value if it is unset.
func (v *PollerInfo) GetIdentity() (o string) {
	if v != nil && v.Identity != nil {
		return *v.Identity
	}

	return
}

// IsSetIdentity returns true if Identity is not nil.
func (v *PollerInfo) IsSetIdentity() bool {
	return v != nil && v.Identity != nil
}

// GetRatePerSecond returns the value of RatePerSecond if it is set or its
// zero value if it is unset.
func (v *PollerInfo) GetRatePerSecond() (o float64) {
	if v != nil && v.RatePerSecond != nil {
		return *v.RatePerSecond
	}

	return
}

// IsSetRatePerSecond returns true if RatePerSecond is not nil.
func (v *PollerInfo) IsSetRatePerSecond() bool {
	return v != nil && v.RatePerSecond != nil
}

type QueryConsistencyLevel int32

const (
	QueryConsistencyLevelEventual QueryConsistencyLevel = 0
	QueryConsistencyLevelStrong   QueryConsistencyLevel = 1
)

// QueryConsistencyLevel_Values returns all recognized values of QueryConsistencyLevel.
func QueryConsistencyLevel_Values() []QueryConsistencyLevel {
	return []QueryConsistencyLevel{
		QueryConsistencyLevelEventual,
		QueryConsistencyLevelStrong,
	}
}

// UnmarshalText tries to decode QueryConsistencyLevel from a byte slice
// containing its name.
//
//   var v QueryConsistencyLevel
//   err := v.UnmarshalText([]byte("EVENTUAL"))
func (v *QueryConsistencyLevel) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "EVENTUAL":
		*v = QueryConsistencyLevelEventual
		return nil
	case "STRONG":
		*v = QueryConsistencyLevelStrong
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "QueryConsistencyLevel", err)
		}
		*v = QueryConsistencyLevel(val)
		return nil
	}
}

// MarshalText encodes QueryConsistencyLevel to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v QueryConsistencyLevel) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("EVENTUAL"), nil
	case 1:
		return []byte("STRONG"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of QueryConsistencyLevel.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v QueryConsistencyLevel) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "EVENTUAL")
	case 1:
		enc.AddString("name", "STRONG")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v QueryConsistencyLevel) Ptr() *QueryConsistencyLevel {
	return &v
}

// ToWire translates QueryConsistencyLevel into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v QueryConsistencyLevel) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes QueryConsistencyLevel from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return QueryConsistencyLevel(0), err
//   }
//
//   var v QueryConsistencyLevel
//   if err := v.FromWire(x); err != nil {
//     return QueryConsistencyLevel(0), err
//   }
//   return v, nil
func (v *QueryConsistencyLevel) FromWire(w wire.Value) error {
	*v = (QueryConsistencyLevel)(w.GetI32())
	return nil
}

// String returns a readable string representation of QueryConsistencyLevel.
func (v QueryConsistencyLevel) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "EVENTUAL"
	case 1:
		return "STRONG"
	}
	return fmt.Sprintf("QueryConsistencyLevel(%d)", w)
}

// Equals returns true if this QueryConsistencyLevel value matches the provided
// value.
func (v QueryConsistencyLevel) Equals(rhs QueryConsistencyLevel) bool {
	return v == rhs
}

// MarshalJSON serializes QueryConsistencyLevel into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v QueryConsistencyLevel) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"EVENTUAL\""), nil
	case 1:
		return ([]byte)("\"STRONG\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode QueryConsistencyLevel from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *QueryConsistencyLevel) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "QueryConsistencyLevel")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "QueryConsistencyLevel")
		}
		*v = (QueryConsistencyLevel)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "QueryConsistencyLevel")
	}
}

type QueryRejectCondition int32

const (
	QueryRejectConditionNotOpen             QueryRejectCondition = 0
	QueryRejectConditionNotCompletedCleanly QueryRejectCondition = 1
)

// QueryRejectCondition_Values returns all recognized values of QueryRejectCondition.
func QueryRejectCondition_Values() []QueryRejectCondition {
	return []QueryRejectCondition{
		QueryRejectConditionNotOpen,
		QueryRejectConditionNotCompletedCleanly,
	}
}

// UnmarshalText tries to decode QueryRejectCondition from a byte slice
// containing its name.
//
//   var v QueryRejectCondition
//   err := v.UnmarshalText([]byte("NOT_OPEN"))
func (v *QueryRejectCondition) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "NOT_OPEN":
		*v = QueryRejectConditionNotOpen
		return nil
	case "NOT_COMPLETED_CLEANLY":
		*v = QueryRejectConditionNotCompletedCleanly
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "QueryRejectCondition", err)
		}
		*v = QueryRejectCondition(val)
		return nil
	}
}

// MarshalText encodes QueryRejectCondition to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v QueryRejectCondition) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("NOT_OPEN"), nil
	case 1:
		return []byte("NOT_COMPLETED_CLEANLY"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of QueryRejectCondition.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v QueryRejectCondition) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "NOT_OPEN")
	case 1:
		enc.AddString("name", "NOT_COMPLETED_CLEANLY")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v QueryRejectCondition) Ptr() *QueryRejectCondition {
	return &v
}

// ToWire translates QueryRejectCondition into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v QueryRejectCondition) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes QueryRejectCondition from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return QueryRejectCondition(0), err
//   }
//
//   var v QueryRejectCondition
//   if err := v.FromWire(x); err != nil {
//     return QueryRejectCondition(0), err
//   }
//   return v, nil
func (v *QueryRejectCondition) FromWire(w wire.Value) error {
	*v = (QueryRejectCondition)(w.GetI32())
	return nil
}

// String returns a readable string representation of QueryRejectCondition.
func (v QueryRejectCondition) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "NOT_OPEN"
	case 1:
		return "NOT_COMPLETED_CLEANLY"
	}
	return fmt.Sprintf("QueryRejectCondition(%d)", w)
}

// Equals returns true if this QueryRejectCondition value matches the provided
// value.
func (v QueryRejectCondition) Equals(rhs QueryRejectCondition) bool {
	return v == rhs
}

// MarshalJSON serializes QueryRejectCondition into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v QueryRejectCondition) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"NOT_OPEN\""), nil
	case 1:
		return ([]byte)("\"NOT_COMPLETED_CLEANLY\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode QueryRejectCondition from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *QueryRejectCondition) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "QueryRejectCondition")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "QueryRejectCondition")
		}
		*v = (QueryRejectCondition)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "QueryRejectCondition")
	}
}

type QueryRejected struct {
	CloseStatus *WorkflowExecutionCloseStatus `json:"closeStatus,omitempty"`
}

// ToWire translates a QueryRejected struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *QueryRejected) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.CloseStatus != nil {
		w, err = v.CloseStatus.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a QueryRejected struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a QueryRejected struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v QueryRejected
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *QueryRejected) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI32 {
				var x WorkflowExecutionCloseStatus
				x, err = _WorkflowExecutionCloseStatus_Read(field.Value)
				v.CloseStatus = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a QueryRejected
// struct.
func (v *QueryRejected) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.CloseStatus != nil {
		fields[i] = fmt.Sprintf("CloseStatus: %v", *(v.CloseStatus))
		i++
	}

	return fmt.Sprintf("QueryRejected{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this QueryRejected match the
// provided QueryRejected.
//
// This function performs a deep comparison.
func (v *QueryRejected) Equals(rhs *QueryRejected) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_WorkflowExecutionCloseStatus_EqualsPtr(v.CloseStatus, rhs.CloseStatus) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of QueryRejected.
func (v *QueryRejected) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.CloseStatus != nil {
		err = multierr.Append(err, enc.AddObject("closeStatus", *v.CloseStatus))
	}
	return err
}

// GetCloseStatus returns the value of CloseStatus if it is set or its
// zero value if it is unset.
func (v *QueryRejected) GetCloseStatus() (o WorkflowExecutionCloseStatus) {
	if v != nil && v.CloseStatus != nil {
		return *v.CloseStatus
	}

	return
}

// IsSetCloseStatus returns true if CloseStatus is not nil.
func (v *QueryRejected) IsSetCloseStatus() bool {
	return v != nil && v.CloseStatus != nil
}

type QueryResultType int32

const (
	QueryResultTypeAnswered QueryResultType = 0
	QueryResultTypeFailed   QueryResultType = 1
)

// QueryResultType_Values returns all recognized values of QueryResultType.
func QueryResultType_Values() []QueryResultType {
	return []QueryResultType{
		QueryResultTypeAnswered,
		QueryResultTypeFailed,
	}
}

// UnmarshalText tries to decode QueryResultType from a byte slice
// containing its name.
//
//   var v QueryResultType
//   err := v.UnmarshalText([]byte("ANSWERED"))
func (v *QueryResultType) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "ANSWERED":
		*v = QueryResultTypeAnswered
		return nil
	case "FAILED":
		*v = QueryResultTypeFailed
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "QueryResultType", err)
		}
		*v = QueryResultType(val)
		return nil
	}
}

// MarshalText encodes QueryResultType to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v QueryResultType) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("ANSWERED"), nil
	case 1:
		return []byte("FAILED"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of QueryResultType.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v QueryResultType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "ANSWERED")
	case 1:
		enc.AddString("name", "FAILED")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v QueryResultType) Ptr() *QueryResultType {
	return &v
}

// ToWire translates QueryResultType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v QueryResultType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes QueryResultType from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return QueryResultType(0), err
//   }
//
//   var v QueryResultType
//   if err := v.FromWire(x); err != nil {
//     return QueryResultType(0), err
//   }
//   return v, nil
func (v *QueryResultType) FromWire(w wire.Value) error {
	*v = (QueryResultType)(w.GetI32())
	return nil
}

// String returns a readable string representation of QueryResultType.
func (v QueryResultType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "ANSWERED"
	case 1:
		return "FAILED"
	}
	return fmt.Sprintf("QueryResultType(%d)", w)
}

// Equals returns true if this QueryResultType value matches the provided
// value.
func (v QueryResultType) Equals(rhs QueryResultType) bool {
	return v == rhs
}

// MarshalJSON serializes QueryResultType into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v QueryResultType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"ANSWERED\""), nil
	case 1:
		return ([]byte)("\"FAILED\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode QueryResultType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *QueryResultType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "QueryResultType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "QueryResultType")
		}
		*v = (QueryResultType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "QueryResultType")
	}
}

type QueryTaskCompletedType int32

const (
	QueryTaskCompletedTypeCompleted QueryTaskCompletedType = 0
	QueryTaskCompletedTypeFailed    QueryTaskCompletedType = 1
)

// QueryTaskCompletedType_Values returns all recognized values of QueryTaskCompletedType.
func QueryTaskCompletedType_Values() []QueryTaskCompletedType {
	return []QueryTaskCompletedType{
		QueryTaskCompletedTypeCompleted,
		QueryTaskCompletedTypeFailed,
	}
}

// UnmarshalText tries to decode QueryTaskCompletedType from a byte slice
// containing its name.
//
//   var v QueryTaskCompletedType
//   err := v.UnmarshalText([]byte("COMPLETED"))
func (v *QueryTaskCompletedType) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "COMPLETED":
		*v = QueryTaskCompletedTypeCompleted
		return nil
	case "FAILED":
		*v = QueryTaskCompletedTypeFailed
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "QueryTaskCompletedType", err)
		}
		*v = QueryTaskCompletedType(val)
		return nil
	}
}

// MarshalText encodes QueryTaskCompletedType to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v QueryTaskCompletedType) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("COMPLETED"), nil
	case 1:
		return []byte("FAILED"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of QueryTaskCompletedType.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v QueryTaskCompletedType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "COMPLETED")
	case 1:
		enc.AddString("name", "FAILED")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v QueryTaskCompletedType) Ptr() *QueryTaskCompletedType {
	return &v
}

// ToWire translates QueryTaskCompletedType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v QueryTaskCompletedType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes QueryTaskCompletedType from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return QueryTaskCompletedType(0), err
//   }
//
//   var v QueryTaskCompletedType
//   if err := v.FromWire(x); err != nil {
//     return QueryTaskCompletedType(0), err
//   }
//   return v, nil
func (v *QueryTaskCompletedType) FromWire(w wire.Value) error {
	*v = (QueryTaskCompletedType)(w.GetI32())
	return nil
}

// String returns a readable string representation of QueryTaskCompletedType.
func (v QueryTaskCompletedType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "COMPLETED"
	case 1:
		return "FAILED"
	}
	return fmt.Sprintf("QueryTaskCompletedType(%d)", w)
}

// Equals returns true if this QueryTaskCompletedType value matches the provided
// value.
func (v QueryTaskCompletedType) Equals(rhs QueryTaskCompletedType) bool {
	return v == rhs
}

// MarshalJSON serializes QueryTaskCompletedType into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v QueryTaskCompletedType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"COMPLETED\""), nil
	case 1:
		return ([]byte)("\"FAILED\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode QueryTaskCompletedType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *QueryTaskCompletedType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "QueryTaskCompletedType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "QueryTaskCompletedType")
		}
		*v = (QueryTaskCompletedType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "QueryTaskCompletedType")
	}
}

type QueryWorkflowResponse struct {
	QueryResult   []byte         `json:"queryResult,omitempty"`
	QueryRejected *QueryRejected `json:"queryRejected,omitempty"`
}

// ToWire translates a QueryWorkflowResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *QueryWorkflowResponse) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.QueryResult != nil {
		w, err = wire.NewValueBinary(v.QueryResult), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.QueryRejected != nil {
		w, err = v.QueryRejected.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _QueryRejected_Read(w wire.Value) (*QueryRejected, error) {
	var v QueryRejected
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a QueryWorkflowResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a QueryWorkflowResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v QueryWorkflowResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *QueryWorkflowResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				v.QueryResult, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TStruct {
				v.QueryRejected, err = _QueryRejected_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a QueryWorkflowResponse
// struct.
func (v *QueryWorkflowResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.QueryResult != nil {
		fields[i] = fmt.Sprintf("QueryResult: %v", v.QueryResult)
		i++
	}
	if v.QueryRejected != nil {
		fields[i] = fmt.Sprintf("QueryRejected: %v", v.QueryRejected)
		i++
	}

	return fmt.Sprintf("QueryWorkflowResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this QueryWorkflowResponse match the
// provided QueryWorkflowResponse.
//
// This function performs a deep comparison.
func (v *QueryWorkflowResponse) Equals(rhs *QueryWorkflowResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.QueryResult == nil && rhs.QueryResult == nil) || (v.QueryResult != nil && rhs.QueryResult != nil && bytes.Equal(v.QueryResult, rhs.QueryResult))) {
		return false
	}
	if !((v.QueryRejected == nil && rhs.QueryRejected == nil) || (v.QueryRejected != nil && rhs.QueryRejected != nil && v.QueryRejected.Equals(rhs.QueryRejected))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of QueryWorkflowResponse.
func (v *QueryWorkflowResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.QueryResult != nil {
		enc.AddString("queryResult", base64.StdEncoding.EncodeToString(v.QueryResult))
	}
	if v.QueryRejected != nil {
		err = multierr.Append(err, enc.AddObject("queryRejected", v.QueryRejected))
	}
	return err
}

// GetQueryResult returns the value of QueryResult if it is set or its
// zero value if it is unset.
func (v *QueryWorkflowResponse) GetQueryResult() (o []byte) {
	if v != nil && v.QueryResult != nil {
		return v.QueryResult
	}

	return
}

// IsSetQueryResult returns true if QueryResult is not nil.
func (v *QueryWorkflowResponse) IsSetQueryResult() bool {
	return v != nil && v.QueryResult != nil
}

// GetQueryRejected returns the value of QueryRejected if it is set or its
// zero value if it is unset.
func (v *QueryWorkflowResponse) GetQueryRejected() (o *QueryRejected) {
	if v != nil && v.QueryRejected != nil {
		return v.QueryRejected
	}

	return
}

// IsSetQueryRejected returns true if QueryRejected is not nil.
func (v *QueryWorkflowResponse) IsSetQueryRejected() bool {
	return v != nil && v.QueryRejected != nil
}

type RecordActivityTaskHeartbeatByIDRequest struct {
	Domain     *string `json:"domain,omitempty"`
	WorkflowID *string `json:"workflowID,omitempty"`
	RunID      *string `json:"runID,omitempty"`
	ActivityID *string `json:"activityID,omitempty"`
	Details    []byte  `json:"details,omitempty"`
	Identity   *string `json:"identity,omitempty"`
}

// ToWire translates a RecordActivityTaskHeartbeatByIDRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RecordActivityTaskHeartbeatByIDRequest) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Domain != nil {
		w, err = wire.NewValueString(*(v.Domain)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.WorkflowID != nil {
		w, err = wire.NewValueString(*(v.WorkflowID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.RunID != nil {
		w, err = wire.NewValueString(*(v.RunID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.ActivityID != nil {
		w, err = wire.NewValueString(*(v.ActivityID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.Details != nil {
		w, err = wire.NewValueBinary(v.Details), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.Identity != nil {
		w, err = wire.NewValueString(*(v.Identity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RecordActivityTaskHeartbeatByIDRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RecordActivityTaskHeartbeatByIDRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RecordActivityTaskHeartbeatByIDRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RecordActivityTaskHeartbeatByIDRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Domain = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.WorkflowID = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RunID = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ActivityID = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TBinary {
				v.Details, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Identity = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RecordActivityTaskHeartbeatByIDRequest
// struct.
func (v *RecordActivityTaskHeartbeatByIDRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.Domain != nil {
		fields[i] = fmt.Sprintf("Domain: %v", *(v.Domain))
		i++
	}
	if v.WorkflowID != nil {
		fields[i] = fmt.Sprintf("WorkflowID: %v", *(v.WorkflowID))
		i++
	}
	if v.RunID != nil {
		fields[i] = fmt.Sprintf("RunID: %v", *(v.RunID))
		i++
	}
	if v.ActivityID != nil {
		fields[i] = fmt.Sprintf("ActivityID: %v", *(v.ActivityID))
		i++
	}
	if v.Details != nil {
		fields[i] = fmt.Sprintf("Details: %v", v.Details)
		i++
	}
	if v.Identity != nil {
		fields[i] = fmt.Sprintf("Identity: %v", *(v.Identity))
		i++
	}

	return fmt.Sprintf("RecordActivityTaskHeartbeatByIDRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RecordActivityTaskHeartbeatByIDRequest match the
// provided RecordActivityTaskHeartbeatByIDRequest.
//
// This function performs a deep comparison.
func (v *RecordActivityTaskHeartbeatByIDRequest) Equals(rhs *RecordActivityTaskHeartbeatByIDRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Domain, rhs.Domain) {
		return false
	}
	if !_String_EqualsPtr(v.WorkflowID, rhs.WorkflowID) {
		return false
	}
	if !_String_EqualsPtr(v.RunID, rhs.RunID) {
		return false
	}
	if !_String_EqualsPtr(v.ActivityID, rhs.ActivityID) {
		return false
	}
	if !((v.Details == nil && rhs.Details == nil) || (v.Details != nil && rhs.Details != nil && bytes.Equal(v.Details, rhs.Details))) {
		return false
	}
	if !_String_EqualsPtr(v.Identity, rhs.Identity) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RecordActivityTaskHeartbeatByIDRequest.
func (v *RecordActivityTaskHeartbeatByIDRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Domain != nil {
		enc.AddString("domain", *v.Domain)
	}
	if v.WorkflowID != nil {
		enc.AddString("workflowID", *v.WorkflowID)
	}
	if v.RunID != nil {
		enc.AddString("runID", *v.RunID)
	}
	if v.ActivityID != nil {
		enc.AddString("activityID", *v.ActivityID)
	}
	if v.Details != nil {
		enc.AddString("details", base64.StdEncoding.EncodeToString(v.Details))
	}
	if v.Identity != nil {
		enc.AddString("identity", *v.Identity)
	}
	return err
}

// GetDomain returns the value of Domain if it is set or its
// zero value if it is unset.
func (v *RecordActivityTaskHeartbeatByIDRequest) GetDomain() (o string) {
	if v != nil && v.Domain != nil {
		return *v.Domain
	}

	return
}

// IsSetDomain returns true if Domain is not nil.
func (v *RecordActivityTaskHeartbeatByIDRequest) IsSetDomain() bool {
	return v != nil && v.Domain != nil
}

// GetWorkflowID returns the value of WorkflowID if it is set or its
// zero value if it is unset.
func (v *RecordActivityTaskHeartbeatByIDRequest) GetWorkflowID() (o string) {
	if v != nil && v.WorkflowID != nil {
		return *v.WorkflowID
	}

	return
}

// IsSetWorkflowID returns true if WorkflowID is not nil.
func (v *RecordActivityTaskHeartbeatByIDRequest) IsSetWorkflowID() bool {
	return v != nil && v.WorkflowID != nil
}

// GetRunID returns the value of RunID if it is set or its
// zero value if it is unset.
func (v *RecordActivityTaskHeartbeatByIDRequest) GetRunID() (o string) {
	if v != nil && v.RunID != nil {
		return *v.RunID
	}

	return
}

// IsSetRunID returns true if RunID is not nil.
func (v *RecordActivityTaskHeartbeatByIDRequest) IsSetRunID() bool {
	return v != nil && v.RunID != nil
}

// GetActivityID returns the value of ActivityID if it is set or its
// zero value if it is unset.
func (v *RecordActivityTaskHeartbeatByIDRequest) GetActivityID() (o string) {
	if v != nil && v.ActivityID != nil {
		return *v.ActivityID
	}

	return
}

// IsSetActivityID returns true if ActivityID is not nil.
func (v *RecordActivityTaskHeartbeatByIDRequest) IsSetActivityID() bool {
	return v != nil && v.ActivityID != nil
}

// GetDetails returns the value of Details if it is set or its
// zero value if it is unset.
func (v *RecordActivityTaskHeartbeatByIDRequest) GetDetails() (o []byte) {
	if v != nil && v.Details != nil {
		return v.Details
	}

	return
}

// IsSetDetails returns true if Details is not nil.
func (v *RecordActivityTaskHeartbeatByIDRequest) IsSetDetails() bool {
	return v != nil && v.Details != nil
}

// GetIdentity returns the value of Identity if it is set or its
// zero value if it is unset.
func (v *RecordActivityTaskHeartbeatByIDRequest) GetIdentity() (o string) {
	if v != nil && v.Identity != nil {
		return *v.Identity
	}

	return
}

// IsSetIdentity returns true if Identity is not nil.
func (v *RecordActivityTaskHeartbeatByIDRequest) IsSetIdentity() bool {
	return v != nil && v.Identity != nil
}

type RecordActivityTaskHeartbeatRequest struct {
	TaskToken []byte  `json:"taskToken,omitempty"`
	Details   []byte  `json:"details,omitempty"`
	Identity  *string `json:"identity,omitempty"`
}

// ToWire translates a RecordActivityTaskHeartbeatRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RecordActivityTaskHeartbeatRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TaskToken != nil {
		w, err = wire.NewValueBinary(v.TaskToken), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Details != nil {
		w, err = wire.NewValueBinary(v.Details), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.Identity != nil {
		w, err = wire.NewValueString(*(v.Identity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RecordActivityTaskHeartbeatRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RecordActivityTaskHeartbeatRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RecordActivityTaskHeartbeatRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RecordActivityTaskHeartbeatRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				v.TaskToken, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				v.Details, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Identity = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RecordActivityTaskHeartbeatRequest
// struct.
func (v *RecordActivityTaskHeartbeatRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.TaskToken != nil {
		fields[i] = fmt.Sprintf("TaskToken: %v", v.TaskToken)
		i++
	}
	if v.Details != nil {
		fields[i] = fmt.Sprintf("Details: %v", v.Details)
		i++
	}
	if v.Identity != nil {
		fields[i] = fmt.Sprintf("Identity: %v", *(v.Identity))
		i++
	}

	return fmt.Sprintf("RecordActivityTaskHeartbeatRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RecordActivityTaskHeartbeatRequest match the
// provided RecordActivityTaskHeartbeatRequest.
//
// This function performs a deep comparison.
func (v *RecordActivityTaskHeartbeatRequest) Equals(rhs *RecordActivityTaskHeartbeatRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.TaskToken == nil && rhs.TaskToken == nil) || (v.TaskToken != nil && rhs.TaskToken != nil && bytes.Equal(v.TaskToken, rhs.TaskToken))) {
		return false
	}
	if !((v.Details == nil && rhs.Details == nil) || (v.Details != nil && rhs.Details != nil && bytes.Equal(v.Details, rhs.Details))) {
		return false
	}
	if !_String_EqualsPtr(v.Identity, rhs.Identity) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RecordActivityTaskHeartbeatRequest.
func (v *RecordActivityTaskHeartbeatRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.TaskToken != nil {
		enc.AddString("taskToken", base64.StdEncoding.EncodeToString(v.TaskToken))
	}
	if v.Details != nil {
		enc.AddString("details", base64.StdEncoding.EncodeToString(v.Details))
	}
	if v.Identity != nil {
		enc.AddString("identity", *v.Identity)
	}
	return err
}

// GetTaskToken returns the value of TaskToken if it is set or its
// zero value if it is unset.
func (v *RecordActivityTaskHeartbeatRequest) GetTaskToken() (o []byte) {
	if v != nil && v.TaskToken != nil {
		return v.TaskToken
	}

	return
}

// IsSetTaskToken returns true if TaskToken is not nil.
func (v *RecordActivityTaskHeartbeatRequest) IsSetTaskToken() bool {
	return v != nil && v.TaskToken != nil
}

// GetDetails returns the value of Details if it is set or its
// zero value if it is unset.
func (v *RecordActivityTaskHeartbeatRequest) GetDetails() (o []byte) {
	if v != nil && v.Details != nil {
		return v.Details
	}

	return
}

// IsSetDetails returns true if Details is not nil.
func (v *RecordActivityTaskHeartbeatRequest) IsSetDetails() bool {
	return v != nil && v.Details != nil
}

// GetIdentity returns the value of Identity if it is set or its
// zero value if it is unset.
func (v *RecordActivityTaskHeartbeatRequest) GetIdentity() (o string) {
	if v != nil && v.Identity != nil {
		return *v.Identity
	}

	return
}

// IsSetIdentity returns true if Identity is not nil.
func (v *RecordActivityTaskHeartbeatRequest) IsSetIdentity() bool {
	return v != nil && v.Identity != nil
}

type RecordActivityTaskHeartbeatResponse struct {
	CancelRequested *bool `json:"cancelRequested,omitempty"`
}

// ToWire translates a RecordActivityTaskHeartbeatResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RecordActivityTaskHeartbeatResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.CancelRequested != nil {
		w, err = wire.NewValueBool(*(v.CancelRequested)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RecordActivityTaskHeartbeatResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RecordActivityTaskHeartbeatResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RecordActivityTaskHeartbeatResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RecordActivityTaskHeartbeatResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.CancelRequested = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RecordActivityTaskHeartbeatResponse
// struct.
func (v *RecordActivityTaskHeartbeatResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.CancelRequested != nil {
		fields[i] = fmt.Sprintf("CancelRequested: %v", *(v.CancelRequested))
		i++
	}

	return fmt.Sprintf("RecordActivityTaskHeartbeatResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RecordActivityTaskHeartbeatResponse match the
// provided RecordActivityTaskHeartbeatResponse.
//
// This function performs a deep comparison.
func (v *RecordActivityTaskHeartbeatResponse) Equals(rhs *RecordActivityTaskHeartbeatResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Bool_EqualsPtr(v.CancelRequested, rhs.CancelRequested) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RecordActivityTaskHeartbeatResponse.
func (v *RecordActivityTaskHeartbeatResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.CancelRequested != nil {
		enc.AddBool("cancelRequested", *v.CancelRequested)
	}
	return err
}

// GetCancelRequested returns the value of CancelRequested if it is set or its
// zero value if it is unset.
func (v *RecordActivityTaskHeartbeatResponse) GetCancelRequested() (o bool) {
	if v != nil && v.CancelRequested != nil {
		return *v.CancelRequested
	}

	return
}

// IsSetCancelRequested returns true if CancelRequested is not nil.
func (v *RecordActivityTaskHeartbeatResponse) IsSetCancelRequested() bool {
	return v != nil && v.CancelRequested != nil
}

type RegisterDomainRequest struct {
	Name                                   *string                            `json:"name,omitempty"`
	Description                            *string                            `json:"description,omitempty"`
	OwnerEmail                             *string                            `json:"ownerEmail,omitempty"`
	WorkflowExecutionRetentionPeriodInDays *int32                             `json:"workflowExecutionRetentionPeriodInDays,omitempty"`
	EmitMetric                             *bool                              `json:"emitMetric,omitempty"`
	Clusters                               []*ClusterReplicationConfiguration `json:"clusters,omitempty"`
	ActiveClusterName                      *string                            `json:"activeClusterName,omitempty"`
	Data                                   map[string]string                  `json:"data,omitempty"`
	SecurityToken                          *string                            `json:"securityToken,omitempty"`
	IsGlobalDomain                         *bool                              `json:"isGlobalDomain,omitempty"`
	HistoryArchivalStatus                  *ArchivalStatus                    `json:"historyArchivalStatus,omitempty"`
	HistoryArchivalURI                     *string                            `json:"historyArchivalURI,omitempty"`
	VisibilityArchivalStatus               *ArchivalStatus                    `json:"visibilityArchivalStatus,omitempty"`
	VisibilityArchivalURI                  *string                            `json:"visibilityArchivalURI,omitempty"`
}

// ToWire translates a RegisterDomainRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RegisterDomainRequest) ToWire() (wire.Value, error) {
	var (
		fields [14]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Description != nil {
		w, err = wire.NewValueString(*(v.Description)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.OwnerEmail != nil {
		w, err = wire.NewValueString(*(v.OwnerEmail)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.WorkflowExecutionRetentionPeriodInDays != nil {
		w, err = wire.NewValueI32(*(v.WorkflowExecutionRetentionPeriodInDays)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.EmitMetric == nil {
		v.EmitMetric = ptr.Bool(true)
	}
	{
		w, err = wire.NewValueBool(*(v.EmitMetric)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.Clusters != nil {
		w, err = wire.NewValueList(_List_ClusterReplicationConfiguration_ValueList(v.Clusters)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}
	if v.ActiveClusterName != nil {
		w, err = wire.NewValueString(*(v.ActiveClusterName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 70, Value: w}
		i++
	}
	if v.Data != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Data)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 80, Value: w}
		i++
	}
	if v.SecurityToken != nil {
		w, err = wire.NewValueString(*(v.SecurityToken)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 90, Value: w}
		i++
	}
	if v.IsGlobalDomain != nil {
		w, err = wire.NewValueBool(*(v.IsGlobalDomain)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 120, Value: w}
		i++
	}
	if v.HistoryArchivalStatus != nil {
		w, err = v.HistoryArchivalStatus.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 130, Value: w}
		i++
	}
	if v.HistoryArchivalURI != nil {
		w, err = wire.NewValueString(*(v.HistoryArchivalURI)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 140, Value: w}
		i++
	}
	if v.VisibilityArchivalStatus != nil {
		w, err = v.VisibilityArchivalStatus.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 150, Value: w}
		i++
	}
	if v.VisibilityArchivalURI != nil {
		w, err = wire.NewValueString(*(v.VisibilityArchivalURI)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 160, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ArchivalStatus_Read(w wire.Value) (ArchivalStatus, error) {
	var v ArchivalStatus
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a RegisterDomainRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RegisterDomainRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RegisterDomainRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RegisterDomainRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Description = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.OwnerEmail = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.WorkflowExecutionRetentionPeriodInDays = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.EmitMetric = &x
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TList {
				v.Clusters, err = _List_ClusterReplicationConfiguration_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 70:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ActiveClusterName = &x
				if err != nil {
					return err
				}

			}
		case 80:
			if field.Value.Type() == wire.TMap {
				v.Data, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 90:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.SecurityToken = &x
				if err != nil {
					return err
				}

			}
		case 120:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.IsGlobalDomain = &x
				if err != nil {
					return err
				}

			}
		case 130:
			if field.Value.Type() == wire.TI32 {
				var x ArchivalStatus
				x, err = _ArchivalStatus_Read(field.Value)
				v.HistoryArchivalStatus = &x
				if err != nil {
					return err
				}

			}
		case 140:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.HistoryArchivalURI = &x
				if err != nil {
					return err
				}

			}
		case 150:
			if field.Value.Type() == wire.TI32 {
				var x ArchivalStatus
				x, err = _ArchivalStatus_Read(field.Value)
				v.VisibilityArchivalStatus = &x
				if err != nil {
					return err
				}

			}
		case 160:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.VisibilityArchivalURI = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if v.EmitMetric == nil {
		v.EmitMetric = ptr.Bool(true)
	}

	return nil
}

// String returns a readable string representation of a RegisterDomainRequest
// struct.
func (v *RegisterDomainRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [14]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Description != nil {
		fields[i] = fmt.Sprintf("Description: %v", *(v.Description))
		i++
	}
	if v.OwnerEmail != nil {
		fields[i] = fmt.Sprintf("OwnerEmail: %v", *(v.OwnerEmail))
		i++
	}
	if v.WorkflowExecutionRetentionPeriodInDays != nil {
		fields[i] = fmt.Sprintf("WorkflowExecutionRetentionPeriodInDays: %v", *(v.WorkflowExecutionRetentionPeriodInDays))
		i++
	}
	if v.EmitMetric != nil {
		fields[i] = fmt.Sprintf("EmitMetric: %v", *(v.EmitMetric))
		i++
	}
	if v.Clusters != nil {
		fields[i] = fmt.Sprintf("Clusters: %v", v.Clusters)
		i++
	}
	if v.ActiveClusterName != nil {
		fields[i] = fmt.Sprintf("ActiveClusterName: %v", *(v.ActiveClusterName))
		i++
	}
	if v.Data != nil {
		fields[i] = fmt.Sprintf("Data: %v", v.Data)
		i++
	}
	if v.SecurityToken != nil {
		fields[i] = fmt.Sprintf("SecurityToken: %v", *(v.SecurityToken))
		i++
	}
	if v.IsGlobalDomain != nil {
		fields[i] = fmt.Sprintf("IsGlobalDomain: %v", *(v.IsGlobalDomain))
		i++
	}
	if v.HistoryArchivalStatus != nil {
		fields[i] = fmt.Sprintf("HistoryArchivalStatus: %v", *(v.HistoryArchivalStatus))
		i++
	}
	if v.HistoryArchivalURI != nil {
		fields[i] = fmt.Sprintf("HistoryArchivalURI: %v", *(v.HistoryArchivalURI))
		i++
	}
	if v.VisibilityArchivalStatus != nil {
		fields[i] = fmt.Sprintf("VisibilityArchivalStatus: %v", *(v.VisibilityArchivalStatus))
		i++
	}
	if v.VisibilityArchivalURI != nil {
		fields[i] = fmt.Sprintf("VisibilityArchivalURI: %v", *(v.VisibilityArchivalURI))
		i++
	}

	return fmt.Sprintf("RegisterDomainRequest{%v}", strings.Join(fields[:i], ", "))
}

func _ArchivalStatus_EqualsPtr(lhs, rhs *ArchivalStatus) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this RegisterDomainRequest match the
// provided RegisterDomainRequest.
//
// This function performs a deep comparison.
func (v *RegisterDomainRequest) Equals(rhs *RegisterDomainRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.Description, rhs.Description) {
		return false
	}
	if !_String_EqualsPtr(v.OwnerEmail, rhs.OwnerEmail) {
		return false
	}
	if !_I32_EqualsPtr(v.WorkflowExecutionRetentionPeriodInDays, rhs.WorkflowExecutionRetentionPeriodInDays) {
		return false
	}
	if !_Bool_EqualsPtr(v.EmitMetric, rhs.EmitMetric) {
		return false
	}
	if !((v.Clusters == nil && rhs.Clusters == nil) || (v.Clusters != nil && rhs.Clusters != nil && _List_ClusterReplicationConfiguration_Equals(v.Clusters, rhs.Clusters))) {
		return false
	}
	if !_String_EqualsPtr(v.ActiveClusterName, rhs.ActiveClusterName) {
		return false
	}
	if !((v.Data == nil && rhs.Data == nil) || (v.Data != nil && rhs.Data != nil && _Map_String_String_Equals(v.Data, rhs.Data))) {
		return false
	}
	if !_String_EqualsPtr(v.SecurityToken, rhs.SecurityToken) {
		return false
	}
	if !_Bool_EqualsPtr(v.IsGlobalDomain, rhs.IsGlobalDomain) {
		return false
	}
	if !_ArchivalStatus_EqualsPtr(v.HistoryArchivalStatus, rhs.HistoryArchivalStatus) {
		return false
	}
	if !_String_EqualsPtr(v.HistoryArchivalURI, rhs.HistoryArchivalURI) {
		return false
	}
	if !_ArchivalStatus_EqualsPtr(v.VisibilityArchivalStatus, rhs.VisibilityArchivalStatus) {
		return false
	}
	if !_String_EqualsPtr(v.VisibilityArchivalURI, rhs.VisibilityArchivalURI) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RegisterDomainRequest.
func (v *RegisterDomainRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Description != nil {
		enc.AddString("description", *v.Description)
	}
	if v.OwnerEmail != nil {
		enc.AddString("ownerEmail", *v.OwnerEmail)
	}
	if v.WorkflowExecutionRetentionPeriodInDays != nil {
		enc.AddInt32("workflowExecutionRetentionPeriodInDays", *v.WorkflowExecutionRetentionPeriodInDays)
	}
	if v.EmitMetric != nil {
		enc.AddBool("emitMetric", *v.EmitMetric)
	}
	if v.Clusters != nil {
		err = multierr.Append(err, enc.AddArray("clusters", (_List_ClusterReplicationConfiguration_Zapper)(v.Clusters)))
	}
	if v.ActiveClusterName != nil {
		enc.AddString("activeClusterName", *v.ActiveClusterName)
	}
	if v.Data != nil {
		err = multierr.Append(err, enc.AddObject("data", (_Map_String_String_Zapper)(v.Data)))
	}
	if v.SecurityToken != nil {
		enc.AddString("securityToken", *v.SecurityToken)
	}
	if v.IsGlobalDomain != nil {
		enc.AddBool("isGlobalDomain", *v.IsGlobalDomain)
	}
	if v.HistoryArchivalStatus != nil {
		err = multierr.Append(err, enc.AddObject("historyArchivalStatus", *v.HistoryArchivalStatus))
	}
	if v.HistoryArchivalURI != nil {
		enc.AddString("historyArchivalURI", *v.HistoryArchivalURI)
	}
	if v.VisibilityArchivalStatus != nil {
		err = multierr.Append(err, enc.AddObject("visibilityArchivalStatus", *v.VisibilityArchivalStatus))
	}
	if v.VisibilityArchivalURI != nil {
		enc.AddString("visibilityArchivalURI", *v.VisibilityArchivalURI)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *RegisterDomainRequest) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *RegisterDomainRequest) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetDescription returns the value of Description if it is set or its
// zero value if it is unset.
func (v *RegisterDomainRequest) GetDescription() (o string) {
	if v != nil && v.Description != nil {
		return *v.Description
	}

	return
}

// IsSetDescription returns true if Description is not nil.
func (v *RegisterDomainRequest) IsSetDescription() bool {
	return v != nil && v.Description != nil
}

// GetOwnerEmail returns the value of OwnerEmail if it is set or its
// zero value if it is unset.
func (v *RegisterDomainRequest) GetOwnerEmail() (o string) {
	if v != nil && v.OwnerEmail != nil {
		return *v.OwnerEmail
	}

	return
}

// IsSetOwnerEmail returns true if OwnerEmail is not nil.
func (v *RegisterDomainRequest) IsSetOwnerEmail() bool {
	return v != nil && v.OwnerEmail != nil
}

// GetWorkflowExecutionRetentionPeriodInDays returns the value of WorkflowExecutionRetentionPeriodInDays if it is set or its
// zero value if it is unset.
func (v *RegisterDomainRequest) GetWorkflowExecutionRetentionPeriodInDays() (o int32) {
	if v != nil && v.WorkflowExecutionRetentionPeriodInDays != nil {
		return *v.WorkflowExecutionRetentionPeriodInDays
	}

	return
}

// IsSetWorkflowExecutionRetentionPeriodInDays returns true if WorkflowExecutionRetentionPeriodInDays is not nil.
func (v *RegisterDomainRequest) IsSetWorkflowExecutionRetentionPeriodInDays() bool {
	return v != nil && v.WorkflowExecutionRetentionPeriodInDays != nil
}

// GetEmitMetric returns the value of EmitMetric if it is set or its
// default value if it is unset.
func (v *RegisterDomainRequest) GetEmitMetric() (o bool) {
	if v != nil && v.EmitMetric != nil {
		return *v.EmitMetric
	}
	o = true
	return
}

// IsSetEmitMetric returns true if EmitMetric is not nil.
func (v *RegisterDomainRequest) IsSetEmitMetric() bool {
	return v != nil && v.EmitMetric != nil
}

// GetClusters returns the value of Clusters if it is set or its
// zero value if it is unset.
func (v *RegisterDomainRequest) GetClusters() (o []*ClusterReplicationConfiguration) {
	if v != nil && v.Clusters != nil {
		return v.Clusters
	}

	return
}

// IsSetClusters returns true if Clusters is not nil.
func (v *RegisterDomainRequest) IsSetClusters() bool {
	return v != nil && v.Clusters != nil
}

// GetActiveClusterName returns the value of ActiveClusterName if it is set or its
// zero value if it is unset.
func (v *RegisterDomainRequest) GetActiveClusterName() (o string) {
	if v != nil && v.ActiveClusterName != nil {
		return *v.ActiveClusterName
	}

	return
}

// IsSetActiveClusterName returns true if ActiveClusterName is not nil.
func (v *RegisterDomainRequest) IsSetActiveClusterName() bool {
	return v != nil && v.ActiveClusterName != nil
}

// GetData returns the value of Data if it is set or its
// zero value if it is unset.
func (v *RegisterDomainRequest) GetData() (o map[string]string) {
	if v != nil && v.Data != nil {
		return v.Data
	}

	return
}

// IsSetData returns true if Data is not nil.
func (v *RegisterDomainRequest) IsSetData() bool {
	return v != nil && v.Data != nil
}

// GetSecurityToken returns the value of SecurityToken if it is set or its
// zero value if it is unset.
func (v *RegisterDomainRequest) GetSecurityToken() (o string) {
	if v != nil && v.SecurityToken != nil {
		return *v.SecurityToken
	}

	return
}

// IsSetSecurityToken returns true if SecurityToken is not nil.
func (v *RegisterDomainRequest) IsSetSecurityToken() bool {
	return v != nil && v.SecurityToken != nil
}

// GetIsGlobalDomain returns the value of IsGlobalDomain if it is set or its
// zero value if it is unset.
func (v *RegisterDomainRequest) GetIsGlobalDomain() (o bool) {
	if v != nil && v.IsGlobalDomain != nil {
		return *v.IsGlobalDomain
	}

	return
}

// IsSetIsGlobalDomain returns true if IsGlobalDomain is not nil.
func (v *RegisterDomainRequest) IsSetIsGlobalDomain() bool {
	return v != nil && v.IsGlobalDomain != nil
}

// GetHistoryArchivalStatus returns the value of HistoryArchivalStatus if it is set or its
// zero value if it is unset.
func (v *RegisterDomainRequest) GetHistoryArchivalStatus() (o ArchivalStatus) {
	if v != nil && v.HistoryArchivalStatus != nil {
		return *v.HistoryArchivalStatus
	}

	return
}

// IsSetHistoryArchivalStatus returns true if HistoryArchivalStatus is not nil.
func (v *RegisterDomainRequest) IsSetHistoryArchivalStatus() bool {
	return v != nil && v.HistoryArchivalStatus != nil
}

// GetHistoryArchivalURI returns the value of HistoryArchivalURI if it is set or its
// zero value if it is unset.
func (v *RegisterDomainRequest) GetHistoryArchivalURI() (o string) {
	if v != nil && v.HistoryArchivalURI != nil {
		return *v.HistoryArchivalURI
	}

	return
}

// IsSetHistoryArchivalURI returns true if HistoryArchivalURI is not nil.
func (v *RegisterDomainRequest) IsSetHistoryArchivalURI() bool {
	return v != nil && v.HistoryArchivalURI != nil
}

// GetVisibilityArchivalStatus returns the value of VisibilityArchivalStatus if it is set or its
// zero value if it is unset.
func (v *RegisterDomainRequest) GetVisibilityArchivalStatus() (o ArchivalStatus) {
	if v != nil && v.VisibilityArchivalStatus != nil {
		return *v.VisibilityArchivalStatus
	}

	return
}

// IsSetVisibilityArchivalStatus returns true if VisibilityArchivalStatus is not nil.
func (v *RegisterDomainRequest) IsSetVisibilityArchivalStatus() bool {
	return v != nil && v.VisibilityArchivalStatus != nil
}

// GetVisibilityArchivalURI returns the value of VisibilityArchivalURI if it is set or its
// zero value if it is unset.
func (v *RegisterDomainRequest) GetVisibilityArchivalURI() (o string) {
	if v != nil && v.VisibilityArchivalURI != nil {
		return *v.VisibilityArchivalURI
	}

	return
}

// IsSetVisibilityArchivalURI returns true if VisibilityArchivalURI is not nil.
func (v *RegisterDomainRequest) IsSetVisibilityArchivalURI() bool {
	return v != nil && v.VisibilityArchivalURI != nil
}

type RemoveTaskRequest struct {
	ShardID *int32 `json:"shardID,omitempty"`
	Type    *int32 `json:"type,omitempty"`
	TaskID  *int64 `json:"taskID,omitempty"`
}

// ToWire translates a RemoveTaskRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RemoveTaskRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ShardID != nil {
		w, err = wire.NewValueI32(*(v.ShardID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Type != nil {
		w, err = wire.NewValueI32(*(v.Type)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.TaskID != nil {
		w, err = wire.NewValueI64(*(v.TaskID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RemoveTaskRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RemoveTaskRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RemoveTaskRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RemoveTaskRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ShardID = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Type = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.TaskID = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RemoveTaskRequest
// struct.
func (v *RemoveTaskRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.ShardID != nil {
		fields[i] = fmt.Sprintf("ShardID: %v", *(v.ShardID))
		i++
	}
	if v.Type != nil {
		fields[i] = fmt.Sprintf("Type: %v", *(v.Type))
		i++
	}
	if v.TaskID != nil {
		fields[i] = fmt.Sprintf("TaskID: %v", *(v.TaskID))
		i++
	}

	return fmt.Sprintf("RemoveTaskRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RemoveTaskRequest match the
// provided RemoveTaskRequest.
//
// This function performs a deep comparison.
func (v *RemoveTaskRequest) Equals(rhs *RemoveTaskRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.ShardID, rhs.ShardID) {
		return false
	}
	if !_I32_EqualsPtr(v.Type, rhs.Type) {
		return false
	}
	if !_I64_EqualsPtr(v.TaskID, rhs.TaskID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RemoveTaskRequest.
func (v *RemoveTaskRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ShardID != nil {
		enc.AddInt32("shardID", *v.ShardID)
	}
	if v.Type != nil {
		enc.AddInt32("type", *v.Type)
	}
	if v.TaskID != nil {
		enc.AddInt64("taskID", *v.TaskID)
	}
	return err
}

// GetShardID returns the value of ShardID if it is set or its
// zero value if it is unset.
func (v *RemoveTaskRequest) GetShardID() (o int32) {
	if v != nil && v.ShardID != nil {
		return *v.ShardID
	}

	return
}

// IsSetShardID returns true if ShardID is not nil.
func (v *RemoveTaskRequest) IsSetShardID() bool {
	return v != nil && v.ShardID != nil
}

// GetType returns the value of Type if it is set or its
// zero value if it is unset.
func (v *RemoveTaskRequest) GetType() (o int32) {
	if v != nil && v.Type != nil {
		return *v.Type
	}

	return
}

// IsSetType returns true if Type is not nil.
func (v *RemoveTaskRequest) IsSetType() bool {
	return v != nil && v.Type != nil
}

// GetTaskID returns the value of TaskID if it is set or its
// zero value if it is unset.
func (v *RemoveTaskRequest) GetTaskID() (o int64) {
	if v != nil && v.TaskID != nil {
		return *v.TaskID
	}

	return
}

// IsSetTaskID returns true if TaskID is not nil.
func (v *RemoveTaskRequest) IsSetTaskID() bool {
	return v != nil && v.TaskID != nil
}

type ReplicationInfo struct {
	Version     *int64 `json:"version,omitempty"`
	LastEventId *int64 `json:"lastEventId,omitempty"`
}

// ToWire translates a ReplicationInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ReplicationInfo) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Version != nil {
		w, err = wire.NewValueI64(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.LastEventId != nil {
		w, err = wire.NewValueI64(*(v.LastEventId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ReplicationInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ReplicationInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ReplicationInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ReplicationInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.LastEventId = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ReplicationInfo
// struct.
func (v *ReplicationInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	if v.LastEventId != nil {
		fields[i] = fmt.Sprintf("LastEventId: %v", *(v.LastEventId))
		i++
	}

	return fmt.Sprintf("ReplicationInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ReplicationInfo match the
// provided ReplicationInfo.
//
// This function performs a deep comparison.
func (v *ReplicationInfo) Equals(rhs *ReplicationInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	if !_I64_EqualsPtr(v.LastEventId, rhs.LastEventId) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ReplicationInfo.
func (v *ReplicationInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Version != nil {
		enc.AddInt64("version", *v.Version)
	}
	if v.LastEventId != nil {
		enc.AddInt64("lastEventId", *v.LastEventId)
	}
	return err
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *ReplicationInfo) GetVersion() (o int64) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *ReplicationInfo) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

// GetLastEventId returns the value of LastEventId if it is set or its
// zero value if it is unset.
func (v *ReplicationInfo) GetLastEventId() (o int64) {
	if v != nil && v.LastEventId != nil {
		return *v.LastEventId
	}

	return
}

// IsSetLastEventId returns true if LastEventId is not nil.
func (v *ReplicationInfo) IsSetLastEventId() bool {
	return v != nil && v.LastEventId != nil
}

type ResetPointInfo struct {
	BinaryChecksum           *string `json:"binaryChecksum,omitempty"`
	RunId                    *string `json:"runId,omitempty"`
	FirstDecisionCompletedId *int64  `json:"firstDecisionCompletedId,omitempty"`
	CreatedTimeNano          *int64  `json:"createdTimeNano,omitempty"`
	ExpiringTimeNano         *int64  `json:"expiringTimeNano,omitempty"`
	Resettable               *bool   `json:"resettable,omitempty"`
}

// ToWire translates a ResetPointInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ResetPointInfo) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BinaryChecksum != nil {
		w, err = wire.NewValueString(*(v.BinaryChecksum)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.RunId != nil {
		w, err = wire.NewValueString(*(v.RunId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.FirstDecisionCompletedId != nil {
		w, err = wire.NewValueI64(*(v.FirstDecisionCompletedId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.CreatedTimeNano != nil {
		w, err = wire.NewValueI64(*(v.CreatedTimeNano)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.ExpiringTimeNano != nil {
		w, err = wire.NewValueI64(*(v.ExpiringTimeNano)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.Resettable != nil {
		w, err = wire.NewValueBool(*(v.Resettable)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ResetPointInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ResetPointInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ResetPointInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ResetPointInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.BinaryChecksum = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RunId = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.FirstDecisionCompletedId = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.CreatedTimeNano = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ExpiringTimeNano = &x
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.Resettable = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ResetPointInfo
// struct.
func (v *ResetPointInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.BinaryChecksum != nil {
		fields[i] = fmt.Sprintf("BinaryChecksum: %v", *(v.BinaryChecksum))
		i++
	}
	if v.RunId != nil {
		fields[i] = fmt.Sprintf("RunId: %v", *(v.RunId))
		i++
	}
	if v.FirstDecisionCompletedId != nil {
		fields[i] = fmt.Sprintf("FirstDecisionCompletedId: %v", *(v.FirstDecisionCompletedId))
		i++
	}
	if v.CreatedTimeNano != nil {
		fields[i] = fmt.Sprintf("CreatedTimeNano: %v", *(v.CreatedTimeNano))
		i++
	}
	if v.ExpiringTimeNano != nil {
		fields[i] = fmt.Sprintf("ExpiringTimeNano: %v", *(v.ExpiringTimeNano))
		i++
	}
	if v.Resettable != nil {
		fields[i] = fmt.Sprintf("Resettable: %v", *(v.Resettable))
		i++
	}

	return fmt.Sprintf("ResetPointInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ResetPointInfo match the
// provided ResetPointInfo.
//
// This function performs a deep comparison.
func (v *ResetPointInfo) Equals(rhs *ResetPointInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.BinaryChecksum, rhs.BinaryChecksum) {
		return false
	}
	if !_String_EqualsPtr(v.RunId, rhs.RunId) {
		return false
	}
	if !_I64_EqualsPtr(v.FirstDecisionCompletedId, rhs.FirstDecisionCompletedId) {
		return false
	}
	if !_I64_EqualsPtr(v.CreatedTimeNano, rhs.CreatedTimeNano) {
		return false
	}
	if !_I64_EqualsPtr(v.ExpiringTimeNano, rhs.ExpiringTimeNano) {
		return false
	}
	if !_Bool_EqualsPtr(v.Resettable, rhs.Resettable) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ResetPointInfo.
func (v *ResetPointInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.BinaryChecksum != nil {
		enc.AddString("binaryChecksum", *v.BinaryChecksum)
	}
	if v.RunId != nil {
		enc.AddString("runId", *v.RunId)
	}
	if v.FirstDecisionCompletedId != nil {
		enc.AddInt64("firstDecisionCompletedId", *v.FirstDecisionCompletedId)
	}
	if v.CreatedTimeNano != nil {
		enc.AddInt64("createdTimeNano", *v.CreatedTimeNano)
	}
	if v.ExpiringTimeNano != nil {
		enc.AddInt64("expiringTimeNano", *v.ExpiringTimeNano)
	}
	if v.Resettable != nil {
		enc.AddBool("resettable", *v.Resettable)
	}
	return err
}

// GetBinaryChecksum returns the value of BinaryChecksum if it is set or its
// zero value if it is unset.
func (v *ResetPointInfo) GetBinaryChecksum() (o string) {
	if v != nil && v.BinaryChecksum != nil {
		return *v.BinaryChecksum
	}

	return
}

// IsSetBinaryChecksum returns true if BinaryChecksum is not nil.
func (v *ResetPointInfo) IsSetBinaryChecksum() bool {
	return v != nil && v.BinaryChecksum != nil
}

// GetRunId returns the value of RunId if it is set or its
// zero value if it is unset.
func (v *ResetPointInfo) GetRunId() (o string) {
	if v != nil && v.RunId != nil {
		return *v.RunId
	}

	return
}

// IsSetRunId returns true if RunId is not nil.
func (v *ResetPointInfo) IsSetRunId() bool {
	return v != nil && v.RunId != nil
}

// GetFirstDecisionCompletedId returns the value of FirstDecisionCompletedId if it is set or its
// zero value if it is unset.
func (v *ResetPointInfo) GetFirstDecisionCompletedId() (o int64) {
	if v != nil && v.FirstDecisionCompletedId != nil {
		return *v.FirstDecisionCompletedId
	}

	return
}

// IsSetFirstDecisionCompletedId returns true if FirstDecisionCompletedId is not nil.
func (v *ResetPointInfo) IsSetFirstDecisionCompletedId() bool {
	return v != nil && v.FirstDecisionCompletedId != nil
}

// GetCreatedTimeNano returns the value of CreatedTimeNano if it is set or its
// zero value if it is unset.
func (v *ResetPointInfo) GetCreatedTimeNano() (o int64) {
	if v != nil && v.CreatedTimeNano != nil {
		return *v.CreatedTimeNano
	}

	return
}

// IsSetCreatedTimeNano returns true if CreatedTimeNano is not nil.
func (v *ResetPointInfo) IsSetCreatedTimeNano() bool {
	return v != nil && v.CreatedTimeNano != nil
}

// GetExpiringTimeNano returns the value of ExpiringTimeNano if it is set or its
// zero value if it is unset.
func (v *ResetPointInfo) GetExpiringTimeNano() (o int64) {
	if v != nil && v.ExpiringTimeNano != nil {
		return *v.ExpiringTimeNano
	}

	return
}

// IsSetExpiringTimeNano returns true if ExpiringTimeNano is not nil.
func (v *ResetPointInfo) IsSetExpiringTimeNano() bool {
	return v != nil && v.ExpiringTimeNano != nil
}

// GetResettable returns the value of Resettable if it is set or its
// zero value if it is unset.
func (v *ResetPointInfo) GetResettable() (o bool) {
	if v != nil && v.Resettable != nil {
		return *v.Resettable
	}

	return
}

// IsSetResettable returns true if Resettable is not nil.
func (v *ResetPointInfo) IsSetResettable() bool {
	return v != nil && v.Resettable != nil
}

type ResetPoints struct {
	Points []*ResetPointInfo `json:"points,omitempty"`
}

type _List_ResetPointInfo_ValueList []*ResetPointInfo

func (v _List_ResetPointInfo_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_ResetPointInfo_ValueList) Size() int {
	return len(v)
}

func (_List_ResetPointInfo_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_ResetPointInfo_ValueList) Close() {}

// ToWire translates a ResetPoints struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ResetPoints) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Points != nil {
		w, err = wire.NewValueList(_List_ResetPointInfo_ValueList(v.Points)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ResetPointInfo_Read(w wire.Value) (*ResetPointInfo, error) {
	var v ResetPointInfo
	err := v.FromWire(w)
	return &v, err
}

func _List_ResetPointInfo_Read(l wire.ValueList) ([]*ResetPointInfo, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*ResetPointInfo, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _ResetPointInfo_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a ResetPoints struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ResetPoints struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ResetPoints
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ResetPoints) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TList {
				v.Points, err = _List_ResetPointInfo_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ResetPoints
// struct.
func (v *ResetPoints) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Points != nil {
		fields[i] = fmt.Sprintf("Points: %v", v.Points)
		i++
	}

	return fmt.Sprintf("ResetPoints{%v}", strings.Join(fields[:i], ", "))
}

func _List_ResetPointInfo_Equals(lhs, rhs []*ResetPointInfo) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ResetPoints match the
// provided ResetPoints.
//
// This function performs a deep comparison.
func (v *ResetPoints) Equals(rhs *ResetPoints) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Points == nil && rhs.Points == nil) || (v.Points != nil && rhs.Points != nil && _List_ResetPointInfo_Equals(v.Points, rhs.Points))) {
		return false
	}

	return true
}

type _List_ResetPointInfo_Zapper []*ResetPointInfo

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_ResetPointInfo_Zapper.
func (l _List_ResetPointInfo_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ResetPoints.
func (v *ResetPoints) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Points != nil {
		err = multierr.Append(err, enc.AddArray("points", (_List_ResetPointInfo_Zapper)(v.Points)))
	}
	return err
}

// GetPoints returns the value of Points if it is set or its
// zero value if it is unset.
func (v *ResetPoints) GetPoints() (o []*ResetPointInfo) {
	if v != nil && v.Points != nil {
		return v.Points
	}

	return
}

// IsSetPoints returns true if Points is not nil.
func (v *ResetPoints) IsSetPoints() bool {
	return v != nil && v.Points != nil
}

type ResetStickyTaskListResponse struct {
}

// ToWire translates a ResetStickyTaskListResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ResetStickyTaskListResponse) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ResetStickyTaskListResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ResetStickyTaskListResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ResetStickyTaskListResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ResetStickyTaskListResponse) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a ResetStickyTaskListResponse
// struct.
func (v *ResetStickyTaskListResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("ResetStickyTaskListResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ResetStickyTaskListResponse match the
// provided ResetStickyTaskListResponse.
//
// This function performs a deep comparison.
func (v *ResetStickyTaskListResponse) Equals(rhs *ResetStickyTaskListResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ResetStickyTaskListResponse.
func (v *ResetStickyTaskListResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

type ResetWorkflowExecutionResponse struct {
	RunId *string `json:"runId,omitempty"`
}

// ToWire translates a ResetWorkflowExecutionResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ResetWorkflowExecutionResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.RunId != nil {
		w, err = wire.NewValueString(*(v.RunId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ResetWorkflowExecutionResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ResetWorkflowExecutionResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ResetWorkflowExecutionResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ResetWorkflowExecutionResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RunId = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ResetWorkflowExecutionResponse
// struct.
func (v *ResetWorkflowExecutionResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.RunId != nil {
		fields[i] = fmt.Sprintf("RunId: %v", *(v.RunId))
		i++
	}

	return fmt.Sprintf("ResetWorkflowExecutionResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ResetWorkflowExecutionResponse match the
// provided ResetWorkflowExecutionResponse.
//
// This function performs a deep comparison.
func (v *ResetWorkflowExecutionResponse) Equals(rhs *ResetWorkflowExecutionResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.RunId, rhs.RunId) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ResetWorkflowExecutionResponse.
func (v *ResetWorkflowExecutionResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.RunId != nil {
		enc.AddString("runId", *v.RunId)
	}
	return err
}

// GetRunId returns the value of RunId if it is set or its
// zero value if it is unset.
func (v *ResetWorkflowExecutionResponse) GetRunId() (o string) {
	if v != nil && v.RunId != nil {
		return *v.RunId
	}

	return
}

// IsSetRunId returns true if RunId is not nil.
func (v *ResetWorkflowExecutionResponse) IsSetRunId() bool {
	return v != nil && v.RunId != nil
}

type RespondActivityTaskCanceledByIDRequest struct {
	Domain     *string `json:"domain,omitempty"`
	WorkflowID *string `json:"workflowID,omitempty"`
	RunID      *string `json:"runID,omitempty"`
	ActivityID *string `json:"activityID,omitempty"`
	Details    []byte  `json:"details,omitempty"`
	Identity   *string `json:"identity,omitempty"`
}

// ToWire translates a RespondActivityTaskCanceledByIDRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RespondActivityTaskCanceledByIDRequest) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Domain != nil {
		w, err = wire.NewValueString(*(v.Domain)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.WorkflowID != nil {
		w, err = wire.NewValueString(*(v.WorkflowID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.RunID != nil {
		w, err = wire.NewValueString(*(v.RunID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.ActivityID != nil {
		w, err = wire.NewValueString(*(v.ActivityID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.Details != nil {
		w, err = wire.NewValueBinary(v.Details), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.Identity != nil {
		w, err = wire.NewValueString(*(v.Identity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RespondActivityTaskCanceledByIDRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RespondActivityTaskCanceledByIDRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RespondActivityTaskCanceledByIDRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RespondActivityTaskCanceledByIDRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Domain = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.WorkflowID = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RunID = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ActivityID = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TBinary {
				v.Details, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Identity = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RespondActivityTaskCanceledByIDRequest
// struct.
func (v *RespondActivityTaskCanceledByIDRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.Domain != nil {
		fields[i] = fmt.Sprintf("Domain: %v", *(v.Domain))
		i++
	}
	if v.WorkflowID != nil {
		fields[i] = fmt.Sprintf("WorkflowID: %v", *(v.WorkflowID))
		i++
	}
	if v.RunID != nil {
		fields[i] = fmt.Sprintf("RunID: %v", *(v.RunID))
		i++
	}
	if v.ActivityID != nil {
		fields[i] = fmt.Sprintf("ActivityID: %v", *(v.ActivityID))
		i++
	}
	if v.Details != nil {
		fields[i] = fmt.Sprintf("Details: %v", v.Details)
		i++
	}
	if v.Identity != nil {
		fields[i] = fmt.Sprintf("Identity: %v", *(v.Identity))
		i++
	}

	return fmt.Sprintf("RespondActivityTaskCanceledByIDRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RespondActivityTaskCanceledByIDRequest match the
// provided RespondActivityTaskCanceledByIDRequest.
//
// This function performs a deep comparison.
func (v *RespondActivityTaskCanceledByIDRequest) Equals(rhs *RespondActivityTaskCanceledByIDRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Domain, rhs.Domain) {
		return false
	}
	if !_String_EqualsPtr(v.WorkflowID, rhs.WorkflowID) {
		return false
	}
	if !_String_EqualsPtr(v.RunID, rhs.RunID) {
		return false
	}
	if !_String_EqualsPtr(v.ActivityID, rhs.ActivityID) {
		return false
	}
	if !((v.Details == nil && rhs.Details == nil) || (v.Details != nil && rhs.Details != nil && bytes.Equal(v.Details, rhs.Details))) {
		return false
	}
	if !_String_EqualsPtr(v.Identity, rhs.Identity) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RespondActivityTaskCanceledByIDRequest.
func (v *RespondActivityTaskCanceledByIDRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Domain != nil {
		enc.AddString("domain", *v.Domain)
	}
	if v.WorkflowID != nil {
		enc.AddString("workflowID", *v.WorkflowID)
	}
	if v.RunID != nil {
		enc.AddString("runID", *v.RunID)
	}
	if v.ActivityID != nil {
		enc.AddString("activityID", *v.ActivityID)
	}
	if v.Details != nil {
		enc.AddString("details", base64.StdEncoding.EncodeToString(v.Details))
	}
	if v.Identity != nil {
		enc.AddString("identity", *v.Identity)
	}
	return err
}

// GetDomain returns the value of Domain if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCanceledByIDRequest) GetDomain() (o string) {
	if v != nil && v.Domain != nil {
		return *v.Domain
	}

	return
}

// IsSetDomain returns true if Domain is not nil.
func (v *RespondActivityTaskCanceledByIDRequest) IsSetDomain() bool {
	return v != nil && v.Domain != nil
}

// GetWorkflowID returns the value of WorkflowID if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCanceledByIDRequest) GetWorkflowID() (o string) {
	if v != nil && v.WorkflowID != nil {
		return *v.WorkflowID
	}

	return
}

// IsSetWorkflowID returns true if WorkflowID is not nil.
func (v *RespondActivityTaskCanceledByIDRequest) IsSetWorkflowID() bool {
	return v != nil && v.WorkflowID != nil
}

// GetRunID returns the value of RunID if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCanceledByIDRequest) GetRunID() (o string) {
	if v != nil && v.RunID != nil {
		return *v.RunID
	}

	return
}

// IsSetRunID returns true if RunID is not nil.
func (v *RespondActivityTaskCanceledByIDRequest) IsSetRunID() bool {
	return v != nil && v.RunID != nil
}

// GetActivityID returns the value of ActivityID if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCanceledByIDRequest) GetActivityID() (o string) {
	if v != nil && v.ActivityID != nil {
		return *v.ActivityID
	}

	return
}

// IsSetActivityID returns true if ActivityID is not nil.
func (v *RespondActivityTaskCanceledByIDRequest) IsSetActivityID() bool {
	return v != nil && v.ActivityID != nil
}

// GetDetails returns the value of Details if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCanceledByIDRequest) GetDetails() (o []byte) {
	if v != nil && v.Details != nil {
		return v.Details
	}

	return
}

// IsSetDetails returns true if Details is not nil.
func (v *RespondActivityTaskCanceledByIDRequest) IsSetDetails() bool {
	return v != nil && v.Details != nil
}

// GetIdentity returns the value of Identity if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCanceledByIDRequest) GetIdentity() (o string) {
	if v != nil && v.Identity != nil {
		return *v.Identity
	}

	return
}

// IsSetIdentity returns true if Identity is not nil.
func (v *RespondActivityTaskCanceledByIDRequest) IsSetIdentity() bool {
	return v != nil && v.Identity != nil
}

type RespondActivityTaskCanceledRequest struct {
	TaskToken []byte  `json:"taskToken,omitempty"`
	Details   []byte  `json:"details,omitempty"`
	Identity  *string `json:"identity,omitempty"`
}

// ToWire translates a RespondActivityTaskCanceledRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RespondActivityTaskCanceledRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TaskToken != nil {
		w, err = wire.NewValueBinary(v.TaskToken), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Details != nil {
		w, err = wire.NewValueBinary(v.Details), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.Identity != nil {
		w, err = wire.NewValueString(*(v.Identity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RespondActivityTaskCanceledRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RespondActivityTaskCanceledRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RespondActivityTaskCanceledRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RespondActivityTaskCanceledRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				v.TaskToken, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				v.Details, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Identity = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RespondActivityTaskCanceledRequest
// struct.
func (v *RespondActivityTaskCanceledRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.TaskToken != nil {
		fields[i] = fmt.Sprintf("TaskToken: %v", v.TaskToken)
		i++
	}
	if v.Details != nil {
		fields[i] = fmt.Sprintf("Details: %v", v.Details)
		i++
	}
	if v.Identity != nil {
		fields[i] = fmt.Sprintf("Identity: %v", *(v.Identity))
		i++
	}

	return fmt.Sprintf("RespondActivityTaskCanceledRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RespondActivityTaskCanceledRequest match the
// provided RespondActivityTaskCanceledRequest.
//
// This function performs a deep comparison.
func (v *RespondActivityTaskCanceledRequest) Equals(rhs *RespondActivityTaskCanceledRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.TaskToken == nil && rhs.TaskToken == nil) || (v.TaskToken != nil && rhs.TaskToken != nil && bytes.Equal(v.TaskToken, rhs.TaskToken))) {
		return false
	}
	if !((v.Details == nil && rhs.Details == nil) || (v.Details != nil && rhs.Details != nil && bytes.Equal(v.Details, rhs.Details))) {
		return false
	}
	if !_String_EqualsPtr(v.Identity, rhs.Identity) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RespondActivityTaskCanceledRequest.
func (v *RespondActivityTaskCanceledRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.TaskToken != nil {
		enc.AddString("taskToken", base64.StdEncoding.EncodeToString(v.TaskToken))
	}
	if v.Details != nil {
		enc.AddString("details", base64.StdEncoding.EncodeToString(v.Details))
	}
	if v.Identity != nil {
		enc.AddString("identity", *v.Identity)
	}
	return err
}

// GetTaskToken returns the value of TaskToken if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCanceledRequest) GetTaskToken() (o []byte) {
	if v != nil && v.TaskToken != nil {
		return v.TaskToken
	}

	return
}

// IsSetTaskToken returns true if TaskToken is not nil.
func (v *RespondActivityTaskCanceledRequest) IsSetTaskToken() bool {
	return v != nil && v.TaskToken != nil
}

// GetDetails returns the value of Details if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCanceledRequest) GetDetails() (o []byte) {
	if v != nil && v.Details != nil {
		return v.Details
	}

	return
}

// IsSetDetails returns true if Details is not nil.
func (v *RespondActivityTaskCanceledRequest) IsSetDetails() bool {
	return v != nil && v.Details != nil
}

// GetIdentity returns the value of Identity if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCanceledRequest) GetIdentity() (o string) {
	if v != nil && v.Identity != nil {
		return *v.Identity
	}

	return
}

// IsSetIdentity returns true if Identity is not nil.
func (v *RespondActivityTaskCanceledRequest) IsSetIdentity() bool {
	return v != nil && v.Identity != nil
}

type RespondActivityTaskCompletedByIDRequest struct {
	Domain     *string `json:"domain,omitempty"`
	WorkflowID *string `json:"workflowID,omitempty"`
	RunID      *string `json:"runID,omitempty"`
	ActivityID *string `json:"activityID,omitempty"`
	Result     []byte  `json:"result,omitempty"`
	Identity   *string `json:"identity,omitempty"`
}

// ToWire translates a RespondActivityTaskCompletedByIDRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RespondActivityTaskCompletedByIDRequest) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Domain != nil {
		w, err = wire.NewValueString(*(v.Domain)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.WorkflowID != nil {
		w, err = wire.NewValueString(*(v.WorkflowID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.RunID != nil {
		w, err = wire.NewValueString(*(v.RunID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.ActivityID != nil {
		w, err = wire.NewValueString(*(v.ActivityID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.Result != nil {
		w, err = wire.NewValueBinary(v.Result), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.Identity != nil {
		w, err = wire.NewValueString(*(v.Identity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RespondActivityTaskCompletedByIDRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RespondActivityTaskCompletedByIDRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RespondActivityTaskCompletedByIDRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RespondActivityTaskCompletedByIDRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Domain = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.WorkflowID = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RunID = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ActivityID = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TBinary {
				v.Result, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Identity = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RespondActivityTaskCompletedByIDRequest
// struct.
func (v *RespondActivityTaskCompletedByIDRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.Domain != nil {
		fields[i] = fmt.Sprintf("Domain: %v", *(v.Domain))
		i++
	}
	if v.WorkflowID != nil {
		fields[i] = fmt.Sprintf("WorkflowID: %v", *(v.WorkflowID))
		i++
	}
	if v.RunID != nil {
		fields[i] = fmt.Sprintf("RunID: %v", *(v.RunID))
		i++
	}
	if v.ActivityID != nil {
		fields[i] = fmt.Sprintf("ActivityID: %v", *(v.ActivityID))
		i++
	}
	if v.Result != nil {
		fields[i] = fmt.Sprintf("Result: %v", v.Result)
		i++
	}
	if v.Identity != nil {
		fields[i] = fmt.Sprintf("Identity: %v", *(v.Identity))
		i++
	}

	return fmt.Sprintf("RespondActivityTaskCompletedByIDRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RespondActivityTaskCompletedByIDRequest match the
// provided RespondActivityTaskCompletedByIDRequest.
//
// This function performs a deep comparison.
func (v *RespondActivityTaskCompletedByIDRequest) Equals(rhs *RespondActivityTaskCompletedByIDRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Domain, rhs.Domain) {
		return false
	}
	if !_String_EqualsPtr(v.WorkflowID, rhs.WorkflowID) {
		return false
	}
	if !_String_EqualsPtr(v.RunID, rhs.RunID) {
		return false
	}
	if !_String_EqualsPtr(v.ActivityID, rhs.ActivityID) {
		return false
	}
	if !((v.Result == nil && rhs.Result == nil) || (v.Result != nil && rhs.Result != nil && bytes.Equal(v.Result, rhs.Result))) {
		return false
	}
	if !_String_EqualsPtr(v.Identity, rhs.Identity) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RespondActivityTaskCompletedByIDRequest.
func (v *RespondActivityTaskCompletedByIDRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Domain != nil {
		enc.AddString("domain", *v.Domain)
	}
	if v.WorkflowID != nil {
		enc.AddString("workflowID", *v.WorkflowID)
	}
	if v.RunID != nil {
		enc.AddString("runID", *v.RunID)
	}
	if v.ActivityID != nil {
		enc.AddString("activityID", *v.ActivityID)
	}
	if v.Result != nil {
		enc.AddString("result", base64.StdEncoding.EncodeToString(v.Result))
	}
	if v.Identity != nil {
		enc.AddString("identity", *v.Identity)
	}
	return err
}

// GetDomain returns the value of Domain if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCompletedByIDRequest) GetDomain() (o string) {
	if v != nil && v.Domain != nil {
		return *v.Domain
	}

	return
}

// IsSetDomain returns true if Domain is not nil.
func (v *RespondActivityTaskCompletedByIDRequest) IsSetDomain() bool {
	return v != nil && v.Domain != nil
}

// GetWorkflowID returns the value of WorkflowID if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCompletedByIDRequest) GetWorkflowID() (o string) {
	if v != nil && v.WorkflowID != nil {
		return *v.WorkflowID
	}

	return
}

// IsSetWorkflowID returns true if WorkflowID is not nil.
func (v *RespondActivityTaskCompletedByIDRequest) IsSetWorkflowID() bool {
	return v != nil && v.WorkflowID != nil
}

// GetRunID returns the value of RunID if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCompletedByIDRequest) GetRunID() (o string) {
	if v != nil && v.RunID != nil {
		return *v.RunID
	}

	return
}

// IsSetRunID returns true if RunID is not nil.
func (v *RespondActivityTaskCompletedByIDRequest) IsSetRunID() bool {
	return v != nil && v.RunID != nil
}

// GetActivityID returns the value of ActivityID if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCompletedByIDRequest) GetActivityID() (o string) {
	if v != nil && v.ActivityID != nil {
		return *v.ActivityID
	}

	return
}

// IsSetActivityID returns true if ActivityID is not nil.
func (v *RespondActivityTaskCompletedByIDRequest) IsSetActivityID() bool {
	return v != nil && v.ActivityID != nil
}

// GetResult returns the value of Result if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCompletedByIDRequest) GetResult() (o []byte) {
	if v != nil && v.Result != nil {
		return v.Result
	}

	return
}

// IsSetResult returns true if Result is not nil.
func (v *RespondActivityTaskCompletedByIDRequest) IsSetResult() bool {
	return v != nil && v.Result != nil
}

// GetIdentity returns the value of Identity if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCompletedByIDRequest) GetIdentity() (o string) {
	if v != nil && v.Identity != nil {
		return *v.Identity
	}

	return
}

// IsSetIdentity returns true if Identity is not nil.
func (v *RespondActivityTaskCompletedByIDRequest) IsSetIdentity() bool {
	return v != nil && v.Identity != nil
}

type RespondActivityTaskCompletedRequest struct {
	TaskToken []byte  `json:"taskToken,omitempty"`
	Result    []byte  `json:"result,omitempty"`
	Identity  *string `json:"identity,omitempty"`
}

// ToWire translates a RespondActivityTaskCompletedRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RespondActivityTaskCompletedRequest) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TaskToken != nil {
		w, err = wire.NewValueBinary(v.TaskToken), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Result != nil {
		w, err = wire.NewValueBinary(v.Result), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.Identity != nil {
		w, err = wire.NewValueString(*(v.Identity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RespondActivityTaskCompletedRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RespondActivityTaskCompletedRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RespondActivityTaskCompletedRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RespondActivityTaskCompletedRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				v.TaskToken, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				v.Result, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Identity = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RespondActivityTaskCompletedRequest
// struct.
func (v *RespondActivityTaskCompletedRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.TaskToken != nil {
		fields[i] = fmt.Sprintf("TaskToken: %v", v.TaskToken)
		i++
	}
	if v.Result != nil {
		fields[i] = fmt.Sprintf("Result: %v", v.Result)
		i++
	}
	if v.Identity != nil {
		fields[i] = fmt.Sprintf("Identity: %v", *(v.Identity))
		i++
	}

	return fmt.Sprintf("RespondActivityTaskCompletedRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RespondActivityTaskCompletedRequest match the
// provided RespondActivityTaskCompletedRequest.
//
// This function performs a deep comparison.
func (v *RespondActivityTaskCompletedRequest) Equals(rhs *RespondActivityTaskCompletedRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.TaskToken == nil && rhs.TaskToken == nil) || (v.TaskToken != nil && rhs.TaskToken != nil && bytes.Equal(v.TaskToken, rhs.TaskToken))) {
		return false
	}
	if !((v.Result == nil && rhs.Result == nil) || (v.Result != nil && rhs.Result != nil && bytes.Equal(v.Result, rhs.Result))) {
		return false
	}
	if !_String_EqualsPtr(v.Identity, rhs.Identity) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RespondActivityTaskCompletedRequest.
func (v *RespondActivityTaskCompletedRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.TaskToken != nil {
		enc.AddString("taskToken", base64.StdEncoding.EncodeToString(v.TaskToken))
	}
	if v.Result != nil {
		enc.AddString("result", base64.StdEncoding.EncodeToString(v.Result))
	}
	if v.Identity != nil {
		enc.AddString("identity", *v.Identity)
	}
	return err
}

// GetTaskToken returns the value of TaskToken if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCompletedRequest) GetTaskToken() (o []byte) {
	if v != nil && v.TaskToken != nil {
		return v.TaskToken
	}

	return
}

// IsSetTaskToken returns true if TaskToken is not nil.
func (v *RespondActivityTaskCompletedRequest) IsSetTaskToken() bool {
	return v != nil && v.TaskToken != nil
}

// GetResult returns the value of Result if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCompletedRequest) GetResult() (o []byte) {
	if v != nil && v.Result != nil {
		return v.Result
	}

	return
}

// IsSetResult returns true if Result is not nil.
func (v *RespondActivityTaskCompletedRequest) IsSetResult() bool {
	return v != nil && v.Result != nil
}

// GetIdentity returns the value of Identity if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskCompletedRequest) GetIdentity() (o string) {
	if v != nil && v.Identity != nil {
		return *v.Identity
	}

	return
}

// IsSetIdentity returns true if Identity is not nil.
func (v *RespondActivityTaskCompletedRequest) IsSetIdentity() bool {
	return v != nil && v.Identity != nil
}

type RespondActivityTaskFailedByIDRequest struct {
	Domain     *string `json:"domain,omitempty"`
	WorkflowID *string `json:"workflowID,omitempty"`
	RunID      *string `json:"runID,omitempty"`
	ActivityID *string `json:"activityID,omitempty"`
	Reason     *string `json:"reason,omitempty"`
	Details    []byte  `json:"details,omitempty"`
	Identity   *string `json:"identity,omitempty"`
}

// ToWire translates a RespondActivityTaskFailedByIDRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RespondActivityTaskFailedByIDRequest) ToWire() (wire.Value, error) {
	var (
		fields [7]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Domain != nil {
		w, err = wire.NewValueString(*(v.Domain)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.WorkflowID != nil {
		w, err = wire.NewValueString(*(v.WorkflowID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.RunID != nil {
		w, err = wire.NewValueString(*(v.RunID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.ActivityID != nil {
		w, err = wire.NewValueString(*(v.ActivityID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.Reason != nil {
		w, err = wire.NewValueString(*(v.Reason)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.Details != nil {
		w, err = wire.NewValueBinary(v.Details), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}
	if v.Identity != nil {
		w, err = wire.NewValueString(*(v.Identity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 70, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RespondActivityTaskFailedByIDRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RespondActivityTaskFailedByIDRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RespondActivityTaskFailedByIDRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RespondActivityTaskFailedByIDRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Domain = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.WorkflowID = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RunID = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ActivityID = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Reason = &x
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TBinary {
				v.Details, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 70:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Identity = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RespondActivityTaskFailedByIDRequest
// struct.
func (v *RespondActivityTaskFailedByIDRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [7]string
	i := 0
	if v.Domain != nil {
		fields[i] = fmt.Sprintf("Domain: %v", *(v.Domain))
		i++
	}
	if v.WorkflowID != nil {
		fields[i] = fmt.Sprintf("WorkflowID: %v", *(v.WorkflowID))
		i++
	}
	if v.RunID != nil {
		fields[i] = fmt.Sprintf("RunID: %v", *(v.RunID))
		i++
	}
	if v.ActivityID != nil {
		fields[i] = fmt.Sprintf("ActivityID: %v", *(v.ActivityID))
		i++
	}
	if v.Reason != nil {
		fields[i] = fmt.Sprintf("Reason: %v", *(v.Reason))
		i++
	}
	if v.Details != nil {
		fields[i] = fmt.Sprintf("Details: %v", v.Details)
		i++
	}
	if v.Identity != nil {
		fields[i] = fmt.Sprintf("Identity: %v", *(v.Identity))
		i++
	}

	return fmt.Sprintf("RespondActivityTaskFailedByIDRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RespondActivityTaskFailedByIDRequest match the
// provided RespondActivityTaskFailedByIDRequest.
//
// This function performs a deep comparison.
func (v *RespondActivityTaskFailedByIDRequest) Equals(rhs *RespondActivityTaskFailedByIDRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Domain, rhs.Domain) {
		return false
	}
	if !_String_EqualsPtr(v.WorkflowID, rhs.WorkflowID) {
		return false
	}
	if !_String_EqualsPtr(v.RunID, rhs.RunID) {
		return false
	}
	if !_String_EqualsPtr(v.ActivityID, rhs.ActivityID) {
		return false
	}
	if !_String_EqualsPtr(v.Reason, rhs.Reason) {
		return false
	}
	if !((v.Details == nil && rhs.Details == nil) || (v.Details != nil && rhs.Details != nil && bytes.Equal(v.Details, rhs.Details))) {
		return false
	}
	if !_String_EqualsPtr(v.Identity, rhs.Identity) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RespondActivityTaskFailedByIDRequest.
func (v *RespondActivityTaskFailedByIDRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Domain != nil {
		enc.AddString("domain", *v.Domain)
	}
	if v.WorkflowID != nil {
		enc.AddString("workflowID", *v.WorkflowID)
	}
	if v.RunID != nil {
		enc.AddString("runID", *v.RunID)
	}
	if v.ActivityID != nil {
		enc.AddString("activityID", *v.ActivityID)
	}
	if v.Reason != nil {
		enc.AddString("reason", *v.Reason)
	}
	if v.Details != nil {
		enc.AddString("details", base64.StdEncoding.EncodeToString(v.Details))
	}
	if v.Identity != nil {
		enc.AddString("identity", *v.Identity)
	}
	return err
}

// GetDomain returns the value of Domain if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskFailedByIDRequest) GetDomain() (o string) {
	if v != nil && v.Domain != nil {
		return *v.Domain
	}

	return
}

// IsSetDomain returns true if Domain is not nil.
func (v *RespondActivityTaskFailedByIDRequest) IsSetDomain() bool {
	return v != nil && v.Domain != nil
}

// GetWorkflowID returns the value of WorkflowID if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskFailedByIDRequest) GetWorkflowID() (o string) {
	if v != nil && v.WorkflowID != nil {
		return *v.WorkflowID
	}

	return
}

// IsSetWorkflowID returns true if WorkflowID is not nil.
func (v *RespondActivityTaskFailedByIDRequest) IsSetWorkflowID() bool {
	return v != nil && v.WorkflowID != nil
}

// GetRunID returns the value of RunID if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskFailedByIDRequest) GetRunID() (o string) {
	if v != nil && v.RunID != nil {
		return *v.RunID
	}

	return
}

// IsSetRunID returns true if RunID is not nil.
func (v *RespondActivityTaskFailedByIDRequest) IsSetRunID() bool {
	return v != nil && v.RunID != nil
}

// GetActivityID returns the value of ActivityID if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskFailedByIDRequest) GetActivityID() (o string) {
	if v != nil && v.ActivityID != nil {
		return *v.ActivityID
	}

	return
}

// IsSetActivityID returns true if ActivityID is not nil.
func (v *RespondActivityTaskFailedByIDRequest) IsSetActivityID() bool {
	return v != nil && v.ActivityID != nil
}

// GetReason returns the value of Reason if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskFailedByIDRequest) GetReason() (o string) {
	if v != nil && v.Reason != nil {
		return *v.Reason
	}

	return
}

// IsSetReason returns true if Reason is not nil.
func (v *RespondActivityTaskFailedByIDRequest) IsSetReason() bool {
	return v != nil && v.Reason != nil
}

// GetDetails returns the value of Details if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskFailedByIDRequest) GetDetails() (o []byte) {
	if v != nil && v.Details != nil {
		return v.Details
	}

	return
}

// IsSetDetails returns true if Details is not nil.
func (v *RespondActivityTaskFailedByIDRequest) IsSetDetails() bool {
	return v != nil && v.Details != nil
}

// GetIdentity returns the value of Identity if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskFailedByIDRequest) GetIdentity() (o string) {
	if v != nil && v.Identity != nil {
		return *v.Identity
	}

	return
}

// IsSetIdentity returns true if Identity is not nil.
func (v *RespondActivityTaskFailedByIDRequest) IsSetIdentity() bool {
	return v != nil && v.Identity != nil
}

type RespondActivityTaskFailedRequest struct {
	TaskToken []byte  `json:"taskToken,omitempty"`
	Reason    *string `json:"reason,omitempty"`
	Details   []byte  `json:"details,omitempty"`
	Identity  *string `json:"identity,omitempty"`
}

// ToWire translates a RespondActivityTaskFailedRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RespondActivityTaskFailedRequest) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TaskToken != nil {
		w, err = wire.NewValueBinary(v.TaskToken), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Reason != nil {
		w, err = wire.NewValueString(*(v.Reason)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.Details != nil {
		w, err = wire.NewValueBinary(v.Details), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.Identity != nil {
		w, err = wire.NewValueString(*(v.Identity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a RespondActivityTaskFailedRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RespondActivityTaskFailedRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RespondActivityTaskFailedRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RespondActivityTaskFailedRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				v.TaskToken, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Reason = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				v.Details, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Identity = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RespondActivityTaskFailedRequest
// struct.
func (v *RespondActivityTaskFailedRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.TaskToken != nil {
		fields[i] = fmt.Sprintf("TaskToken: %v", v.TaskToken)
		i++
	}
	if v.Reason != nil {
		fields[i] = fmt.Sprintf("Reason: %v", *(v.Reason))
		i++
	}
	if v.Details != nil {
		fields[i] = fmt.Sprintf("Details: %v", v.Details)
		i++
	}
	if v.Identity != nil {
		fields[i] = fmt.Sprintf("Identity: %v", *(v.Identity))
		i++
	}

	return fmt.Sprintf("RespondActivityTaskFailedRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RespondActivityTaskFailedRequest match the
// provided RespondActivityTaskFailedRequest.
//
// This function performs a deep comparison.
func (v *RespondActivityTaskFailedRequest) Equals(rhs *RespondActivityTaskFailedRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.TaskToken == nil && rhs.TaskToken == nil) || (v.TaskToken != nil && rhs.TaskToken != nil && bytes.Equal(v.TaskToken, rhs.TaskToken))) {
		return false
	}
	if !_String_EqualsPtr(v.Reason, rhs.Reason) {
		return false
	}
	if !((v.Details == nil && rhs.Details == nil) || (v.Details != nil && rhs.Details != nil && bytes.Equal(v.Details, rhs.Details))) {
		return false
	}
	if !_String_EqualsPtr(v.Identity, rhs.Identity) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RespondActivityTaskFailedRequest.
func (v *RespondActivityTaskFailedRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.TaskToken != nil {
		enc.AddString("taskToken", base64.StdEncoding.EncodeToString(v.TaskToken))
	}
	if v.Reason != nil {
		enc.AddString("reason", *v.Reason)
	}
	if v.Details != nil {
		enc.AddString("details", base64.StdEncoding.EncodeToString(v.Details))
	}
	if v.Identity != nil {
		enc.AddString("identity", *v.Identity)
	}
	return err
}

// GetTaskToken returns the value of TaskToken if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskFailedRequest) GetTaskToken() (o []byte) {
	if v != nil && v.TaskToken != nil {
		return v.TaskToken
	}

	return
}

// IsSetTaskToken returns true if TaskToken is not nil.
func (v *RespondActivityTaskFailedRequest) IsSetTaskToken() bool {
	return v != nil && v.TaskToken != nil
}

// GetReason returns the value of Reason if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskFailedRequest) GetReason() (o string) {
	if v != nil && v.Reason != nil {
		return *v.Reason
	}

	return
}

// IsSetReason returns true if Reason is not nil.
func (v *RespondActivityTaskFailedRequest) IsSetReason() bool {
	return v != nil && v.Reason != nil
}

// GetDetails returns the value of Details if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskFailedRequest) GetDetails() (o []byte) {
	if v != nil && v.Details != nil {
		return v.Details
	}

	return
}

// IsSetDetails returns true if Details is not nil.
func (v *RespondActivityTaskFailedRequest) IsSetDetails() bool {
	return v != nil && v.Details != nil
}

// GetIdentity returns the value of Identity if it is set or its
// zero value if it is unset.
func (v *RespondActivityTaskFailedRequest) GetIdentity() (o string) {
	if v != nil && v.Identity != nil {
		return *v.Identity
	}

	return
}

// IsSetIdentity returns true if Identity is not nil.
func (v *RespondActivityTaskFailedRequest) IsSetIdentity() bool {
	return v != nil && v.Identity != nil
}

type RespondDecisionTaskFailedRequest struct {
	TaskToken      []byte                   `json:"taskToken,omitempty"`
	Cause          *DecisionTaskFailedCause `json:"cause,omitempty"`
	Details        []byte                   `json:"details,omitempty"`
	Identity       *string                  `json:"identity,omitempty"`
	BinaryChecksum *string                  `json:"binaryChecksum,omitempty"`
}

// ToWire translates a RespondDecisionTaskFailedRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RespondDecisionTaskFailedRequest) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TaskToken != nil {
		w, err = wire.NewValueBinary(v.TaskToken), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Cause != nil {
		w, err = v.Cause.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.Details != nil {
		w, err = wire.NewValueBinary(v.Details), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.Identity != nil {
		w, err = wire.NewValueString(*(v.Identity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.BinaryChecksum != nil {
		w, err = wire.NewValueString(*(v.BinaryChecksum)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _DecisionTaskFailedCause_Read(w wire.Value) (DecisionTaskFailedCause, error) {
	var v DecisionTaskFailedCause
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a RespondDecisionTaskFailedRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RespondDecisionTaskFailedRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RespondDecisionTaskFailedRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RespondDecisionTaskFailedRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				v.TaskToken, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI32 {
				var x DecisionTaskFailedCause
				x, err = _DecisionTaskFailedCause_Read(field.Value)
				v.Cause = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				v.Details, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Identity = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.BinaryChecksum = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RespondDecisionTaskFailedRequest
// struct.
func (v *RespondDecisionTaskFailedRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.TaskToken != nil {
		fields[i] = fmt.Sprintf("TaskToken: %v", v.TaskToken)
		i++
	}
	if v.Cause != nil {
		fields[i] = fmt.Sprintf("Cause: %v", *(v.Cause))
		i++
	}
	if v.Details != nil {
		fields[i] = fmt.Sprintf("Details: %v", v.Details)
		i++
	}
	if v.Identity != nil {
		fields[i] = fmt.Sprintf("Identity: %v", *(v.Identity))
		i++
	}
	if v.BinaryChecksum != nil {
		fields[i] = fmt.Sprintf("BinaryChecksum: %v", *(v.BinaryChecksum))
		i++
	}

	return fmt.Sprintf("RespondDecisionTaskFailedRequest{%v}", strings.Join(fields[:i], ", "))
}

func _DecisionTaskFailedCause_EqualsPtr(lhs, rhs *DecisionTaskFailedCause) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this RespondDecisionTaskFailedRequest match the
// provided RespondDecisionTaskFailedRequest.
//
// This function performs a deep comparison.
func (v *RespondDecisionTaskFailedRequest) Equals(rhs *RespondDecisionTaskFailedRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.TaskToken == nil && rhs.TaskToken == nil) || (v.TaskToken != nil && rhs.TaskToken != nil && bytes.Equal(v.TaskToken, rhs.TaskToken))) {
		return false
	}
	if !_DecisionTaskFailedCause_EqualsPtr(v.Cause, rhs.Cause) {
		return false
	}
	if !((v.Details == nil && rhs.Details == nil) || (v.Details != nil && rhs.Details != nil && bytes.Equal(v.Details, rhs.Details))) {
		return false
	}
	if !_String_EqualsPtr(v.Identity, rhs.Identity) {
		return false
	}
	if !_String_EqualsPtr(v.BinaryChecksum, rhs.BinaryChecksum) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RespondDecisionTaskFailedRequest.
func (v *RespondDecisionTaskFailedRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.TaskToken != nil {
		enc.AddString("taskToken", base64.StdEncoding.EncodeToString(v.TaskToken))
	}
	if v.Cause != nil {
		err = multierr.Append(err, enc.AddObject("cause", *v.Cause))
	}
	if v.Details != nil {
		enc.AddString("details", base64.StdEncoding.EncodeToString(v.Details))
	}
	if v.Identity != nil {
		enc.AddString("identity", *v.Identity)
	}
	if v.BinaryChecksum != nil {
		enc.AddString("binaryChecksum", *v.BinaryChecksum)
	}
	return err
}

// GetTaskToken returns the value of TaskToken if it is set or its
// zero value if it is unset.
func (v *RespondDecisionTaskFailedRequest) GetTaskToken() (o []byte) {
	if v != nil && v.TaskToken != nil {
		return v.TaskToken
	}

	return
}

// IsSetTaskToken returns true if TaskToken is not nil.
func (v *RespondDecisionTaskFailedRequest) IsSetTaskToken() bool {
	return v != nil && v.TaskToken != nil
}

// GetCause returns the value of Cause if it is set or its
// zero value if it is unset.
func (v *RespondDecisionTaskFailedRequest) GetCause() (o DecisionTaskFailedCause) {
	if v != nil && v.Cause != nil {
		return *v.Cause
	}

	return
}

// IsSetCause returns true if Cause is not nil.
func (v *RespondDecisionTaskFailedRequest) IsSetCause() bool {
	return v != nil && v.Cause != nil
}

// GetDetails returns the value of Details if it is set or its
// zero value if it is unset.
func (v *RespondDecisionTaskFailedRequest) GetDetails() (o []byte) {
	if v != nil && v.Details != nil {
		return v.Details
	}

	return
}

// IsSetDetails returns true if Details is not nil.
func (v *RespondDecisionTaskFailedRequest) IsSetDetails() bool {
	return v != nil && v.Details != nil
}

// GetIdentity returns the value of Identity if it is set or its
// zero value if it is unset.
func (v *RespondDecisionTaskFailedRequest) GetIdentity() (o string) {
	if v != nil && v.Identity != nil {
		return *v.Identity
	}

	return
}

// IsSetIdentity returns true if Identity is not nil.
func (v *RespondDecisionTaskFailedRequest) IsSetIdentity() bool {
	return v != nil && v.Identity != nil
}

// GetBinaryChecksum returns the value of BinaryChecksum if it is set or its
// zero value if it is unset.
func (v *RespondDecisionTaskFailedRequest) GetBinaryChecksum() (o string) {
	if v != nil && v.BinaryChecksum != nil {
		return *v.BinaryChecksum
	}

	return
}

// IsSetBinaryChecksum returns true if BinaryChecksum is not nil.
func (v *RespondDecisionTaskFailedRequest) IsSetBinaryChecksum() bool {
	return v != nil && v.BinaryChecksum != nil
}

type RespondQueryTaskCompletedRequest struct {
	TaskToken         []byte                  `json:"taskToken,omitempty"`
	CompletedType     *QueryTaskCompletedType `json:"completedType,omitempty"`
	QueryResult       []byte                  `json:"queryResult,omitempty"`
	ErrorMessage      *string                 `json:"errorMessage,omitempty"`
	WorkerVersionInfo *WorkerVersionInfo      `json:"workerVersionInfo,omitempty"`
}

// ToWire translates a RespondQueryTaskCompletedRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RespondQueryTaskCompletedRequest) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TaskToken != nil {
		w, err = wire.NewValueBinary(v.TaskToken), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.CompletedType != nil {
		w, err = v.CompletedType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.QueryResult != nil {
		w, err = wire.NewValueBinary(v.QueryResult), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.ErrorMessage != nil {
		w, err = wire.NewValueString(*(v.ErrorMessage)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.WorkerVersionInfo != nil {
		w, err = v.WorkerVersionInfo.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _QueryTaskCompletedType_Read(w wire.Value) (QueryTaskCompletedType, error) {
	var v QueryTaskCompletedType
	err := v.FromWire(w)
	return v, err
}

func _WorkerVersionInfo_Read(w wire.Value) (*WorkerVersionInfo, error) {
	var v WorkerVersionInfo
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a RespondQueryTaskCompletedRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RespondQueryTaskCompletedRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RespondQueryTaskCompletedRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RespondQueryTaskCompletedRequest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				v.TaskToken, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI32 {
				var x QueryTaskCompletedType
				x, err = _QueryTaskCompletedType_Read(field.Value)
				v.CompletedType = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				v.QueryResult, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ErrorMessage = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TStruct {
				v.WorkerVersionInfo, err = _WorkerVersionInfo_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RespondQueryTaskCompletedRequest
// struct.
func (v *RespondQueryTaskCompletedRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.TaskToken != nil {
		fields[i] = fmt.Sprintf("TaskToken: %v", v.TaskToken)
		i++
	}
	if v.CompletedType != nil {
		fields[i] = fmt.Sprintf("CompletedType: %v", *(v.CompletedType))
		i++
	}
	if v.QueryResult != nil {
		fields[i] = fmt.Sprintf("QueryResult: %v", v.QueryResult)
		i++
	}
	if v.ErrorMessage != nil {
		fields[i] = fmt.Sprintf("ErrorMessage: %v", *(v.ErrorMessage))
		i++
	}
	if v.WorkerVersionInfo != nil {
		fields[i] = fmt.Sprintf("WorkerVersionInfo: %v", v.WorkerVersionInfo)
		i++
	}

	return fmt.Sprintf("RespondQueryTaskCompletedRequest{%v}", strings.Join(fields[:i], ", "))
}

func _QueryTaskCompletedType_EqualsPtr(lhs, rhs *QueryTaskCompletedType) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this RespondQueryTaskCompletedRequest match the
// provided RespondQueryTaskCompletedRequest.
//
// This function performs a deep comparison.
func (v *RespondQueryTaskCompletedRequest) Equals(rhs *RespondQueryTaskCompletedRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.TaskToken == nil && rhs.TaskToken == nil) || (v.TaskToken != nil && rhs.TaskToken != nil && bytes.Equal(v.TaskToken, rhs.TaskToken))) {
		return false
	}
	if !_QueryTaskCompletedType_EqualsPtr(v.CompletedType, rhs.CompletedType) {
		return false
	}
	if !((v.QueryResult == nil && rhs.QueryResult == nil) || (v.QueryResult != nil && rhs.QueryResult != nil && bytes.Equal(v.QueryResult, rhs.QueryResult))) {
		return false
	}
	if !_String_EqualsPtr(v.ErrorMessage, rhs.ErrorMessage) {
		return false
	}
	if !((v.WorkerVersionInfo == nil && rhs.WorkerVersionInfo == nil) || (v.WorkerVersionInfo != nil && rhs.WorkerVersionInfo != nil && v.WorkerVersionInfo.Equals(rhs.WorkerVersionInfo))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RespondQueryTaskCompletedRequest.
func (v *RespondQueryTaskCompletedRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.TaskToken != nil {
		enc.AddString("taskToken", base64.StdEncoding.EncodeToString(v.TaskToken))
	}
	if v.CompletedType != nil {
		err = multierr.Append(err, enc.AddObject("completedType", *v.CompletedType))
	}
	if v.QueryResult != nil {
		enc.AddString("queryResult", base64.StdEncoding.EncodeToString(v.QueryResult))
	}
	if v.ErrorMessage != nil {
		enc.AddString("errorMessage", *v.ErrorMessage)
	}
	if v.WorkerVersionInfo != nil {
		err = multierr.Append(err, enc.AddObject("workerVersionInfo", v.WorkerVersionInfo))
	}
	return err
}

// GetTaskToken returns the value of TaskToken if it is set or its
// zero value if it is unset.
func (v *RespondQueryTaskCompletedRequest) GetTaskToken() (o []byte) {
	if v != nil && v.TaskToken != nil {
		return v.TaskToken
	}

	return
}

// IsSetTaskToken returns true if TaskToken is not nil.
func (v *RespondQueryTaskCompletedRequest) IsSetTaskToken() bool {
	return v != nil && v.TaskToken != nil
}

// GetCompletedType returns the value of CompletedType if it is set or its
// zero value if it is unset.
func (v *RespondQueryTaskCompletedRequest) GetCompletedType() (o QueryTaskCompletedType) {
	if v != nil && v.CompletedType != nil {
		return *v.CompletedType
	}

	return
}

// IsSetCompletedType returns true if CompletedType is not nil.
func (v *RespondQueryTaskCompletedRequest) IsSetCompletedType() bool {
	return v != nil && v.CompletedType != nil
}

// GetQueryResult returns the value of QueryResult if it is set or its
// zero value if it is unset.
func (v *RespondQueryTaskCompletedRequest) GetQueryResult() (o []byte) {
	if v != nil && v.QueryResult != nil {
		return v.QueryResult
	}

	return
}

// IsSetQueryResult returns true if QueryResult is not nil.
func (v *RespondQueryTaskCompletedRequest) IsSetQueryResult() bool {
	return v != nil && v.QueryResult != nil
}

// GetErrorMessage returns the value of ErrorMessage if it is set or its
// zero value if it is unset.
func (v *RespondQueryTaskCompletedRequest) GetErrorMessage() (o string) {
	if v != nil && v.ErrorMessage != nil {
		return *v.ErrorMessage
	}

	return
}

// IsSetErrorMessage returns true if ErrorMessage is not nil.
func (v *RespondQueryTaskCompletedRequest) IsSetErrorMessage() bool {
	return v != nil && v.ErrorMessage != nil
}

// GetWorkerVersionInfo returns the value of WorkerVersionInfo if it is set or its
// zero value if it is unset.
func (v *RespondQueryTaskCompletedRequest) GetWorkerVersionInfo() (o *WorkerVersionInfo) {
	if v != nil && v.WorkerVersionInfo != nil {
		return v.WorkerVersionInfo
	}

	return
}

// IsSetWorkerVersionInfo returns true if WorkerVersionInfo is not nil.
func (v *RespondQueryTaskCompletedRequest) IsSetWorkerVersionInfo() bool {
	return v != nil && v.WorkerVersionInfo != nil
}

type RetryPolicy struct {
	InitialIntervalInSeconds    *int32   `json:"initialIntervalInSeconds,omitempty"`
	BackoffCoefficient          *float64 `json:"backoffCoefficient,omitempty"`
	MaximumIntervalInSeconds    *int32   `json:"maximumIntervalInSeconds,omitempty"`
	MaximumAttempts             *int32   `json:"maximumAttempts,omitempty"`
	NonRetriableErrorReasons    []string `json:"nonRetriableErrorReasons,omitempty"`
	ExpirationIntervalInSeconds *int32   `json:"expirationIntervalInSeconds,omitempty"`
}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_String_ValueList) Size() int {
	return len(v)
}

func (_List_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_String_ValueList) Close() {}

// ToWire translates a RetryPolicy struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RetryPolicy) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.InitialIntervalInSeconds != nil {
		w, err = wire.NewValueI32(*(v.InitialIntervalInSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.BackoffCoefficient != nil {
		w, err = wire.NewValueDouble(*(v.BackoffCoefficient)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.MaximumIntervalInSeconds != nil {
		w, err = wire.NewValueI32(*(v.MaximumIntervalInSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.MaximumAttempts != nil {
		w, err = wire.NewValueI32(*(v.MaximumAttempts)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.NonRetriableErrorReasons != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.NonRetriableErrorReasons)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.ExpirationIntervalInSeconds != nil {
		w, err = wire.NewValueI32(*(v.ExpirationIntervalInSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_String_Read(l wire.ValueList) ([]string, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]string, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a RetryPolicy struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RetryPolicy struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RetryPolicy
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RetryPolicy) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.InitialIntervalInSeconds = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.BackoffCoefficient = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.MaximumIntervalInSeconds = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.MaximumAttempts = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TList {
				v.NonRetriableErrorReasons, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ExpirationIntervalInSeconds = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RetryPolicy
// struct.
func (v *RetryPolicy) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.InitialIntervalInSeconds != nil {
		fields[i] = fmt.Sprintf("InitialIntervalInSeconds: %v", *(v.InitialIntervalInSeconds))
		i++
	}
	if v.BackoffCoefficient != nil {
		fields[i] = fmt.Sprintf("BackoffCoefficient: %v", *(v.BackoffCoefficient))
		i++
	}
	if v.MaximumIntervalInSeconds != nil {
		fields[i] = fmt.Sprintf("MaximumIntervalInSeconds: %v", *(v.MaximumIntervalInSeconds))
		i++
	}
	if v.MaximumAttempts != nil {
		fields[i] = fmt.Sprintf("MaximumAttempts: %v", *(v.MaximumAttempts))
		i++
	}
	if v.NonRetriableErrorReasons != nil {
		fields[i] = fmt.Sprintf("NonRetriableErrorReasons: %v", v.NonRetriableErrorReasons)
		i++
	}
	if v.ExpirationIntervalInSeconds != nil {
		fields[i] = fmt.Sprintf("ExpirationIntervalInSeconds: %v", *(v.ExpirationIntervalInSeconds))
		i++
	}

	return fmt.Sprintf("RetryPolicy{%v}", strings.Join(fields[:i], ", "))
}

func _List_String_Equals(lhs, rhs []string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this RetryPolicy match the
// provided RetryPolicy.
//
// This function performs a deep comparison.
func (v *RetryPolicy) Equals(rhs *RetryPolicy) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.InitialIntervalInSeconds, rhs.InitialIntervalInSeconds) {
		return false
	}
	if !_Double_EqualsPtr(v.BackoffCoefficient, rhs.BackoffCoefficient) {
		return false
	}
	if !_I32_EqualsPtr(v.MaximumIntervalInSeconds, rhs.MaximumIntervalInSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.MaximumAttempts, rhs.MaximumAttempts) {
		return false
	}
	if !((v.NonRetriableErrorReasons == nil && rhs.NonRetriableErrorReasons == nil) || (v.NonRetriableErrorReasons != nil && rhs.NonRetriableErrorReasons != nil && _List_String_Equals(v.NonRetriableErrorReasons, rhs.NonRetriableErrorReasons))) {
		return false
	}
	if !_I32_EqualsPtr(v.ExpirationIntervalInSeconds, rhs.ExpirationIntervalInSeconds) {
		return false
	}

	return true
}

type _List_String_Zapper []string

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_String_Zapper.
func (l _List_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendString(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RetryPolicy.
func (v *RetryPolicy) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.InitialIntervalInSeconds != nil {
		enc.AddInt32("initialIntervalInSeconds", *v.InitialIntervalInSeconds)
	}
	if v.BackoffCoefficient != nil {
		enc.AddFloat64("backoffCoefficient", *v.BackoffCoefficient)
	}
	if v.MaximumIntervalInSeconds != nil {
		enc.AddInt32("maximumIntervalInSeconds", *v.MaximumIntervalInSeconds)
	}
	if v.MaximumAttempts != nil {
		enc.AddInt32("maximumAttempts", *v.MaximumAttempts)
	}
	if v.NonRetriableErrorReasons != nil {
		err = multierr.Append(err, enc.AddArray("nonRetriableErrorReasons", (_List_String_Zapper)(v.NonRetriableErrorReasons)))
	}
	if v.ExpirationIntervalInSeconds != nil {
		enc.AddInt32("expirationIntervalInSeconds", *v.ExpirationIntervalInSeconds)
	}
	return err
}

// GetInitialIntervalInSeconds returns the value of InitialIntervalInSeconds if it is set or its
// zero value if it is unset.
func (v *RetryPolicy) GetInitialIntervalInSeconds() (o int32) {
	if v != nil && v.InitialIntervalInSeconds != nil {
		return *v.InitialIntervalInSeconds
	}

	return
}

// IsSetInitialIntervalInSeconds returns true if InitialIntervalInSeconds is not nil.
func (v *RetryPolicy) IsSetInitialIntervalInSeconds() bool {
	return v != nil && v.InitialIntervalInSeconds != nil
}

// GetBackoffCoefficient returns the value of BackoffCoefficient if it is set or its
// zero value if it is unset.
func (v *RetryPolicy) GetBackoffCoefficient() (o float64) {
	if v != nil && v.BackoffCoefficient != nil {
		return *v.BackoffCoefficient
	}

	return
}

// IsSetBackoffCoefficient returns true if BackoffCoefficient is not nil.
func (v *RetryPolicy) IsSetBackoffCoefficient() bool {
	return v != nil && v.BackoffCoefficient != nil
}

// GetMaximumIntervalInSeconds returns the value of MaximumIntervalInSeconds if it is set or its
// zero value if it is unset.
func (v *RetryPolicy) GetMaximumIntervalInSeconds() (o int32) {
	if v != nil && v.MaximumIntervalInSeconds != nil {
		return *v.MaximumIntervalInSeconds
	}

	return
}

// IsSetMaximumIntervalInSeconds returns true if MaximumIntervalInSeconds is not nil.
func (v *RetryPolicy) IsSetMaximumIntervalInSeconds() bool {
	return v != nil && v.MaximumIntervalInSeconds != nil
}

// GetMaximumAttempts returns the value of MaximumAttempts if it is set or its
// zero value if it is unset.
func (v *RetryPolicy) GetMaximumAttempts() (o int32) {
	if v != nil && v.MaximumAttempts != nil {
		return *v.MaximumAttempts
	}

	return
}

// IsSetMaximumAttempts returns true if MaximumAttempts is not nil.
func (v *RetryPolicy) IsSetMaximumAttempts() bool {
	return v != nil && v.MaximumAttempts != nil
}

// GetNonRetriableErrorReasons returns the value of NonRetriableErrorReasons if it is set or its
// zero value if it is unset.
func (v *RetryPolicy) GetNonRetriableErrorReasons() (o []string) {
	if v != nil && v.NonRetriableErrorReasons != nil {
		return v.NonRetriableErrorReasons
	}

	return
}

// IsSetNonRetriableErrorReasons returns true if NonRetriableErrorReasons is not nil.
func (v *RetryPolicy) IsSetNonRetriableErrorReasons() bool {
	return v != nil && v.NonRetriableErrorReasons != nil
}

// GetExpirationIntervalInSeconds returns the value of ExpirationIntervalInSeconds if it is set or its
// zero value if it is unset.
func (v *RetryPolicy) GetExpirationIntervalInSeconds() (o int32) {
	if v != nil && v.ExpirationIntervalInSeconds != nil {
		return *v.ExpirationIntervalInSeconds
	}

	return
}

// IsSetExpirationIntervalInSeconds returns true if ExpirationIntervalInSeconds is not nil.
func (v *RetryPolicy) IsSetExpirationIntervalInSeconds() bool {
	return v != nil && v.ExpirationIntervalInSeconds != nil
}

type SearchAttributes struct {
	IndexedFields map[string][]byte `json:"indexedFields,omitempty"`
}

// ToWire translates a SearchAttributes struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *SearchAttributes) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.IndexedFields != nil {
		w, err = wire.NewValueMap(_Map_String_Binary_MapItemList(v.IndexedFields)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a SearchAttributes struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a SearchAttributes struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v SearchAttributes
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *SearchAttributes) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TMap {
				v.IndexedFields, err = _Map_String_Binary_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a SearchAttributes
// struct.
func (v *SearchAttributes) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.IndexedFields != nil {
		fields[i] = fmt.Sprintf("IndexedFields: %v", v.IndexedFields)
		i++
	}

	return fmt.Sprintf("SearchAttributes{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this SearchAttributes match the
// provided SearchAttributes.
//
// This function performs a deep comparison.
func (v *SearchAttributes) Equals(rhs *SearchAttributes) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.IndexedFields == nil && rhs.IndexedFields == nil) || (v.IndexedFields != nil && rhs.IndexedFields != nil && _Map_String_Binary_Equals(v.IndexedFields, rhs.IndexedFields))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of SearchAttributes.
func (v *SearchAttributes) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.IndexedFields != nil {
		err = multierr.Append(err, enc.AddObject("indexedFields", (_Map_String_Binary_Zapper)(v.IndexedFields)))
	}
	return err
}

// GetIndexedFields returns the value of IndexedFields if it is set or its
// zero value if it is unset.
func (v *SearchAttributes) GetIndexedFields() (o map[string][]byte) {
	if v != nil && v.IndexedFields != nil {
		return v.IndexedFields
	}

	return
}

// IsSetIndexedFields returns true if IndexedFields is not nil.
func (v *SearchAttributes) IsSetIndexedFields() bool {
	return v != nil && v.IndexedFields != nil
}

type SignalExternalWorkflowExecutionFailedCause int32

const (
	SignalExternalWorkflowExecutionFailedCauseUnknownExternalWorkflowExecution SignalExternalWorkflowExecutionFailedCause = 0
)

// SignalExternalWorkflowExecutionFailedCause_Values returns all recognized values of SignalExternalWorkflowExecutionFailedCause.
func SignalExternalWorkflowExecutionFailedCause_Values() []SignalExternalWorkflowExecutionFailedCause {
	return []SignalExternalWorkflowExecutionFailedCause{
		SignalExternalWorkflowExecutionFailedCauseUnknownExternalWorkflowExecution,
	}
}

// UnmarshalText tries to decode SignalExternalWorkflowExecutionFailedCause from a byte slice
// containing its name.
//
//   var v SignalExternalWorkflowExecutionFailedCause
//   err := v.UnmarshalText([]byte("UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION"))
func (v *SignalExternalWorkflowExecutionFailedCause) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION":
		*v = SignalExternalWorkflowExecutionFailedCauseUnknownExternalWorkflowExecution
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "SignalExternalWorkflowExecutionFailedCause", err)
		}
		*v = SignalExternalWorkflowExecutionFailedCause(val)
		return nil
	}
}

// MarshalText encodes SignalExternalWorkflowExecutionFailedCause to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v SignalExternalWorkflowExecutionFailedCause) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of SignalExternalWorkflowExecutionFailedCause.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v SignalExternalWorkflowExecutionFailedCause) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v SignalExternalWorkflowExecutionFailedCause) Ptr() *SignalExternalWorkflowExecutionFailedCause {
	return &v
}

// ToWire translates SignalExternalWorkflowExecutionFailedCause into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v SignalExternalWorkflowExecutionFailedCause) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes SignalExternalWorkflowExecutionFailedCause from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return SignalExternalWorkflowExecutionFailedCause(0), err
//   }
//
//   var v SignalExternalWorkflowExecutionFailedCause
//   if err := v.FromWire(x); err != nil {
//     return SignalExternalWorkflowExecutionFailedCause(0), err
//   }
//   return v, nil
func (v *SignalExternalWorkflowExecutionFailedCause) FromWire(w wire.Value) error {
	*v = (SignalExternalWorkflowExecutionFailedCause)(w.GetI32())
	return nil
}

// String returns a readable string representation of SignalExternalWorkflowExecutionFailedCause.
func (v SignalExternalWorkflowExecutionFailedCause) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION"
	}
	return fmt.Sprintf("SignalExternalWorkflowExecutionFailedCause(%d)", w)
}

// Equals returns true if this SignalExternalWorkflowExecutionFailedCause value matches the provided
// value.
func (v SignalExternalWorkflowExecutionFailedCause) Equals(rhs SignalExternalWorkflowExecutionFailedCause) bool {
	return v == rhs
}

// MarshalJSON serializes SignalExternalWorkflowExecutionFailedCause into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v SignalExternalWorkflowExecutionFailedCause) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode SignalExternalWorkflowExecutionFailedCause from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *SignalExternalWorkflowExecutionFailedCause) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "SignalExternalWorkflowExecutionFailedCause")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "SignalExternalWorkflowExecutionFailedCause")
		}
		*v = (SignalExternalWorkflowExecutionFailedCause)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "SignalExternalWorkflowExecutionFailedCause")
	}
}

type StartTimeFilter struct {
	EarliestTime *int64 `json:"earliestTime,omitempty"`
	LatestTime   *int64 `json:"latestTime,omitempty"`
}

// ToWire translates a StartTimeFilter struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *StartTimeFilter) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.EarliestTime != nil {
		w, err = wire.NewValueI64(*(v.EarliestTime)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.LatestTime != nil {
		w, err = wire.NewValueI64(*(v.LatestTime)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a StartTimeFilter struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a StartTimeFilter struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v StartTimeFilter
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *StartTimeFilter) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.EarliestTime = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.LatestTime = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a StartTimeFilter
// struct.
func (v *StartTimeFilter) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.EarliestTime != nil {
		fields[i] = fmt.Sprintf("EarliestTime: %v", *(v.EarliestTime))
		i++
	}
	if v.LatestTime != nil {
		fields[i] = fmt.Sprintf("LatestTime: %v", *(v.LatestTime))
		i++
	}

	return fmt.Sprintf("StartTimeFilter{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this StartTimeFilter match the
// provided StartTimeFilter.
//
// This function performs a deep comparison.
func (v *StartTimeFilter) Equals(rhs *StartTimeFilter) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.EarliestTime, rhs.EarliestTime) {
		return false
	}
	if !_I64_EqualsPtr(v.LatestTime, rhs.LatestTime) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of StartTimeFilter.
func (v *StartTimeFilter) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.EarliestTime != nil {
		enc.AddInt64("earliestTime", *v.EarliestTime)
	}
	if v.LatestTime != nil {
		enc.AddInt64("latestTime", *v.LatestTime)
	}
	return err
}

// GetEarliestTime returns the value of EarliestTime if it is set or its
// zero value if it is unset.
func (v *StartTimeFilter) GetEarliestTime() (o int64) {
	if v != nil && v.EarliestTime != nil {
		return *v.EarliestTime
	}

	return
}

// IsSetEarliestTime returns true if EarliestTime is not nil.
func (v *StartTimeFilter) IsSetEarliestTime() bool {
	return v != nil && v.EarliestTime != nil
}

// GetLatestTime returns the value of LatestTime if it is set or its
// zero value if it is unset.
func (v *StartTimeFilter) GetLatestTime() (o int64) {
	if v != nil && v.LatestTime != nil {
		return *v.LatestTime
	}

	return
}

// IsSetLatestTime returns true if LatestTime is not nil.
func (v *StartTimeFilter) IsSetLatestTime() bool {
	return v != nil && v.LatestTime != nil
}

type StartWorkflowExecutionResponse struct {
	RunId *string `json:"runId,omitempty"`
}

// ToWire translates a StartWorkflowExecutionResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *StartWorkflowExecutionResponse) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.RunId != nil {
		w, err = wire.NewValueString(*(v.RunId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a StartWorkflowExecutionResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a StartWorkflowExecutionResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v StartWorkflowExecutionResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *StartWorkflowExecutionResponse) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RunId = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a StartWorkflowExecutionResponse
// struct.
func (v *StartWorkflowExecutionResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.RunId != nil {
		fields[i] = fmt.Sprintf("RunId: %v", *(v.RunId))
		i++
	}

	return fmt.Sprintf("StartWorkflowExecutionResponse{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this StartWorkflowExecutionResponse match the
// provided StartWorkflowExecutionResponse.
//
// This function performs a deep comparison.
func (v *StartWorkflowExecutionResponse) Equals(rhs *StartWorkflowExecutionResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.RunId, rhs.RunId) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of StartWorkflowExecutionResponse.
func (v *StartWorkflowExecutionResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.RunId != nil {
		enc.AddString("runId", *v.RunId)
	}
	return err
}

// GetRunId returns the value of RunId if it is set or its
// zero value if it is unset.
func (v *StartWorkflowExecutionResponse) GetRunId() (o string) {
	if v != nil && v.RunId != nil {
		return *v.RunId
	}

	return
}

// IsSetRunId returns true if RunId is not nil.
func (v *StartWorkflowExecutionResponse) IsSetRunId() bool {
	return v != nil && v.RunId != nil
}

type StickyExecutionAttributes struct {
	WorkerTaskList                *TaskList `json:"workerTaskList,omitempty"`
	ScheduleToStartTimeoutSeconds *int32    `json:"scheduleToStartTimeoutSeconds,omitempty"`
}

// ToWire translates a StickyExecutionAttributes struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *StickyExecutionAttributes) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.WorkerTaskList != nil {
		w, err = v.WorkerTaskList.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.ScheduleToStartTimeoutSeconds != nil {
		w, err = wire.NewValueI32(*(v.ScheduleToStartTimeoutSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a StickyExecutionAttributes struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a StickyExecutionAttributes struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v StickyExecutionAttributes
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *StickyExecutionAttributes) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TStruct {
				v.WorkerTaskList, err = _TaskList_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ScheduleToStartTimeoutSeconds = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a StickyExecutionAttributes
// struct.
func (v *StickyExecutionAttributes) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.WorkerTaskList != nil {
		fields[i] = fmt.Sprintf("WorkerTaskList: %v", v.WorkerTaskList)
		i++
	}
	if v.ScheduleToStartTimeoutSeconds != nil {
		fields[i] = fmt.Sprintf("ScheduleToStartTimeoutSeconds: %v", *(v.ScheduleToStartTimeoutSeconds))
		i++
	}

	return fmt.Sprintf("StickyExecutionAttributes{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this StickyExecutionAttributes match the
// provided StickyExecutionAttributes.
//
// This function performs a deep comparison.
func (v *StickyExecutionAttributes) Equals(rhs *StickyExecutionAttributes) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.WorkerTaskList == nil && rhs.WorkerTaskList == nil) || (v.WorkerTaskList != nil && rhs.WorkerTaskList != nil && v.WorkerTaskList.Equals(rhs.WorkerTaskList))) {
		return false
	}
	if !_I32_EqualsPtr(v.ScheduleToStartTimeoutSeconds, rhs.ScheduleToStartTimeoutSeconds) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of StickyExecutionAttributes.
func (v *StickyExecutionAttributes) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.WorkerTaskList != nil {
		err = multierr.Append(err, enc.AddObject("workerTaskList", v.WorkerTaskList))
	}
	if v.ScheduleToStartTimeoutSeconds != nil {
		enc.AddInt32("scheduleToStartTimeoutSeconds", *v.ScheduleToStartTimeoutSeconds)
	}
	return err
}

// GetWorkerTaskList returns the value of WorkerTaskList if it is set or its
// zero value if it is unset.
func (v *StickyExecutionAttributes) GetWorkerTaskList() (o *TaskList) {
	if v != nil && v.WorkerTaskList != nil {
		return v.WorkerTaskList
	}

	return
}

// IsSetWorkerTaskList returns true if WorkerTaskList is not nil.
func (v *StickyExecutionAttributes) IsSetWorkerTaskList() bool {
	return v != nil && v.WorkerTaskList != nil
}

// GetScheduleToStartTimeoutSeconds returns the value of ScheduleToStartTimeoutSeconds if it is set or its
// zero value if it is unset.
func (v *StickyExecutionAttributes) GetScheduleToStartTimeoutSeconds() (o int32) {
	if v != nil && v.ScheduleToStartTimeoutSeconds != nil {
		return *v.ScheduleToStartTimeoutSeconds
	}

	return
}

// IsSetScheduleToStartTimeoutSeconds returns true if ScheduleToStartTimeoutSeconds is not nil.
func (v *StickyExecutionAttributes) IsSetScheduleToStartTimeoutSeconds() bool {
	return v != nil && v.ScheduleToStartTimeoutSeconds != nil
}

type SupportedClientVersions struct {
	GoSdk   *string `json:"goSdk,omitempty"`
	JavaSdk *string `json:"javaSdk,omitempty"`
}

// ToWire translates a SupportedClientVersions struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *SupportedClientVersions) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.GoSdk != nil {
		w, err = wire.NewValueString(*(v.GoSdk)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.JavaSdk != nil {
		w, err = wire.NewValueString(*(v.JavaSdk)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a SupportedClientVersions struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a SupportedClientVersions struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v SupportedClientVersions
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *SupportedClientVersions) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.GoSdk = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.JavaSdk = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a SupportedClientVersions
// struct.
func (v *SupportedClientVersions) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.GoSdk != nil {
		fields[i] = fmt.Sprintf("GoSdk: %v", *(v.GoSdk))
		i++
	}
	if v.JavaSdk != nil {
		fields[i] = fmt.Sprintf("JavaSdk: %v", *(v.JavaSdk))
		i++
	}

	return fmt.Sprintf("SupportedClientVersions{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this SupportedClientVersions match the
// provided SupportedClientVersions.
//
// This function performs a deep comparison.
func (v *SupportedClientVersions) Equals(rhs *SupportedClientVersions) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.GoSdk, rhs.GoSdk) {
		return false
	}
	if !_String_EqualsPtr(v.JavaSdk, rhs.JavaSdk) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of SupportedClientVersions.
func (v *SupportedClientVersions) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.GoSdk != nil {
		enc.AddString("goSdk", *v.GoSdk)
	}
	if v.JavaSdk != nil {
		enc.AddString("javaSdk", *v.JavaSdk)
	}
	return err
}

// GetGoSdk returns the value of GoSdk if it is set or its
// zero value if it is unset.
func (v *SupportedClientVersions) GetGoSdk() (o string) {
	if v != nil && v.GoSdk != nil {
		return *v.GoSdk
	}

	return
}

// IsSetGoSdk returns true if GoSdk is not nil.
func (v *SupportedClientVersions) IsSetGoSdk() bool {
	return v != nil && v.GoSdk != nil
}

// GetJavaSdk returns the value of JavaSdk if it is set or its
// zero value if it is unset.
func (v *SupportedClientVersions) GetJavaSdk() (o string) {
	if v != nil && v.JavaSdk != nil {
		return *v.JavaSdk
	}

	return
}

// IsSetJavaSdk returns true if JavaSdk is not nil.
func (v *SupportedClientVersions) IsSetJavaSdk() bool {
	return v != nil && v.JavaSdk != nil
}

type TaskIDBlock struct {
	StartID *int64 `json:"startID,omitempty"`
	EndID   *int64 `json:"endID,omitempty"`
}

// ToWire translates a TaskIDBlock struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TaskIDBlock) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.StartID != nil {
		w, err = wire.NewValueI64(*(v.StartID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.EndID != nil {
		w, err = wire.NewValueI64(*(v.EndID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a TaskIDBlock struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TaskIDBlock struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TaskIDBlock
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TaskIDBlock) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.StartID = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.EndID = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a TaskIDBlock
// struct.
func (v *TaskIDBlock) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.StartID != nil {
		fields[i] = fmt.Sprintf("StartID: %v", *(v.StartID))
		i++
	}
	if v.EndID != nil {
		fields[i] = fmt.Sprintf("EndID: %v", *(v.EndID))
		i++
	}

	return fmt.Sprintf("TaskIDBlock{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TaskIDBlock match the
// provided TaskIDBlock.
//
// This function performs a deep comparison.
func (v *TaskIDBlock) Equals(rhs *TaskIDBlock) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.StartID, rhs.StartID) {
		return false
	}
	if !_I64_EqualsPtr(v.EndID, rhs.EndID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskIDBlock.
func (v *TaskIDBlock) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.StartID != nil {
		enc.AddInt64("startID", *v.StartID)
	}
	if v.EndID != nil {
		enc.AddInt64("endID", *v.EndID)
	}
	return err
}

// GetStartID returns the value of StartID if it is set or its
// zero value if it is unset.
func (v *TaskIDBlock) GetStartID() (o int64) {
	if v != nil && v.StartID != nil {
		return *v.StartID
	}

	return
}

// IsSetStartID returns true if StartID is not nil.
func (v *TaskIDBlock) IsSetStartID() bool {
	return v != nil && v.StartID != nil
}

// GetEndID returns the value of EndID if it is set or its
// zero value if it is unset.
func (v *TaskIDBlock) GetEndID() (o int64) {
	if v != nil && v.EndID != nil {
		return *v.EndID
	}

	return
}

// IsSetEndID returns true if EndID is not nil.
func (v *TaskIDBlock) IsSetEndID() bool {
	return v != nil && v.EndID != nil
}

type TaskList struct {
	Name *string       `json:"name,omitempty"`
	Kind *TaskListKind `json:"kind,omitempty"`
}

// ToWire translates a TaskList struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TaskList) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Kind != nil {
		w, err = v.Kind.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _TaskListKind_Read(w wire.Value) (TaskListKind, error) {
	var v TaskListKind
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a TaskList struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TaskList struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TaskList
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TaskList) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI32 {
				var x TaskListKind
				x, err = _TaskListKind_Read(field.Value)
				v.Kind = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a TaskList
// struct.
func (v *TaskList) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Kind != nil {
		fields[i] = fmt.Sprintf("Kind: %v", *(v.Kind))
		i++
	}

	return fmt.Sprintf("TaskList{%v}", strings.Join(fields[:i], ", "))
}

func _TaskListKind_EqualsPtr(lhs, rhs *TaskListKind) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this TaskList match the
// provided TaskList.
//
// This function performs a deep comparison.
func (v *TaskList) Equals(rhs *TaskList) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_TaskListKind_EqualsPtr(v.Kind, rhs.Kind) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskList.
func (v *TaskList) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Kind != nil {
		err = multierr.Append(err, enc.AddObject("kind", *v.Kind))
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *TaskList) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *TaskList) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetKind returns the value of Kind if it is set or its
// zero value if it is unset.
func (v *TaskList) GetKind() (o TaskListKind) {
	if v != nil && v.Kind != nil {
		return *v.Kind
	}

	return
}

// IsSetKind returns true if Kind is not nil.
func (v *TaskList) IsSetKind() bool {
	return v != nil && v.Kind != nil
}

type TaskListKind int32

const (
	TaskListKindNormal TaskListKind = 0
	TaskListKindSticky TaskListKind = 1
)

// TaskListKind_Values returns all recognized values of TaskListKind.
func TaskListKind_Values() []TaskListKind {
	return []TaskListKind{
		TaskListKindNormal,
		TaskListKindSticky,
	}
}

// UnmarshalText tries to decode TaskListKind from a byte slice
// containing its name.
//
//   var v TaskListKind
//   err := v.UnmarshalText([]byte("NORMAL"))
func (v *TaskListKind) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "NORMAL":
		*v = TaskListKindNormal
		return nil
	case "STICKY":
		*v = TaskListKindSticky
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "TaskListKind", err)
		}
		*v = TaskListKind(val)
		return nil
	}
}

// MarshalText encodes TaskListKind to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v TaskListKind) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("NORMAL"), nil
	case 1:
		return []byte("STICKY"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskListKind.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v TaskListKind) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "NORMAL")
	case 1:
		enc.AddString("name", "STICKY")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v TaskListKind) Ptr() *TaskListKind {
	return &v
}

// ToWire translates TaskListKind into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v TaskListKind) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes TaskListKind from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return TaskListKind(0), err
//   }
//
//   var v TaskListKind
//   if err := v.FromWire(x); err != nil {
//     return TaskListKind(0), err
//   }
//   return v, nil
func (v *TaskListKind) FromWire(w wire.Value) error {
	*v = (TaskListKind)(w.GetI32())
	return nil
}

// String returns a readable string representation of TaskListKind.
func (v TaskListKind) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "NORMAL"
	case 1:
		return "STICKY"
	}
	return fmt.Sprintf("TaskListKind(%d)", w)
}

// Equals returns true if this TaskListKind value matches the provided
// value.
func (v TaskListKind) Equals(rhs TaskListKind) bool {
	return v == rhs
}

// MarshalJSON serializes TaskListKind into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v TaskListKind) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"NORMAL\""), nil
	case 1:
		return ([]byte)("\"STICKY\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode TaskListKind from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *TaskListKind) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "TaskListKind")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "TaskListKind")
		}
		*v = (TaskListKind)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "TaskListKind")
	}
}

type TaskListMetadata struct {
	MaxTasksPerSecond *float64 `json:"maxTasksPerSecond,omitempty"`
}

// ToWire translates a TaskListMetadata struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TaskListMetadata) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.MaxTasksPerSecond != nil {
		w, err = wire.NewValueDouble(*(v.MaxTasksPerSecond)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a TaskListMetadata struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TaskListMetadata struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TaskListMetadata
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TaskListMetadata) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.MaxTasksPerSecond = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a TaskListMetadata
// struct.
func (v *TaskListMetadata) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.MaxTasksPerSecond != nil {
		fields[i] = fmt.Sprintf("MaxTasksPerSecond: %v", *(v.MaxTasksPerSecond))
		i++
	}

	return fmt.Sprintf("TaskListMetadata{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TaskListMetadata match the
// provided TaskListMetadata.
//
// This function performs a deep comparison.
func (v *TaskListMetadata) Equals(rhs *TaskListMetadata) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Double_EqualsPtr(v.MaxTasksPerSecond, rhs.MaxTasksPerSecond) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskListMetadata.
func (v *TaskListMetadata) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.MaxTasksPerSecond != nil {
		enc.AddFloat64("maxTasksPerSecond", *v.MaxTasksPerSecond)
	}
	return err
}

// GetMaxTasksPerSecond returns the value of MaxTasksPerSecond if it is set or its
// zero value if it is unset.
func (v *TaskListMetadata) GetMaxTasksPerSecond() (o float64) {
	if v != nil && v.MaxTasksPerSecond != nil {
		return *v.MaxTasksPerSecond
	}

	return
}

// IsSetMaxTasksPerSecond returns true if MaxTasksPerSecond is not nil.
func (v *TaskListMetadata) IsSetMaxTasksPerSecond() bool {
	return v != nil && v.MaxTasksPerSecond != nil
}

type TaskListPartitionMetadata struct {
	Key           *string `json:"key,omitempty"`
	OwnerHostName *string `json:"ownerHostName,omitempty"`
}

// ToWire translates a TaskListPartitionMetadata struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TaskListPartitionMetadata) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Key != nil {
		w, err = wire.NewValueString(*(v.Key)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.OwnerHostName != nil {
		w, err = wire.NewValueString(*(v.OwnerHostName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a TaskListPartitionMetadata struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TaskListPartitionMetadata struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TaskListPartitionMetadata
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TaskListPartitionMetadata) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Key = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.OwnerHostName = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a TaskListPartitionMetadata
// struct.
func (v *TaskListPartitionMetadata) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Key != nil {
		fields[i] = fmt.Sprintf("Key: %v", *(v.Key))
		i++
	}
	if v.OwnerHostName != nil {
		fields[i] = fmt.Sprintf("OwnerHostName: %v", *(v.OwnerHostName))
		i++
	}

	return fmt.Sprintf("TaskListPartitionMetadata{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TaskListPartitionMetadata match the
// provided TaskListPartitionMetadata.
//
// This function performs a deep comparison.
func (v *TaskListPartitionMetadata) Equals(rhs *TaskListPartitionMetadata) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Key, rhs.Key) {
		return false
	}
	if !_String_EqualsPtr(v.OwnerHostName, rhs.OwnerHostName) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskListPartitionMetadata.
func (v *TaskListPartitionMetadata) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Key != nil {
		enc.AddString("key", *v.Key)
	}
	if v.OwnerHostName != nil {
		enc.AddString("ownerHostName", *v.OwnerHostName)
	}
	return err
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *TaskListPartitionMetadata) GetKey() (o string) {
	if v != nil && v.Key != nil {
		return *v.Key
	}

	return
}

// IsSetKey returns true if Key is not nil.
func (v *TaskListPartitionMetadata) IsSetKey() bool {
	return v != nil && v.Key != nil
}

// GetOwnerHostName returns the value of OwnerHostName if it is set or its
// zero value if it is unset.
func (v *TaskListPartitionMetadata) GetOwnerHostName() (o string) {
	if v != nil && v.OwnerHostName != nil {
		return *v.OwnerHostName
	}

	return
}

// IsSetOwnerHostName returns true if OwnerHostName is not nil.
func (v *TaskListPartitionMetadata) IsSetOwnerHostName() bool {
	return v != nil && v.OwnerHostName != nil
}

type TaskListStatus struct {
	BacklogCountHint *int64       `json:"backlogCountHint,omitempty"`
	ReadLevel        *int64       `json:"readLevel,omitempty"`
	AckLevel         *int64       `json:"ackLevel,omitempty"`
	RatePerSecond    *float64     `json:"ratePerSecond,omitempty"`
	TaskIDBlock      *TaskIDBlock `json:"taskIDBlock,omitempty"`
}

// ToWire translates a TaskListStatus struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *TaskListStatus) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BacklogCountHint != nil {
		w, err = wire.NewValueI64(*(v.BacklogCountHint)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.ReadLevel != nil {
		w, err = wire.NewValueI64(*(v.ReadLevel)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.AckLevel != nil {
		w, err = wire.NewValueI64(*(v.AckLevel)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.RatePerSecond != nil {
		w, err = wire.NewValueDouble(*(v.RatePerSecond)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 35, Value: w}
		i++
	}
	if v.TaskIDBlock != nil {
		w, err = v.TaskIDBlock.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _TaskIDBlock_Read(w wire.Value) (*TaskIDBlock, error) {
	var v TaskIDBlock
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a TaskListStatus struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a TaskListStatus struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v TaskListStatus
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *TaskListStatus) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.BacklogCountHint = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ReadLevel = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.AckLevel = &x
				if err != nil {
					return err
				}

			}
		case 35:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.RatePerSecond = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TStruct {
				v.TaskIDBlock, err = _TaskIDBlock_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a TaskListStatus
// struct.
func (v *TaskListStatus) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	if v.BacklogCountHint != nil {
		fields[i] = fmt.Sprintf("BacklogCountHint: %v", *(v.BacklogCountHint))
		i++
	}
	if v.ReadLevel != nil {
		fields[i] = fmt.Sprintf("ReadLevel: %v", *(v.ReadLevel))
		i++
	}
	if v.AckLevel != nil {
		fields[i] = fmt.Sprintf("AckLevel: %v", *(v.AckLevel))
		i++
	}
	if v.RatePerSecond != nil {
		fields[i] = fmt.Sprintf("RatePerSecond: %v", *(v.RatePerSecond))
		i++
	}
	if v.TaskIDBlock != nil {
		fields[i] = fmt.Sprintf("TaskIDBlock: %v", v.TaskIDBlock)
		i++
	}

	return fmt.Sprintf("TaskListStatus{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this TaskListStatus match the
// provided TaskListStatus.
//
// This function performs a deep comparison.
func (v *TaskListStatus) Equals(rhs *TaskListStatus) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.BacklogCountHint, rhs.BacklogCountHint) {
		return false
	}
	if !_I64_EqualsPtr(v.ReadLevel, rhs.ReadLevel) {
		return false
	}
	if !_I64_EqualsPtr(v.AckLevel, rhs.AckLevel) {
		return false
	}
	if !_Double_EqualsPtr(v.RatePerSecond, rhs.RatePerSecond) {
		return false
	}
	if !((v.TaskIDBlock == nil && rhs.TaskIDBlock == nil) || (v.TaskIDBlock != nil && rhs.TaskIDBlock != nil && v.TaskIDBlock.Equals(rhs.TaskIDBlock))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskListStatus.
func (v *TaskListStatus) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.BacklogCountHint != nil {
		enc.AddInt64("backlogCountHint", *v.BacklogCountHint)
	}
	if v.ReadLevel != nil {
		enc.AddInt64("readLevel", *v.ReadLevel)
	}
	if v.AckLevel != nil {
		enc.AddInt64("ackLevel", *v.AckLevel)
	}
	if v.RatePerSecond != nil {
		enc.AddFloat64("ratePerSecond", *v.RatePerSecond)
	}
	if v.TaskIDBlock != nil {
		err = multierr.Append(err, enc.AddObject("taskIDBlock", v.TaskIDBlock))
	}
	return err
}

// GetBacklogCountHint returns the value of BacklogCountHint if it is set or its
// zero value if it is unset.
func (v *TaskListStatus) GetBacklogCountHint() (o int64) {
	if v != nil && v.BacklogCountHint != nil {
		return *v.BacklogCountHint
	}

	return
}

// IsSetBacklogCountHint returns true if BacklogCountHint is not nil.
func (v *TaskListStatus) IsSetBacklogCountHint() bool {
	return v != nil && v.BacklogCountHint != nil
}

// GetReadLevel returns the value of ReadLevel if it is set or its
// zero value if it is unset.
func (v *TaskListStatus) GetReadLevel() (o int64) {
	if v != nil && v.ReadLevel != nil {
		return *v.ReadLevel
	}

	return
}

// IsSetReadLevel returns true if ReadLevel is not nil.
func (v *TaskListStatus) IsSetReadLevel() bool {
	return v != nil && v.ReadLevel != nil
}

// GetAckLevel returns the value of AckLevel if it is set or its
// zero value if it is unset.
func (v *TaskListStatus) GetAckLevel() (o int64) {
	if v != nil && v.AckLevel != nil {
		return *v.AckLevel
	}

	return
}

// IsSetAckLevel returns true if AckLevel is not nil.
func (v *TaskListStatus) IsSetAckLevel() bool {
	return v != nil && v.AckLevel != nil
}

// GetRatePerSecond returns the value of RatePerSecond if it is set or its
// zero value if it is unset.
func (v *TaskListStatus) GetRatePerSecond() (o float64) {
	if v != nil && v.RatePerSecond != nil {
		return *v.RatePerSecond
	}

	return
}

// IsSetRatePerSecond returns true if RatePerSecond is not nil.
func (v *TaskListStatus) IsSetRatePerSecond() bool {
	return v != nil && v.RatePerSecond != nil
}

// GetTaskIDBlock returns the value of TaskIDBlock if it is set or its
// zero value if it is unset.
func (v *TaskListStatus) GetTaskIDBlock() (o *TaskIDBlock) {
	if v != nil && v.TaskIDBlock != nil {
		return v.TaskIDBlock
	}

	return
}

// IsSetTaskIDBlock returns true if TaskIDBlock is not nil.
func (v *TaskListStatus) IsSetTaskIDBlock() bool {
	return v != nil && v.TaskIDBlock != nil
}

type TaskListType int32

const (
	TaskListTypeDecision TaskListType = 0
	TaskListTypeActivity TaskListType = 1
)

// TaskListType_Values returns all recognized values of TaskListType.
func TaskListType_Values() []TaskListType {
	return []TaskListType{
		TaskListTypeDecision,
		TaskListTypeActivity,
	}
}

// UnmarshalText tries to decode TaskListType from a byte slice
// containing its name.
//
//   var v TaskListType
//   err := v.UnmarshalText([]byte("Decision"))
func (v *TaskListType) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "Decision":
		*v = TaskListTypeDecision
		return nil
	case "Activity":
		*v = TaskListTypeActivity
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "TaskListType", err)
		}
		*v = TaskListType(val)
		return nil
	}
}

// MarshalText encodes TaskListType to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v TaskListType) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("Decision"), nil
	case 1:
		return []byte("Activity"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TaskListType.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v TaskListType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "Decision")
	case 1:
		enc.AddString("name", "Activity")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v TaskListType) Ptr() *TaskListType {
	return &v
}

// ToWire translates TaskListType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v TaskListType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes TaskListType from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return TaskListType(0), err
//   }
//
//   var v TaskListType
//   if err := v.FromWire(x); err != nil {
//     return TaskListType(0), err
//   }
//   return v, nil
func (v *TaskListType) FromWire(w wire.Value) error {
	*v = (TaskListType)(w.GetI32())
	return nil
}

// String returns a readable string representation of TaskListType.
func (v TaskListType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "Decision"
	case 1:
		return "Activity"
	}
	return fmt.Sprintf("TaskListType(%d)", w)
}

// Equals returns true if this TaskListType value matches the provided
// value.
func (v TaskListType) Equals(rhs TaskListType) bool {
	return v == rhs
}

// MarshalJSON serializes TaskListType into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v TaskListType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"Decision\""), nil
	case 1:
		return ([]byte)("\"Activity\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode TaskListType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *TaskListType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "TaskListType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "TaskListType")
		}
		*v = (TaskListType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "TaskListType")
	}
}

type TimeoutType int32

const (
	TimeoutTypeStartToClose    TimeoutType = 0
	TimeoutTypeScheduleToStart TimeoutType = 1
	TimeoutTypeScheduleToClose TimeoutType = 2
	TimeoutTypeHeartbeat       TimeoutType = 3
)

// TimeoutType_Values returns all recognized values of TimeoutType.
func TimeoutType_Values() []TimeoutType {
	return []TimeoutType{
		TimeoutTypeStartToClose,
		TimeoutTypeScheduleToStart,
		TimeoutTypeScheduleToClose,
		TimeoutTypeHeartbeat,
	}
}

// UnmarshalText tries to decode TimeoutType from a byte slice
// containing its name.
//
//   var v TimeoutType
//   err := v.UnmarshalText([]byte("StartToClose"))
func (v *TimeoutType) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "StartToClose":
		*v = TimeoutTypeStartToClose
		return nil
	case "ScheduleToStart":
		*v = TimeoutTypeScheduleToStart
		return nil
	case "ScheduleToClose":
		*v = TimeoutTypeScheduleToClose
		return nil
	case "Heartbeat":
		*v = TimeoutTypeHeartbeat
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "TimeoutType", err)
		}
		*v = TimeoutType(val)
		return nil
	}
}

// MarshalText encodes TimeoutType to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v TimeoutType) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("StartToClose"), nil
	case 1:
		return []byte("ScheduleToStart"), nil
	case 2:
		return []byte("ScheduleToClose"), nil
	case 3:
		return []byte("Heartbeat"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of TimeoutType.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v TimeoutType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "StartToClose")
	case 1:
		enc.AddString("name", "ScheduleToStart")
	case 2:
		enc.AddString("name", "ScheduleToClose")
	case 3:
		enc.AddString("name", "Heartbeat")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v TimeoutType) Ptr() *TimeoutType {
	return &v
}

// ToWire translates TimeoutType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v TimeoutType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes TimeoutType from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return TimeoutType(0), err
//   }
//
//   var v TimeoutType
//   if err := v.FromWire(x); err != nil {
//     return TimeoutType(0), err
//   }
//   return v, nil
func (v *TimeoutType) FromWire(w wire.Value) error {
	*v = (TimeoutType)(w.GetI32())
	return nil
}

// String returns a readable string representation of TimeoutType.
func (v TimeoutType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "StartToClose"
	case 1:
		return "ScheduleToStart"
	case 2:
		return "ScheduleToClose"
	case 3:
		return "Heartbeat"
	}
	return fmt.Sprintf("TimeoutType(%d)", w)
}

// Equals returns true if this TimeoutType value matches the provided
// value.
func (v TimeoutType) Equals(rhs TimeoutType) bool {
	return v == rhs
}

// MarshalJSON serializes TimeoutType into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v TimeoutType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"StartToClose\""), nil
	case 1:
		return ([]byte)("\"ScheduleToStart\""), nil
	case 2:
		return ([]byte)("\"ScheduleToClose\""), nil
	case 3:
		return ([]byte)("\"Heartbeat\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode TimeoutType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *TimeoutType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "TimeoutType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "TimeoutType")
		}
		*v = (TimeoutType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "TimeoutType")
	}
}

type UpdateDomainInfo struct {
	Description *string           `json:"description,omitempty"`
	OwnerEmail  *string           `json:"ownerEmail,omitempty"`
	Data        map[string]string `json:"data,omitempty"`
}

// ToWire translates a UpdateDomainInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *UpdateDomainInfo) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Description != nil {
		w, err = wire.NewValueString(*(v.Description)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.OwnerEmail != nil {
		w, err = wire.NewValueString(*(v.OwnerEmail)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.Data != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Data)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a UpdateDomainInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a UpdateDomainInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v UpdateDomainInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *UpdateDomainInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Description = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.OwnerEmail = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TMap {
				v.Data, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a UpdateDomainInfo
// struct.
func (v *UpdateDomainInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Description != nil {
		fields[i] = fmt.Sprintf("Description: %v", *(v.Description))
		i++
	}
	if v.OwnerEmail != nil {
		fields[i] = fmt.Sprintf("OwnerEmail: %v", *(v.OwnerEmail))
		i++
	}
	if v.Data != nil {
		fields[i] = fmt.Sprintf("Data: %v", v.Data)
		i++
	}

	return fmt.Sprintf("UpdateDomainInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this UpdateDomainInfo match the
// provided UpdateDomainInfo.
//
// This function performs a deep comparison.
func (v *UpdateDomainInfo) Equals(rhs *UpdateDomainInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Description, rhs.Description) {
		return false
	}
	if !_String_EqualsPtr(v.OwnerEmail, rhs.OwnerEmail) {
		return false
	}
	if !((v.Data == nil && rhs.Data == nil) || (v.Data != nil && rhs.Data != nil && _Map_String_String_Equals(v.Data, rhs.Data))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of UpdateDomainInfo.
func (v *UpdateDomainInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Description != nil {
		enc.AddString("description", *v.Description)
	}
	if v.OwnerEmail != nil {
		enc.AddString("ownerEmail", *v.OwnerEmail)
	}
	if v.Data != nil {
		err = multierr.Append(err, enc.AddObject("data", (_Map_String_String_Zapper)(v.Data)))
	}
	return err
}

// GetDescription returns the value of Description if it is set or its
// zero value if it is unset.
func (v *UpdateDomainInfo) GetDescription() (o string) {
	if v != nil && v.Description != nil {
		return *v.Description
	}

	return
}

// IsSetDescription returns true if Description is not nil.
func (v *UpdateDomainInfo) IsSetDescription() bool {
	return v != nil && v.Description != nil
}

// GetOwnerEmail returns the value of OwnerEmail if it is set or its
// zero value if it is unset.
func (v *UpdateDomainInfo) GetOwnerEmail() (o string) {
	if v != nil && v.OwnerEmail != nil {
		return *v.OwnerEmail
	}

	return
}

// IsSetOwnerEmail returns true if OwnerEmail is not nil.
func (v *UpdateDomainInfo) IsSetOwnerEmail() bool {
	return v != nil && v.OwnerEmail != nil
}

// GetData returns the value of Data if it is set or its
// zero value if it is unset.
func (v *UpdateDomainInfo) GetData() (o map[string]string) {
	if v != nil && v.Data != nil {
		return v.Data
	}

	return
}

// IsSetData returns true if Data is not nil.
func (v *UpdateDomainInfo) IsSetData() bool {
	return v != nil && v.Data != nil
}

type VersionHistories struct {
	CurrentVersionHistoryIndex *int32            `json:"currentVersionHistoryIndex,omitempty"`
	Histories                  []*VersionHistory `json:"histories,omitempty"`
}

type _List_VersionHistory_ValueList []*VersionHistory

func (v _List_VersionHistory_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_VersionHistory_ValueList) Size() int {
	return len(v)
}

func (_List_VersionHistory_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_VersionHistory_ValueList) Close() {}

// ToWire translates a VersionHistories struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *VersionHistories) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.CurrentVersionHistoryIndex != nil {
		w, err = wire.NewValueI32(*(v.CurrentVersionHistoryIndex)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Histories != nil {
		w, err = wire.NewValueList(_List_VersionHistory_ValueList(v.Histories)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _VersionHistory_Read(w wire.Value) (*VersionHistory, error) {
	var v VersionHistory
	err := v.FromWire(w)
	return &v, err
}

func _List_VersionHistory_Read(l wire.ValueList) ([]*VersionHistory, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*VersionHistory, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _VersionHistory_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a VersionHistories struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a VersionHistories struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v VersionHistories
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *VersionHistories) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.CurrentVersionHistoryIndex = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TList {
				v.Histories, err = _List_VersionHistory_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a VersionHistories
// struct.
func (v *VersionHistories) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.CurrentVersionHistoryIndex != nil {
		fields[i] = fmt.Sprintf("CurrentVersionHistoryIndex: %v", *(v.CurrentVersionHistoryIndex))
		i++
	}
	if v.Histories != nil {
		fields[i] = fmt.Sprintf("Histories: %v", v.Histories)
		i++
	}

	return fmt.Sprintf("VersionHistories{%v}", strings.Join(fields[:i], ", "))
}

func _List_VersionHistory_Equals(lhs, rhs []*VersionHistory) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this VersionHistories match the
// provided VersionHistories.
//
// This function performs a deep comparison.
func (v *VersionHistories) Equals(rhs *VersionHistories) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.CurrentVersionHistoryIndex, rhs.CurrentVersionHistoryIndex) {
		return false
	}
	if !((v.Histories == nil && rhs.Histories == nil) || (v.Histories != nil && rhs.Histories != nil && _List_VersionHistory_Equals(v.Histories, rhs.Histories))) {
		return false
	}

	return true
}

type _List_VersionHistory_Zapper []*VersionHistory

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_VersionHistory_Zapper.
func (l _List_VersionHistory_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of VersionHistories.
func (v *VersionHistories) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.CurrentVersionHistoryIndex != nil {
		enc.AddInt32("currentVersionHistoryIndex", *v.CurrentVersionHistoryIndex)
	}
	if v.Histories != nil {
		err = multierr.Append(err, enc.AddArray("histories", (_List_VersionHistory_Zapper)(v.Histories)))
	}
	return err
}

// GetCurrentVersionHistoryIndex returns the value of CurrentVersionHistoryIndex if it is set or its
// zero value if it is unset.
func (v *VersionHistories) GetCurrentVersionHistoryIndex() (o int32) {
	if v != nil && v.CurrentVersionHistoryIndex != nil {
		return *v.CurrentVersionHistoryIndex
	}

	return
}

// IsSetCurrentVersionHistoryIndex returns true if CurrentVersionHistoryIndex is not nil.
func (v *VersionHistories) IsSetCurrentVersionHistoryIndex() bool {
	return v != nil && v.CurrentVersionHistoryIndex != nil
}

// GetHistories returns the value of Histories if it is set or its
// zero value if it is unset.
func (v *VersionHistories) GetHistories() (o []*VersionHistory) {
	if v != nil && v.Histories != nil {
		return v.Histories
	}

	return
}

// IsSetHistories returns true if Histories is not nil.
func (v *VersionHistories) IsSetHistories() bool {
	return v != nil && v.Histories != nil
}

type VersionHistory struct {
	BranchToken []byte                `json:"branchToken,omitempty"`
	Items       []*VersionHistoryItem `json:"items,omitempty"`
}

type _List_VersionHistoryItem_ValueList []*VersionHistoryItem

func (v _List_VersionHistoryItem_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_VersionHistoryItem_ValueList) Size() int {
	return len(v)
}

func (_List_VersionHistoryItem_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_VersionHistoryItem_ValueList) Close() {}

// ToWire translates a VersionHistory struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *VersionHistory) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BranchToken != nil {
		w, err = wire.NewValueBinary(v.BranchToken), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Items != nil {
		w, err = wire.NewValueList(_List_VersionHistoryItem_ValueList(v.Items)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _VersionHistoryItem_Read(w wire.Value) (*VersionHistoryItem, error) {
	var v VersionHistoryItem
	err := v.FromWire(w)
	return &v, err
}

func _List_VersionHistoryItem_Read(l wire.ValueList) ([]*VersionHistoryItem, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*VersionHistoryItem, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _VersionHistoryItem_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a VersionHistory struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a VersionHistory struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v VersionHistory
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *VersionHistory) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				v.BranchToken, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TList {
				v.Items, err = _List_VersionHistoryItem_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a VersionHistory
// struct.
func (v *VersionHistory) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.BranchToken != nil {
		fields[i] = fmt.Sprintf("BranchToken: %v", v.BranchToken)
		i++
	}
	if v.Items != nil {
		fields[i] = fmt.Sprintf("Items: %v", v.Items)
		i++
	}

	return fmt.Sprintf("VersionHistory{%v}", strings.Join(fields[:i], ", "))
}

func _List_VersionHistoryItem_Equals(lhs, rhs []*VersionHistoryItem) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this VersionHistory match the
// provided VersionHistory.
//
// This function performs a deep comparison.
func (v *VersionHistory) Equals(rhs *VersionHistory) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.BranchToken == nil && rhs.BranchToken == nil) || (v.BranchToken != nil && rhs.BranchToken != nil && bytes.Equal(v.BranchToken, rhs.BranchToken))) {
		return false
	}
	if !((v.Items == nil && rhs.Items == nil) || (v.Items != nil && rhs.Items != nil && _List_VersionHistoryItem_Equals(v.Items, rhs.Items))) {
		return false
	}

	return true
}

type _List_VersionHistoryItem_Zapper []*VersionHistoryItem

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_VersionHistoryItem_Zapper.
func (l _List_VersionHistoryItem_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of VersionHistory.
func (v *VersionHistory) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.BranchToken != nil {
		enc.AddString("branchToken", base64.StdEncoding.EncodeToString(v.BranchToken))
	}
	if v.Items != nil {
		err = multierr.Append(err, enc.AddArray("items", (_List_VersionHistoryItem_Zapper)(v.Items)))
	}
	return err
}

// GetBranchToken returns the value of BranchToken if it is set or its
// zero value if it is unset.
func (v *VersionHistory) GetBranchToken() (o []byte) {
	if v != nil && v.BranchToken != nil {
		return v.BranchToken
	}

	return
}

// IsSetBranchToken returns true if BranchToken is not nil.
func (v *VersionHistory) IsSetBranchToken() bool {
	return v != nil && v.BranchToken != nil
}

// GetItems returns the value of Items if it is set or its
// zero value if it is unset.
func (v *VersionHistory) GetItems() (o []*VersionHistoryItem) {
	if v != nil && v.Items != nil {
		return v.Items
	}

	return
}

// IsSetItems returns true if Items is not nil.
func (v *VersionHistory) IsSetItems() bool {
	return v != nil && v.Items != nil
}

type VersionHistoryItem struct {
	EventID *int64 `json:"eventID,omitempty"`
	Version *int64 `json:"version,omitempty"`
}

// ToWire translates a VersionHistoryItem struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *VersionHistoryItem) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.EventID != nil {
		w, err = wire.NewValueI64(*(v.EventID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Version != nil {
		w, err = wire.NewValueI64(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a VersionHistoryItem struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a VersionHistoryItem struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v VersionHistoryItem
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *VersionHistoryItem) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.EventID = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a VersionHistoryItem
// struct.
func (v *VersionHistoryItem) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.EventID != nil {
		fields[i] = fmt.Sprintf("EventID: %v", *(v.EventID))
		i++
	}
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}

	return fmt.Sprintf("VersionHistoryItem{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this VersionHistoryItem match the
// provided VersionHistoryItem.
//
// This function performs a deep comparison.
func (v *VersionHistoryItem) Equals(rhs *VersionHistoryItem) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.EventID, rhs.EventID) {
		return false
	}
	if !_I64_EqualsPtr(v.Version, rhs.Version) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of VersionHistoryItem.
func (v *VersionHistoryItem) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.EventID != nil {
		enc.AddInt64("eventID", *v.EventID)
	}
	if v.Version != nil {
		enc.AddInt64("version", *v.Version)
	}
	return err
}

// GetEventID returns the value of EventID if it is set or its
// zero value if it is unset.
func (v *VersionHistoryItem) GetEventID() (o int64) {
	if v != nil && v.EventID != nil {
		return *v.EventID
	}

	return
}

// IsSetEventID returns true if EventID is not nil.
func (v *VersionHistoryItem) IsSetEventID() bool {
	return v != nil && v.EventID != nil
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *VersionHistoryItem) GetVersion() (o int64) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *VersionHistoryItem) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

type WorkerVersionInfo struct {
	Impl           *string `json:"impl,omitempty"`
	FeatureVersion *string `json:"featureVersion,omitempty"`
}

// ToWire translates a WorkerVersionInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *WorkerVersionInfo) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Impl != nil {
		w, err = wire.NewValueString(*(v.Impl)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.FeatureVersion != nil {
		w, err = wire.NewValueString(*(v.FeatureVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a WorkerVersionInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a WorkerVersionInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v WorkerVersionInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *WorkerVersionInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Impl = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.FeatureVersion = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a WorkerVersionInfo
// struct.
func (v *WorkerVersionInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Impl != nil {
		fields[i] = fmt.Sprintf("Impl: %v", *(v.Impl))
		i++
	}
	if v.FeatureVersion != nil {
		fields[i] = fmt.Sprintf("FeatureVersion: %v", *(v.FeatureVersion))
		i++
	}

	return fmt.Sprintf("WorkerVersionInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this WorkerVersionInfo match the
// provided WorkerVersionInfo.
//
// This function performs a deep comparison.
func (v *WorkerVersionInfo) Equals(rhs *WorkerVersionInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Impl, rhs.Impl) {
		return false
	}
	if !_String_EqualsPtr(v.FeatureVersion, rhs.FeatureVersion) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of WorkerVersionInfo.
func (v *WorkerVersionInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Impl != nil {
		enc.AddString("impl", *v.Impl)
	}
	if v.FeatureVersion != nil {
		enc.AddString("featureVersion", *v.FeatureVersion)
	}
	return err
}

// GetImpl returns the value of Impl if it is set or its
// zero value if it is unset.
func (v *WorkerVersionInfo) GetImpl() (o string) {
	if v != nil && v.Impl != nil {
		return *v.Impl
	}

	return
}

// IsSetImpl returns true if Impl is not nil.
func (v *WorkerVersionInfo) IsSetImpl() bool {
	return v != nil && v.Impl != nil
}

// GetFeatureVersion returns the value of FeatureVersion if it is set or its
// zero value if it is unset.
func (v *WorkerVersionInfo) GetFeatureVersion() (o string) {
	if v != nil && v.FeatureVersion != nil {
		return *v.FeatureVersion
	}

	return
}

// IsSetFeatureVersion returns true if FeatureVersion is not nil.
func (v *WorkerVersionInfo) IsSetFeatureVersion() bool {
	return v != nil && v.FeatureVersion != nil
}

type WorkflowExecutionCloseStatus int32

const (
	WorkflowExecutionCloseStatusCompleted      WorkflowExecutionCloseStatus = 0
	WorkflowExecutionCloseStatusFailed         WorkflowExecutionCloseStatus = 1
	WorkflowExecutionCloseStatusCanceled       WorkflowExecutionCloseStatus = 2
	WorkflowExecutionCloseStatusTerminated     WorkflowExecutionCloseStatus = 3
	WorkflowExecutionCloseStatusContinuedAsNew WorkflowExecutionCloseStatus = 4
	WorkflowExecutionCloseStatusTimedOut       WorkflowExecutionCloseStatus = 5
)

// WorkflowExecutionCloseStatus_Values returns all recognized values of WorkflowExecutionCloseStatus.
func WorkflowExecutionCloseStatus_Values() []WorkflowExecutionCloseStatus {
	return []WorkflowExecutionCloseStatus{
		WorkflowExecutionCloseStatusCompleted,
		WorkflowExecutionCloseStatusFailed,
		WorkflowExecutionCloseStatusCanceled,
		WorkflowExecutionCloseStatusTerminated,
		WorkflowExecutionCloseStatusContinuedAsNew,
		WorkflowExecutionCloseStatusTimedOut,
	}
}

// UnmarshalText tries to decode WorkflowExecutionCloseStatus from a byte slice
// containing its name.
//
//   var v WorkflowExecutionCloseStatus
//   err := v.UnmarshalText([]byte("COMPLETED"))
func (v *WorkflowExecutionCloseStatus) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "COMPLETED":
		*v = WorkflowExecutionCloseStatusCompleted
		return nil
	case "FAILED":
		*v = WorkflowExecutionCloseStatusFailed
		return nil
	case "CANCELED":
		*v = WorkflowExecutionCloseStatusCanceled
		return nil
	case "TERMINATED":
		*v = WorkflowExecutionCloseStatusTerminated
		return nil
	case "CONTINUED_AS_NEW":
		*v = WorkflowExecutionCloseStatusContinuedAsNew
		return nil
	case "TIMED_OUT":
		*v = WorkflowExecutionCloseStatusTimedOut
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "WorkflowExecutionCloseStatus", err)
		}
		*v = WorkflowExecutionCloseStatus(val)
		return nil
	}
}

// MarshalText encodes WorkflowExecutionCloseStatus to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v WorkflowExecutionCloseStatus) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("COMPLETED"), nil
	case 1:
		return []byte("FAILED"), nil
	case 2:
		return []byte("CANCELED"), nil
	case 3:
		return []byte("TERMINATED"), nil
	case 4:
		return []byte("CONTINUED_AS_NEW"), nil
	case 5:
		return []byte("TIMED_OUT"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of WorkflowExecutionCloseStatus.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v WorkflowExecutionCloseStatus) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "COMPLETED")
	case 1:
		enc.AddString("name", "FAILED")
	case 2:
		enc.AddString("name", "CANCELED")
	case 3:
		enc.AddString("name", "TERMINATED")
	case 4:
		enc.AddString("name", "CONTINUED_AS_NEW")
	case 5:
		enc.AddString("name", "TIMED_OUT")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v WorkflowExecutionCloseStatus) Ptr() *WorkflowExecutionCloseStatus {
	return &v
}

// ToWire translates WorkflowExecutionCloseStatus into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v WorkflowExecutionCloseStatus) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes WorkflowExecutionCloseStatus from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return WorkflowExecutionCloseStatus(0), err
//   }
//
//   var v WorkflowExecutionCloseStatus
//   if err := v.FromWire(x); err != nil {
//     return WorkflowExecutionCloseStatus(0), err
//   }
//   return v, nil
func (v *WorkflowExecutionCloseStatus) FromWire(w wire.Value) error {
	*v = (WorkflowExecutionCloseStatus)(w.GetI32())
	return nil
}

// String returns a readable string representation of WorkflowExecutionCloseStatus.
func (v WorkflowExecutionCloseStatus) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "COMPLETED"
	case 1:
		return "FAILED"
	case 2:
		return "CANCELED"
	case 3:
		return "TERMINATED"
	case 4:
		return "CONTINUED_AS_NEW"
	case 5:
		return "TIMED_OUT"
	}
	return fmt.Sprintf("WorkflowExecutionCloseStatus(%d)", w)
}

// Equals returns true if this WorkflowExecutionCloseStatus value matches the provided
// value.
func (v WorkflowExecutionCloseStatus) Equals(rhs WorkflowExecutionCloseStatus) bool {
	return v == rhs
}

// MarshalJSON serializes WorkflowExecutionCloseStatus into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v WorkflowExecutionCloseStatus) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"COMPLETED\""), nil
	case 1:
		return ([]byte)("\"FAILED\""), nil
	case 2:
		return ([]byte)("\"CANCELED\""), nil
	case 3:
		return ([]byte)("\"TERMINATED\""), nil
	case 4:
		return ([]byte)("\"CONTINUED_AS_NEW\""), nil
	case 5:
		return ([]byte)("\"TIMED_OUT\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode WorkflowExecutionCloseStatus from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *WorkflowExecutionCloseStatus) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "WorkflowExecutionCloseStatus")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "WorkflowExecutionCloseStatus")
		}
		*v = (WorkflowExecutionCloseStatus)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "WorkflowExecutionCloseStatus")
	}
}

type WorkflowExecutionCompletedEventAttributes struct {
	Result                       []byte `json:"result,omitempty"`
	DecisionTaskCompletedEventId *int64 `json:"decisionTaskCompletedEventId,omitempty"`
}

// ToWire translates a WorkflowExecutionCompletedEventAttributes struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *WorkflowExecutionCompletedEventAttributes) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Result != nil {
		w, err = wire.NewValueBinary(v.Result), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.DecisionTaskCompletedEventId != nil {
		w, err = wire.NewValueI64(*(v.DecisionTaskCompletedEventId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a WorkflowExecutionCompletedEventAttributes struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a WorkflowExecutionCompletedEventAttributes struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v WorkflowExecutionCompletedEventAttributes
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *WorkflowExecutionCompletedEventAttributes) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				v.Result, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.DecisionTaskCompletedEventId = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a WorkflowExecutionCompletedEventAttributes
// struct.
func (v *WorkflowExecutionCompletedEventAttributes) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Result != nil {
		fields[i] = fmt.Sprintf("Result: %v", v.Result)
		i++
	}
	if v.DecisionTaskCompletedEventId != nil {
		fields[i] = fmt.Sprintf("DecisionTaskCompletedEventId: %v", *(v.DecisionTaskCompletedEventId))
		i++
	}

	return fmt.Sprintf("WorkflowExecutionCompletedEventAttributes{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this WorkflowExecutionCompletedEventAttributes match the
// provided WorkflowExecutionCompletedEventAttributes.
//
// This function performs a deep comparison.
func (v *WorkflowExecutionCompletedEventAttributes) Equals(rhs *WorkflowExecutionCompletedEventAttributes) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Result == nil && rhs.Result == nil) || (v.Result != nil && rhs.Result != nil && bytes.Equal(v.Result, rhs.Result))) {
		return false
	}
	if !_I64_EqualsPtr(v.DecisionTaskCompletedEventId, rhs.DecisionTaskCompletedEventId) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of WorkflowExecutionCompletedEventAttributes.
func (v *WorkflowExecutionCompletedEventAttributes) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Result != nil {
		enc.AddString("result", base64.StdEncoding.EncodeToString(v.Result))
	}
	if v.DecisionTaskCompletedEventId != nil {
		enc.AddInt64("decisionTaskCompletedEventId", *v.DecisionTaskCompletedEventId)
	}
	return err
}

// GetResult returns the value of Result if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionCompletedEventAttributes) GetResult() (o []byte) {
	if v != nil && v.Result != nil {
		return v.Result
	}

	return
}

// IsSetResult returns true if Result is not nil.
func (v *WorkflowExecutionCompletedEventAttributes) IsSetResult() bool {
	return v != nil && v.Result != nil
}

// GetDecisionTaskCompletedEventId returns the value of DecisionTaskCompletedEventId if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionCompletedEventAttributes) GetDecisionTaskCompletedEventId() (o int64) {
	if v != nil && v.DecisionTaskCompletedEventId != nil {
		return *v.DecisionTaskCompletedEventId
	}

	return
}

// IsSetDecisionTaskCompletedEventId returns true if DecisionTaskCompletedEventId is not nil.
func (v *WorkflowExecutionCompletedEventAttributes) IsSetDecisionTaskCompletedEventId() bool {
	return v != nil && v.DecisionTaskCompletedEventId != nil
}

type WorkflowExecutionConfiguration struct {
	TaskList                            *TaskList `json:"taskList,omitempty"`
	ExecutionStartToCloseTimeoutSeconds *int32    `json:"executionStartToCloseTimeoutSeconds,omitempty"`
	TaskStartToCloseTimeoutSeconds      *int32    `json:"taskStartToCloseTimeoutSeconds,omitempty"`
}

// ToWire translates a WorkflowExecutionConfiguration struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *WorkflowExecutionConfiguration) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TaskList != nil {
		w, err = v.TaskList.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.ExecutionStartToCloseTimeoutSeconds != nil {
		w, err = wire.NewValueI32(*(v.ExecutionStartToCloseTimeoutSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.TaskStartToCloseTimeoutSeconds != nil {
		w, err = wire.NewValueI32(*(v.TaskStartToCloseTimeoutSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a WorkflowExecutionConfiguration struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a WorkflowExecutionConfiguration struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v WorkflowExecutionConfiguration
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *WorkflowExecutionConfiguration) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TStruct {
				v.TaskList, err = _TaskList_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ExecutionStartToCloseTimeoutSeconds = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.TaskStartToCloseTimeoutSeconds = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a WorkflowExecutionConfiguration
// struct.
func (v *WorkflowExecutionConfiguration) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.TaskList != nil {
		fields[i] = fmt.Sprintf("TaskList: %v", v.TaskList)
		i++
	}
	if v.ExecutionStartToCloseTimeoutSeconds != nil {
		fields[i] = fmt.Sprintf("ExecutionStartToCloseTimeoutSeconds: %v", *(v.ExecutionStartToCloseTimeoutSeconds))
		i++
	}
	if v.TaskStartToCloseTimeoutSeconds != nil {
		fields[i] = fmt.Sprintf("TaskStartToCloseTimeoutSeconds: %v", *(v.TaskStartToCloseTimeoutSeconds))
		i++
	}

	return fmt.Sprintf("WorkflowExecutionConfiguration{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this WorkflowExecutionConfiguration match the
// provided WorkflowExecutionConfiguration.
//
// This function performs a deep comparison.
func (v *WorkflowExecutionConfiguration) Equals(rhs *WorkflowExecutionConfiguration) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.TaskList == nil && rhs.TaskList == nil) || (v.TaskList != nil && rhs.TaskList != nil && v.TaskList.Equals(rhs.TaskList))) {
		return false
	}
	if !_I32_EqualsPtr(v.ExecutionStartToCloseTimeoutSeconds, rhs.ExecutionStartToCloseTimeoutSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.TaskStartToCloseTimeoutSeconds, rhs.TaskStartToCloseTimeoutSeconds) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of WorkflowExecutionConfiguration.
func (v *WorkflowExecutionConfiguration) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.TaskList != nil {
		err = multierr.Append(err, enc.AddObject("taskList", v.TaskList))
	}
	if v.ExecutionStartToCloseTimeoutSeconds != nil {
		enc.AddInt32("executionStartToCloseTimeoutSeconds", *v.ExecutionStartToCloseTimeoutSeconds)
	}
	if v.TaskStartToCloseTimeoutSeconds != nil {
		enc.AddInt32("taskStartToCloseTimeoutSeconds", *v.TaskStartToCloseTimeoutSeconds)
	}
	return err
}

// GetTaskList returns the value of TaskList if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionConfiguration) GetTaskList() (o *TaskList) {
	if v != nil && v.TaskList != nil {
		return v.TaskList
	}

	return
}

// IsSetTaskList returns true if TaskList is not nil.
func (v *WorkflowExecutionConfiguration) IsSetTaskList() bool {
	return v != nil && v.TaskList != nil
}

// GetExecutionStartToCloseTimeoutSeconds returns the value of ExecutionStartToCloseTimeoutSeconds if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionConfiguration) GetExecutionStartToCloseTimeoutSeconds() (o int32) {
	if v != nil && v.ExecutionStartToCloseTimeoutSeconds != nil {
		return *v.ExecutionStartToCloseTimeoutSeconds
	}

	return
}

// IsSetExecutionStartToCloseTimeoutSeconds returns true if ExecutionStartToCloseTimeoutSeconds is not nil.
func (v *WorkflowExecutionConfiguration) IsSetExecutionStartToCloseTimeoutSeconds() bool {
	return v != nil && v.ExecutionStartToCloseTimeoutSeconds != nil
}

// GetTaskStartToCloseTimeoutSeconds returns the value of TaskStartToCloseTimeoutSeconds if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionConfiguration) GetTaskStartToCloseTimeoutSeconds() (o int32) {
	if v != nil && v.TaskStartToCloseTimeoutSeconds != nil {
		return *v.TaskStartToCloseTimeoutSeconds
	}

	return
}

// IsSetTaskStartToCloseTimeoutSeconds returns true if TaskStartToCloseTimeoutSeconds is not nil.
func (v *WorkflowExecutionConfiguration) IsSetTaskStartToCloseTimeoutSeconds() bool {
	return v != nil && v.TaskStartToCloseTimeoutSeconds != nil
}

type WorkflowExecutionFailedEventAttributes struct {
	Reason                       *string `json:"reason,omitempty"`
	Details                      []byte  `json:"details,omitempty"`
	DecisionTaskCompletedEventId *int64  `json:"decisionTaskCompletedEventId,omitempty"`
}

// ToWire translates a WorkflowExecutionFailedEventAttributes struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *WorkflowExecutionFailedEventAttributes) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Reason != nil {
		w, err = wire.NewValueString(*(v.Reason)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Details != nil {
		w, err = wire.NewValueBinary(v.Details), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.DecisionTaskCompletedEventId != nil {
		w, err = wire.NewValueI64(*(v.DecisionTaskCompletedEventId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a WorkflowExecutionFailedEventAttributes struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a WorkflowExecutionFailedEventAttributes struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v WorkflowExecutionFailedEventAttributes
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *WorkflowExecutionFailedEventAttributes) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Reason = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				v.Details, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.DecisionTaskCompletedEventId = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a WorkflowExecutionFailedEventAttributes
// struct.
func (v *WorkflowExecutionFailedEventAttributes) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Reason != nil {
		fields[i] = fmt.Sprintf("Reason: %v", *(v.Reason))
		i++
	}
	if v.Details != nil {
		fields[i] = fmt.Sprintf("Details: %v", v.Details)
		i++
	}
	if v.DecisionTaskCompletedEventId != nil {
		fields[i] = fmt.Sprintf("DecisionTaskCompletedEventId: %v", *(v.DecisionTaskCompletedEventId))
		i++
	}

	return fmt.Sprintf("WorkflowExecutionFailedEventAttributes{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this WorkflowExecutionFailedEventAttributes match the
// provided WorkflowExecutionFailedEventAttributes.
//
// This function performs a deep comparison.
func (v *WorkflowExecutionFailedEventAttributes) Equals(rhs *WorkflowExecutionFailedEventAttributes) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Reason, rhs.Reason) {
		return false
	}
	if !((v.Details == nil && rhs.Details == nil) || (v.Details != nil && rhs.Details != nil && bytes.Equal(v.Details, rhs.Details))) {
		return false
	}
	if !_I64_EqualsPtr(v.DecisionTaskCompletedEventId, rhs.DecisionTaskCompletedEventId) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of WorkflowExecutionFailedEventAttributes.
func (v *WorkflowExecutionFailedEventAttributes) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Reason != nil {
		enc.AddString("reason", *v.Reason)
	}
	if v.Details != nil {
		enc.AddString("details", base64.StdEncoding.EncodeToString(v.Details))
	}
	if v.DecisionTaskCompletedEventId != nil {
		enc.AddInt64("decisionTaskCompletedEventId", *v.DecisionTaskCompletedEventId)
	}
	return err
}

// GetReason returns the value of Reason if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionFailedEventAttributes) GetReason() (o string) {
	if v != nil && v.Reason != nil {
		return *v.Reason
	}

	return
}

// IsSetReason returns true if Reason is not nil.
func (v *WorkflowExecutionFailedEventAttributes) IsSetReason() bool {
	return v != nil && v.Reason != nil
}

// GetDetails returns the value of Details if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionFailedEventAttributes) GetDetails() (o []byte) {
	if v != nil && v.Details != nil {
		return v.Details
	}

	return
}

// IsSetDetails returns true if Details is not nil.
func (v *WorkflowExecutionFailedEventAttributes) IsSetDetails() bool {
	return v != nil && v.Details != nil
}

// GetDecisionTaskCompletedEventId returns the value of DecisionTaskCompletedEventId if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionFailedEventAttributes) GetDecisionTaskCompletedEventId() (o int64) {
	if v != nil && v.DecisionTaskCompletedEventId != nil {
		return *v.DecisionTaskCompletedEventId
	}

	return
}

// IsSetDecisionTaskCompletedEventId returns true if DecisionTaskCompletedEventId is not nil.
func (v *WorkflowExecutionFailedEventAttributes) IsSetDecisionTaskCompletedEventId() bool {
	return v != nil && v.DecisionTaskCompletedEventId != nil
}

type WorkflowExecutionFilter struct {
	WorkflowId *string `json:"workflowId,omitempty"`
	RunId      *string `json:"runId,omitempty"`
}

// ToWire translates a WorkflowExecutionFilter struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *WorkflowExecutionFilter) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.WorkflowId != nil {
		w, err = wire.NewValueString(*(v.WorkflowId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.RunId != nil {
		w, err = wire.NewValueString(*(v.RunId)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a WorkflowExecutionFilter struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a WorkflowExecutionFilter struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v WorkflowExecutionFilter
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *WorkflowExecutionFilter) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.WorkflowId = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RunId = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a WorkflowExecutionFilter
// struct.
func (v *WorkflowExecutionFilter) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.WorkflowId != nil {
		fields[i] = fmt.Sprintf("WorkflowId: %v", *(v.WorkflowId))
		i++
	}
	if v.RunId != nil {
		fields[i] = fmt.Sprintf("RunId: %v", *(v.RunId))
		i++
	}

	return fmt.Sprintf("WorkflowExecutionFilter{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this WorkflowExecutionFilter match the
// provided WorkflowExecutionFilter.
//
// This function performs a deep comparison.
func (v *WorkflowExecutionFilter) Equals(rhs *WorkflowExecutionFilter) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.WorkflowId, rhs.WorkflowId) {
		return false
	}
	if !_String_EqualsPtr(v.RunId, rhs.RunId) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of WorkflowExecutionFilter.
func (v *WorkflowExecutionFilter) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.WorkflowId != nil {
		enc.AddString("workflowId", *v.WorkflowId)
	}
	if v.RunId != nil {
		enc.AddString("runId", *v.RunId)
	}
	return err
}

// GetWorkflowId returns the value of WorkflowId if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionFilter) GetWorkflowId() (o string) {
	if v != nil && v.WorkflowId != nil {
		return *v.WorkflowId
	}

	return
}

// IsSetWorkflowId returns true if WorkflowId is not nil.
func (v *WorkflowExecutionFilter) IsSetWorkflowId() bool {
	return v != nil && v.WorkflowId != nil
}

// GetRunId returns the value of RunId if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionFilter) GetRunId() (o string) {
	if v != nil && v.RunId != nil {
		return *v.RunId
	}

	return
}

// IsSetRunId returns true if RunId is not nil.
func (v *WorkflowExecutionFilter) IsSetRunId() bool {
	return v != nil && v.RunId != nil
}

type WorkflowExecutionTimedOutEventAttributes struct {
	TimeoutType *TimeoutType `json:"timeoutType,omitempty"`
}

// ToWire translates a WorkflowExecutionTimedOutEventAttributes struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *WorkflowExecutionTimedOutEventAttributes) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.TimeoutType != nil {
		w, err = v.TimeoutType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _TimeoutType_Read(w wire.Value) (TimeoutType, error) {
	var v TimeoutType
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a WorkflowExecutionTimedOutEventAttributes struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a WorkflowExecutionTimedOutEventAttributes struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v WorkflowExecutionTimedOutEventAttributes
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *WorkflowExecutionTimedOutEventAttributes) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI32 {
				var x TimeoutType
				x, err = _TimeoutType_Read(field.Value)
				v.TimeoutType = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a WorkflowExecutionTimedOutEventAttributes
// struct.
func (v *WorkflowExecutionTimedOutEventAttributes) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.TimeoutType != nil {
		fields[i] = fmt.Sprintf("TimeoutType: %v", *(v.TimeoutType))
		i++
	}

	return fmt.Sprintf("WorkflowExecutionTimedOutEventAttributes{%v}", strings.Join(fields[:i], ", "))
}

func _TimeoutType_EqualsPtr(lhs, rhs *TimeoutType) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this WorkflowExecutionTimedOutEventAttributes match the
// provided WorkflowExecutionTimedOutEventAttributes.
//
// This function performs a deep comparison.
func (v *WorkflowExecutionTimedOutEventAttributes) Equals(rhs *WorkflowExecutionTimedOutEventAttributes) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_TimeoutType_EqualsPtr(v.TimeoutType, rhs.TimeoutType) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of WorkflowExecutionTimedOutEventAttributes.
func (v *WorkflowExecutionTimedOutEventAttributes) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.TimeoutType != nil {
		err = multierr.Append(err, enc.AddObject("timeoutType", *v.TimeoutType))
	}
	return err
}

// GetTimeoutType returns the value of TimeoutType if it is set or its
// zero value if it is unset.
func (v *WorkflowExecutionTimedOutEventAttributes) GetTimeoutType() (o TimeoutType) {
	if v != nil && v.TimeoutType != nil {
		return *v.TimeoutType
	}

	return
}

// IsSetTimeoutType returns true if TimeoutType is not nil.
func (v *WorkflowExecutionTimedOutEventAttributes) IsSetTimeoutType() bool {
	return v != nil && v.TimeoutType != nil
}

type WorkflowIdReusePolicy int32

const (
	WorkflowIdReusePolicyAllowDuplicateFailedOnly WorkflowIdReusePolicy = 0
	WorkflowIdReusePolicyAllowDuplicate           WorkflowIdReusePolicy = 1
	WorkflowIdReusePolicyRejectDuplicate          WorkflowIdReusePolicy = 2
)

// WorkflowIdReusePolicy_Values returns all recognized values of WorkflowIdReusePolicy.
func WorkflowIdReusePolicy_Values() []WorkflowIdReusePolicy {
	return []WorkflowIdReusePolicy{
		WorkflowIdReusePolicyAllowDuplicateFailedOnly,
		WorkflowIdReusePolicyAllowDuplicate,
		WorkflowIdReusePolicyRejectDuplicate,
	}
}

// UnmarshalText tries to decode WorkflowIdReusePolicy from a byte slice
// containing its name.
//
//   var v WorkflowIdReusePolicy
//   err := v.UnmarshalText([]byte("AllowDuplicateFailedOnly"))
func (v *WorkflowIdReusePolicy) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "AllowDuplicateFailedOnly":
		*v = WorkflowIdReusePolicyAllowDuplicateFailedOnly
		return nil
	case "AllowDuplicate":
		*v = WorkflowIdReusePolicyAllowDuplicate
		return nil
	case "RejectDuplicate":
		*v = WorkflowIdReusePolicyRejectDuplicate
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "WorkflowIdReusePolicy", err)
		}
		*v = WorkflowIdReusePolicy(val)
		return nil
	}
}

// MarshalText encodes WorkflowIdReusePolicy to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v WorkflowIdReusePolicy) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("AllowDuplicateFailedOnly"), nil
	case 1:
		return []byte("AllowDuplicate"), nil
	case 2:
		return []byte("RejectDuplicate"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of WorkflowIdReusePolicy.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v WorkflowIdReusePolicy) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "AllowDuplicateFailedOnly")
	case 1:
		enc.AddString("name", "AllowDuplicate")
	case 2:
		enc.AddString("name", "RejectDuplicate")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v WorkflowIdReusePolicy) Ptr() *WorkflowIdReusePolicy {
	return &v
}

// ToWire translates WorkflowIdReusePolicy into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v WorkflowIdReusePolicy) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes WorkflowIdReusePolicy from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return WorkflowIdReusePolicy(0), err
//   }
//
//   var v WorkflowIdReusePolicy
//   if err := v.FromWire(x); err != nil {
//     return WorkflowIdReusePolicy(0), err
//   }
//   return v, nil
func (v *WorkflowIdReusePolicy) FromWire(w wire.Value) error {
	*v = (WorkflowIdReusePolicy)(w.GetI32())
	return nil
}

// String returns a readable string representation of WorkflowIdReusePolicy.
func (v WorkflowIdReusePolicy) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "AllowDuplicateFailedOnly"
	case 1:
		return "AllowDuplicate"
	case 2:
		return "RejectDuplicate"
	}
	return fmt.Sprintf("WorkflowIdReusePolicy(%d)", w)
}

// Equals returns true if this WorkflowIdReusePolicy value matches the provided
// value.
func (v WorkflowIdReusePolicy) Equals(rhs WorkflowIdReusePolicy) bool {
	return v == rhs
}

// MarshalJSON serializes WorkflowIdReusePolicy into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v WorkflowIdReusePolicy) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"AllowDuplicateFailedOnly\""), nil
	case 1:
		return ([]byte)("\"AllowDuplicate\""), nil
	case 2:
		return ([]byte)("\"RejectDuplicate\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode WorkflowIdReusePolicy from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *WorkflowIdReusePolicy) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "WorkflowIdReusePolicy")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "WorkflowIdReusePolicy")
		}
		*v = (WorkflowIdReusePolicy)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "WorkflowIdReusePolicy")
	}
}

type WorkflowQuery struct {
	QueryType *string `json:"queryType,omitempty"`
	QueryArgs []byte  `json:"queryArgs,omitempty"`
}

// ToWire translates a WorkflowQuery struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *WorkflowQuery) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.QueryType != nil {
		w, err = wire.NewValueString(*(v.QueryType)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.QueryArgs != nil {
		w, err = wire.NewValueBinary(v.QueryArgs), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a WorkflowQuery struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a WorkflowQuery struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v WorkflowQuery
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *WorkflowQuery) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.QueryType = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				v.QueryArgs, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a WorkflowQuery
// struct.
func (v *WorkflowQuery) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.QueryType != nil {
		fields[i] = fmt.Sprintf("QueryType: %v", *(v.QueryType))
		i++
	}
	if v.QueryArgs != nil {
		fields[i] = fmt.Sprintf("QueryArgs: %v", v.QueryArgs)
		i++
	}

	return fmt.Sprintf("WorkflowQuery{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this WorkflowQuery match the
// provided WorkflowQuery.
//
// This function performs a deep comparison.
func (v *WorkflowQuery) Equals(rhs *WorkflowQuery) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.QueryType, rhs.QueryType) {
		return false
	}
	if !((v.QueryArgs == nil && rhs.QueryArgs == nil) || (v.QueryArgs != nil && rhs.QueryArgs != nil && bytes.Equal(v.QueryArgs, rhs.QueryArgs))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of WorkflowQuery.
func (v *WorkflowQuery) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.QueryType != nil {
		enc.AddString("queryType", *v.QueryType)
	}
	if v.QueryArgs != nil {
		enc.AddString("queryArgs", base64.StdEncoding.EncodeToString(v.QueryArgs))
	}
	return err
}

// GetQueryType returns the value of QueryType if it is set or its
// zero value if it is unset.
func (v *WorkflowQuery) GetQueryType() (o string) {
	if v != nil && v.QueryType != nil {
		return *v.QueryType
	}

	return
}

// IsSetQueryType returns true if QueryType is not nil.
func (v *WorkflowQuery) IsSetQueryType() bool {
	return v != nil && v.QueryType != nil
}

// GetQueryArgs returns the value of QueryArgs if it is set or its
// zero value if it is unset.
func (v *WorkflowQuery) GetQueryArgs() (o []byte) {
	if v != nil && v.QueryArgs != nil {
		return v.QueryArgs
	}

	return
}

// IsSetQueryArgs returns true if QueryArgs is not nil.
func (v *WorkflowQuery) IsSetQueryArgs() bool {
	return v != nil && v.QueryArgs != nil
}

type WorkflowQueryResult struct {
	ResultType   *QueryResultType `json:"resultType,omitempty"`
	Answer       []byte           `json:"answer,omitempty"`
	ErrorMessage *string          `json:"errorMessage,omitempty"`
}

// ToWire translates a WorkflowQueryResult struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *WorkflowQueryResult) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ResultType != nil {
		w, err = v.ResultType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Answer != nil {
		w, err = wire.NewValueBinary(v.Answer), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.ErrorMessage != nil {
		w, err = wire.NewValueString(*(v.ErrorMessage)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _QueryResultType_Read(w wire.Value) (QueryResultType, error) {
	var v QueryResultType
	err := v.FromWire(w)
	return v, err
}

// FromWire deserializes a WorkflowQueryResult struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a WorkflowQueryResult struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v WorkflowQueryResult
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *WorkflowQueryResult) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI32 {
				var x QueryResultType
				x, err = _QueryResultType_Read(field.Value)
				v.ResultType = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				v.Answer, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ErrorMessage = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a WorkflowQueryResult
// struct.
func (v *WorkflowQueryResult) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.ResultType != nil {
		fields[i] = fmt.Sprintf("ResultType: %v", *(v.ResultType))
		i++
	}
	if v.Answer != nil {
		fields[i] = fmt.Sprintf("Answer: %v", v.Answer)
		i++
	}
	if v.ErrorMessage != nil {
		fields[i] = fmt.Sprintf("ErrorMessage: %v", *(v.ErrorMessage))
		i++
	}

	return fmt.Sprintf("WorkflowQueryResult{%v}", strings.Join(fields[:i], ", "))
}

func _QueryResultType_EqualsPtr(lhs, rhs *QueryResultType) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this WorkflowQueryResult match the
// provided WorkflowQueryResult.
//
// This function performs a deep comparison.
func (v *WorkflowQueryResult) Equals(rhs *WorkflowQueryResult) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_QueryResultType_EqualsPtr(v.ResultType, rhs.ResultType) {
		return false
	}
	if !((v.Answer == nil && rhs.Answer == nil) || (v.Answer != nil && rhs.Answer != nil && bytes.Equal(v.Answer, rhs.Answer))) {
		return false
	}
	if !_String_EqualsPtr(v.ErrorMessage, rhs.ErrorMessage) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of WorkflowQueryResult.
func (v *WorkflowQueryResult) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ResultType != nil {
		err = multierr.Append(err, enc.AddObject("resultType", *v.ResultType))
	}
	if v.Answer != nil {
		enc.AddString("answer", base64.StdEncoding.EncodeToString(v.Answer))
	}
	if v.ErrorMessage != nil {
		enc.AddString("errorMessage", *v.ErrorMessage)
	}
	return err
}

// GetResultType returns the value of ResultType if it is set or its
// zero value if it is unset.
func (v *WorkflowQueryResult) GetResultType() (o QueryResultType) {
	if v != nil && v.ResultType != nil {
		return *v.ResultType
	}

	return
}

// IsSetResultType returns true if ResultType is not nil.
func (v *WorkflowQueryResult) IsSetResultType() bool {
	return v != nil && v.ResultType != nil
}

// GetAnswer returns the value of Answer if it is set or its
// zero value if it is unset.
func (v *WorkflowQueryResult) GetAnswer() (o []byte) {
	if v != nil && v.Answer != nil {
		return v.Answer
	}

	return
}

// IsSetAnswer returns true if Answer is not nil.
func (v *WorkflowQueryResult) IsSetAnswer() bool {
	return v != nil && v.Answer != nil
}

// GetErrorMessage returns the value of ErrorMessage if it is set or its
// zero value if it is unset.
func (v *WorkflowQueryResult) GetErrorMessage() (o string) {
	if v != nil && v.ErrorMessage != nil {
		return *v.ErrorMessage
	}

	return
}

// IsSetErrorMessage returns true if ErrorMessage is not nil.
func (v *WorkflowQueryResult) IsSetErrorMessage() bool {
	return v != nil && v.ErrorMessage != nil
}

type WorkflowType struct {
	Name *string `json:"name,omitempty"`
}

// ToWire translates a WorkflowType struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *WorkflowType) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a WorkflowType struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a WorkflowType struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v WorkflowType
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *WorkflowType) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a WorkflowType
// struct.
func (v *WorkflowType) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}

	return fmt.Sprintf("WorkflowType{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this WorkflowType match the
// provided WorkflowType.
//
// This function performs a deep comparison.
func (v *WorkflowType) Equals(rhs *WorkflowType) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of WorkflowType.
func (v *WorkflowType) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *WorkflowType) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *WorkflowType) IsSetName() bool {
	return v != nil && v.Name != nil
}

type WorkflowTypeFilter struct {
	Name *string `json:"name,omitempty"`
}

// ToWire translates a WorkflowTypeFilter struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *WorkflowTypeFilter) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a WorkflowTypeFilter struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a WorkflowTypeFilter struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v WorkflowTypeFilter
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *WorkflowTypeFilter) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a WorkflowTypeFilter
// struct.
func (v *WorkflowTypeFilter) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}

	return fmt.Sprintf("WorkflowTypeFilter{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this WorkflowTypeFilter match the
// provided WorkflowTypeFilter.
//
// This function performs a deep comparison.
func (v *WorkflowTypeFilter) Equals(rhs *WorkflowTypeFilter) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of WorkflowTypeFilter.
func (v *WorkflowTypeFilter) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *WorkflowTypeFilter) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *WorkflowTypeFilter) IsSetName() bool {
	return v != nil && v.Name != nil
}

// ThriftModule represents the IDL file used to generate this package.
var ThriftModule = &thriftreflect.ThriftModule{
	Name:     "shared",
	Package:  "github.com/temporalio/temporal/.gen/go/shared",
	FilePath: "shared.thrift",
	SHA1:     "33193dc9d941fa84aed9ad457237a819e6e8bdcd",
	Raw:      rawIDL,
}

const rawIDL = "// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nnamespace java com.temporalio.temporal\n\nenum WorkflowIdReusePolicy {\n  /*\n   * allow start a workflow execution using the same workflow ID,\n   * when workflow not running, and the last execution close state is in\n   * [terminated, cancelled, timeouted, failed].\n   */\n  AllowDuplicateFailedOnly,\n  /*\n   * allow start a workflow execution using the same workflow ID,\n   * when workflow not running.\n   */\n  AllowDuplicate,\n  /*\n   * do not allow start a workflow execution using the same workflow ID at all\n   */\n  RejectDuplicate,\n}\n\nenum DomainStatus {\n  REGISTERED,\n  DEPRECATED,\n  DELETED,\n}\n\nenum TimeoutType {\n    StartToClose,\n    ScheduleToStart,\n    ScheduleToClose,\n    Heartbeat,\n}\n\nenum ParentClosePolicy {\n\tABANDON,\n\tREQUEST_CANCEL,\n\tTERMINATE,\n}\n\n\n// whenever this list of decision is changed\n// do change the mutableStateBuilder.go\n// function shouldBufferEvent\n// to make sure wo do the correct event ordering\nenum DecisionType {\n  ScheduleActivityTask,\n  RequestCancelActivityTask,\n  StartTimer,\n  CompleteWorkflowExecution,\n  FailWorkflowExecution,\n  CancelTimer,\n  CancelWorkflowExecution,\n  RequestCancelExternalWorkflowExecution,\n  RecordMarker,\n  ContinueAsNewWorkflowExecution,\n  StartChildWorkflowExecution,\n  SignalExternalWorkflowExecution,\n  UpsertWorkflowSearchAttributes,\n}\n\nenum EventType {\n  WorkflowExecutionStarted,\n  WorkflowExecutionCompleted,\n  WorkflowExecutionFailed,\n  WorkflowExecutionTimedOut,\n  DecisionTaskScheduled,\n  DecisionTaskStarted,\n  DecisionTaskCompleted,\n  DecisionTaskTimedOut\n  DecisionTaskFailed,\n  ActivityTaskScheduled,\n  ActivityTaskStarted,\n  ActivityTaskCompleted,\n  ActivityTaskFailed,\n  ActivityTaskTimedOut,\n  ActivityTaskCancelRequested,\n  RequestCancelActivityTaskFailed,\n  ActivityTaskCanceled,\n  TimerStarted,\n  TimerFired,\n  CancelTimerFailed,\n  TimerCanceled,\n  WorkflowExecutionCancelRequested,\n  WorkflowExecutionCanceled,\n  RequestCancelExternalWorkflowExecutionInitiated,\n  RequestCancelExternalWorkflowExecutionFailed,\n  ExternalWorkflowExecutionCancelRequested,\n  MarkerRecorded,\n  WorkflowExecutionSignaled,\n  WorkflowExecutionTerminated,\n  WorkflowExecutionContinuedAsNew,\n  StartChildWorkflowExecutionInitiated,\n  StartChildWorkflowExecutionFailed,\n  ChildWorkflowExecutionStarted,\n  ChildWorkflowExecutionCompleted,\n  ChildWorkflowExecutionFailed,\n  ChildWorkflowExecutionCanceled,\n  ChildWorkflowExecutionTimedOut,\n  ChildWorkflowExecutionTerminated,\n  SignalExternalWorkflowExecutionInitiated,\n  SignalExternalWorkflowExecutionFailed,\n  ExternalWorkflowExecutionSignaled,\n  UpsertWorkflowSearchAttributes,\n}\n\nenum DecisionTaskFailedCause {\n  UNHANDLED_DECISION,\n  BAD_SCHEDULE_ACTIVITY_ATTRIBUTES,\n  BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES,\n  BAD_START_TIMER_ATTRIBUTES,\n  BAD_CANCEL_TIMER_ATTRIBUTES,\n  BAD_RECORD_MARKER_ATTRIBUTES,\n  BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES,\n  BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES,\n  BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES,\n  BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES,\n  BAD_CONTINUE_AS_NEW_ATTRIBUTES,\n  START_TIMER_DUPLICATE_ID,\n  RESET_STICKY_TASKLIST,\n  WORKFLOW_WORKER_UNHANDLED_FAILURE,\n  BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES,\n  BAD_START_CHILD_EXECUTION_ATTRIBUTES,\n  FORCE_CLOSE_DECISION,\n  FAILOVER_CLOSE_DECISION,\n  BAD_SIGNAL_INPUT_SIZE,\n  RESET_WORKFLOW,\n  BAD_BINARY,\n  SCHEDULE_ACTIVITY_DUPLICATE_ID,\n  BAD_SEARCH_ATTRIBUTES,\n}\n\nenum CancelExternalWorkflowExecutionFailedCause {\n  UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION,\n}\n\nenum SignalExternalWorkflowExecutionFailedCause {\n  UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION,\n}\n\nenum ChildWorkflowExecutionFailedCause {\n  WORKFLOW_ALREADY_RUNNING,\n}\n\n// TODO: when migrating to gRPC, add a running / none status,\n//  currently, customer is using null / nil as an indication\n//  that workflow is still running\nenum WorkflowExecutionCloseStatus {\n  COMPLETED,\n  FAILED,\n  CANCELED,\n  TERMINATED,\n  CONTINUED_AS_NEW,\n  TIMED_OUT,\n}\n\nenum QueryTaskCompletedType {\n  COMPLETED,\n  FAILED,\n}\n\nenum QueryResultType {\n  ANSWERED,\n  FAILED,\n}\n\nenum PendingActivityState {\n  SCHEDULED,\n  STARTED,\n  CANCEL_REQUESTED,\n}\n\nenum HistoryEventFilterType {\n  ALL_EVENT,\n  CLOSE_EVENT,\n}\n\nenum TaskListKind {\n  NORMAL,\n  STICKY,\n}\n\nenum ArchivalStatus {\n  DISABLED,\n  ENABLED,\n}\n\nenum IndexedValueType {\n  STRING,\n  KEYWORD,\n  INT,\n  DOUBLE,\n  BOOL,\n  DATETIME,\n}\n\nstruct Header {\n    10: optional map<string, binary> fields\n}\n\nstruct WorkflowType {\n  10: optional string name\n}\n\nstruct ActivityType {\n  10: optional string name\n}\n\nstruct TaskList {\n  10: optional string name\n  20: optional TaskListKind kind\n}\n\nenum EncodingType {\n  ThriftRW,\n  JSON,\n}\n\nenum QueryRejectCondition {\n  // NOT_OPEN indicates that query should be rejected if workflow is not open\n  NOT_OPEN\n  // NOT_COMPLETED_CLEANLY indicates that query should be rejected if workflow did not complete cleanly\n  NOT_COMPLETED_CLEANLY\n}\n\nenum QueryConsistencyLevel {\n  // EVENTUAL indicates that query should be eventually consistent\n  EVENTUAL\n  // STRONG indicates that any events that came before query should be reflected in workflow state before running query\n  STRONG\n}\n\nstruct DataBlob {\n  10: optional EncodingType EncodingType\n  20: optional binary Data\n}\n\nstruct ReplicationInfo {\n  10: optional i64 (js.type = \"Long\") version\n  20: optional i64 (js.type = \"Long\") lastEventId\n}\n\nstruct TaskListMetadata {\n  10: optional double maxTasksPerSecond\n}\n\nstruct SearchAttributes {\n  10: optional map<string,binary> indexedFields\n}\n\nstruct WorkerVersionInfo {\n  10: optional string impl\n  20: optional string featureVersion\n}\n\nstruct WorkflowExecutionConfiguration {\n  10: optional TaskList taskList\n  20: optional i32 executionStartToCloseTimeoutSeconds\n  30: optional i32 taskStartToCloseTimeoutSeconds\n//  40: optional ChildPolicy childPolicy -- Removed but reserve the IDL order number\n}\n\nstruct ResetPoints{\n  10: optional list<ResetPointInfo> points\n}\n\n struct ResetPointInfo{\n  10: optional string binaryChecksum\n  20: optional string runId\n  30: optional i64 firstDecisionCompletedId\n  40: optional i64 (js.type = \"Long\") createdTimeNano\n  50: optional i64 (js.type = \"Long\") expiringTimeNano //the time that the run is deleted due to retention\n  60: optional bool resettable                         // false if the resset point has pending childWFs/reqCancels/signalExternals.\n}\n\nstruct WorkflowExecutionCompletedEventAttributes {\n  10: optional binary result\n  20: optional i64 (js.type = \"Long\") decisionTaskCompletedEventId\n}\n\nstruct WorkflowExecutionFailedEventAttributes {\n  10: optional string reason\n  20: optional binary details\n  30: optional i64 (js.type = \"Long\") decisionTaskCompletedEventId\n}\n\nstruct WorkflowExecutionTimedOutEventAttributes {\n  10: optional TimeoutType timeoutType\n}\n\nenum ContinueAsNewInitiator {\n  Decider,\n  RetryPolicy,\n  CronSchedule,\n}\n\n\nstruct WorkflowExecutionFilter {\n  10: optional string workflowId\n  20: optional string runId\n}\n\nstruct WorkflowTypeFilter {\n  10: optional string name\n}\n\nstruct StartTimeFilter {\n  10: optional i64 (js.type = \"Long\") earliestTime\n  20: optional i64 (js.type = \"Long\") latestTime\n}\n\nstruct DomainInfo {\n  10: optional string name\n  20: optional DomainStatus status\n  30: optional string description\n  40: optional string ownerEmail\n  // A key-value map for any customized purpose\n  50: optional map<string,string> data\n  60: optional string uuid\n}\n\nstruct UpdateDomainInfo {\n  10: optional string description\n  20: optional string ownerEmail\n  // A key-value map for any customized purpose\n  30: optional map<string,string> data\n}\n\nstruct ClusterReplicationConfiguration {\n 10: optional string clusterName\n}\n\nstruct DomainReplicationConfiguration {\n 10: optional string activeClusterName\n 20: optional list<ClusterReplicationConfiguration> clusters\n}\n\nstruct RegisterDomainRequest {\n  10: optional string name\n  20: optional string description\n  30: optional string ownerEmail\n  40: optional i32 workflowExecutionRetentionPeriodInDays\n  50: optional bool emitMetric = true\n  60: optional list<ClusterReplicationConfiguration> clusters\n  70: optional string activeClusterName\n  // A key-value map for any customized purpose\n  80: optional map<string,string> data\n  90: optional string securityToken\n  120: optional bool isGlobalDomain\n  130: optional ArchivalStatus historyArchivalStatus\n  140: optional string historyArchivalURI\n  150: optional ArchivalStatus visibilityArchivalStatus\n  160: optional string visibilityArchivalURI\n}\n\nstruct StartWorkflowExecutionResponse {\n  10: optional string runId\n}\n\nstruct PollForDecisionTaskRequest {\n  10: optional string domain\n  20: optional TaskList taskList\n  30: optional string identity\n  40: optional string binaryChecksum\n}\n\nstruct StickyExecutionAttributes {\n  10: optional TaskList workerTaskList\n  20: optional i32 scheduleToStartTimeoutSeconds\n}\n\nstruct RespondDecisionTaskFailedRequest {\n  10: optional binary taskToken\n  20: optional DecisionTaskFailedCause cause\n  30: optional binary details\n  40: optional string identity\n  50: optional string binaryChecksum\n}\n\nstruct PollForActivityTaskRequest {\n  10: optional string domain\n  20: optional TaskList taskList\n  30: optional string identity\n  40: optional TaskListMetadata taskListMetadata\n}\n\nstruct RecordActivityTaskHeartbeatRequest {\n  10: optional binary taskToken\n  20: optional binary details\n  30: optional string identity\n}\n\nstruct RecordActivityTaskHeartbeatByIDRequest {\n  10: optional string domain\n  20: optional string workflowID\n  30: optional string runID\n  40: optional string activityID\n  50: optional binary details\n  60: optional string identity\n}\n\nstruct RecordActivityTaskHeartbeatResponse {\n  10: optional bool cancelRequested\n}\n\nstruct RespondActivityTaskCompletedRequest {\n  10: optional binary taskToken\n  20: optional binary result\n  30: optional string identity\n}\n\nstruct RespondActivityTaskFailedRequest {\n  10: optional binary taskToken\n  20: optional string reason\n  30: optional binary details\n  40: optional string identity\n}\n\nstruct RespondActivityTaskCanceledRequest {\n  10: optional binary taskToken\n  20: optional binary details\n  30: optional string identity\n}\n\nstruct RespondActivityTaskCompletedByIDRequest {\n  10: optional string domain\n  20: optional string workflowID\n  30: optional string runID\n  40: optional string activityID\n  50: optional binary result\n  60: optional string identity\n}\n\nstruct RespondActivityTaskFailedByIDRequest {\n  10: optional string domain\n  20: optional string workflowID\n  30: optional string runID\n  40: optional string activityID\n  50: optional string reason\n  60: optional binary details\n  70: optional string identity\n}\n\nstruct RespondActivityTaskCanceledByIDRequest {\n  10: optional string domain\n  20: optional string workflowID\n  30: optional string runID\n  40: optional string activityID\n  50: optional binary details\n  60: optional string identity\n}\n\nstruct ResetWorkflowExecutionResponse {\n  10: optional string runId\n}\n\nstruct ListOpenWorkflowExecutionsRequest {\n  10: optional string domain\n  20: optional i32 maximumPageSize\n  30: optional binary nextPageToken\n  40: optional StartTimeFilter StartTimeFilter\n  50: optional WorkflowExecutionFilter executionFilter\n  60: optional WorkflowTypeFilter typeFilter\n}\n\nstruct ListClosedWorkflowExecutionsRequest {\n  10: optional string domain\n  20: optional i32 maximumPageSize\n  30: optional binary nextPageToken\n  40: optional StartTimeFilter StartTimeFilter\n  50: optional WorkflowExecutionFilter executionFilter\n  60: optional WorkflowTypeFilter typeFilter\n  70: optional WorkflowExecutionCloseStatus statusFilter\n}\n\nstruct ListWorkflowExecutionsRequest {\n  10: optional string domain\n  20: optional i32 pageSize\n  30: optional binary nextPageToken\n  40: optional string query\n}\nstruct ListArchivedWorkflowExecutionsRequest {\n  10: optional string domain\n  20: optional i32 pageSize\n  30: optional binary nextPageToken\n  40: optional string query\n}\n\nstruct CountWorkflowExecutionsRequest {\n  10: optional string domain\n  20: optional string query\n}\n\nstruct CountWorkflowExecutionsResponse {\n  10: optional i64 count\n}\n\nstruct GetSearchAttributesResponse {\n  10: optional map<string, IndexedValueType> keys\n}\n\nstruct QueryRejected {\n  10: optional WorkflowExecutionCloseStatus closeStatus\n}\n\nstruct QueryWorkflowResponse {\n  10: optional binary queryResult\n  20: optional QueryRejected queryRejected\n}\n\nstruct WorkflowQuery {\n  10: optional string queryType\n  20: optional binary queryArgs\n}\n\n\nstruct ResetStickyTaskListResponse {\n    // The reason to keep this response is to allow returning\n    // information in the future.\n}\n\nstruct RespondQueryTaskCompletedRequest {\n  10: optional binary taskToken\n  20: optional QueryTaskCompletedType completedType\n  30: optional binary queryResult\n  40: optional string errorMessage\n  50: optional WorkerVersionInfo workerVersionInfo\n}\n\nstruct WorkflowQueryResult {\n  10: optional QueryResultType resultType\n  20: optional binary answer\n  30: optional string errorMessage\n}\n\nstruct PendingActivityInfo {\n  10: optional string activityID\n  20: optional ActivityType activityType\n  30: optional PendingActivityState state\n  40: optional binary heartbeatDetails\n  50: optional i64 (js.type = \"Long\") lastHeartbeatTimestamp\n  60: optional i64 (js.type = \"Long\") lastStartedTimestamp\n  70: optional i32 attempt\n  80: optional i32 maximumAttempts\n  90: optional i64 (js.type = \"Long\") scheduledTimestamp\n  100: optional i64 (js.type = \"Long\") expirationTimestamp\n  110: optional string lastFailureReason\n  120: optional string lastWorkerIdentity\n  130: optional binary lastFailureDetails\n}\n\nstruct PendingChildExecutionInfo {\n  10: optional string workflowID\n  20: optional string runID\n  30: optional string workflowTypName\n  40: optional i64 (js.type = \"Long\") initiatedID\n  50: optional ParentClosePolicy parentClosePolicy\n}\nstruct DescribeTaskListRequest {\n  10: optional string domain\n  20: optional TaskList taskList\n  30: optional TaskListType taskListType\n  40: optional bool includeTaskListStatus\n}\n\nstruct DescribeTaskListResponse {\n  10: optional list<PollerInfo> pollers\n  20: optional TaskListStatus taskListStatus\n}\n\nstruct ListTaskListPartitionsRequest {\n  10: optional string domain\n  20: optional TaskList taskList\n}\n\nstruct TaskListPartitionMetadata {\n  10: optional string key\n  20: optional string ownerHostName\n}\n\nstruct ListTaskListPartitionsResponse {\n  10: optional list<TaskListPartitionMetadata> activityTaskListPartitions\n  20: optional list<TaskListPartitionMetadata> decisionTaskListPartitions\n}\n\nstruct TaskListStatus {\n  10: optional i64 (js.type = \"Long\") backlogCountHint\n  20: optional i64 (js.type = \"Long\") readLevel\n  30: optional i64 (js.type = \"Long\") ackLevel\n  35: optional double ratePerSecond\n  40: optional TaskIDBlock taskIDBlock\n}\n\nstruct TaskIDBlock {\n  10: optional i64 (js.type = \"Long\")  startID\n  20: optional i64 (js.type = \"Long\")  endID\n}\n\n\nstruct RemoveTaskRequest {\n  10: optional i32                      shardID\n  20: optional i32                      type\n  30: optional i64 (js.type = \"Long\")   taskID\n}\n\nstruct CloseShardRequest {\n  10: optional i32               shardID\n}\n\nstruct DescribeHistoryHostResponse{\n  10: optional i32                  numberOfShards\n  20: optional list<i32>            shardIDs\n  30: optional DomainCacheInfo      domainCache\n  40: optional string               shardControllerStatus\n  50: optional string               address\n}\n\nstruct DomainCacheInfo{\n  10: optional i64 numOfItemsInCacheByID\n  20: optional i64 numOfItemsInCacheByName\n}\n\nenum TaskListType {\n  /*\n   * Decision type of tasklist\n   */\n  Decision,\n  /*\n   * Activity type of tasklist\n   */\n  Activity,\n}\n\nstruct PollerInfo {\n  // Unix Nano\n  10: optional i64 (js.type = \"Long\")  lastAccessTime\n  20: optional string identity\n  30: optional double ratePerSecond\n}\n\nstruct RetryPolicy {\n  // Interval of the first retry. If coefficient is 1.0 then it is used for all retries.\n  10: optional i32 initialIntervalInSeconds\n\n  // Coefficient used to calculate the next retry interval.\n  // The next retry interval is previous interval multiplied by the coefficient.\n  // Must be 1 or larger.\n  20: optional double backoffCoefficient\n\n  // Maximum interval between retries. Exponential backoff leads to interval increase.\n  // This value is the cap of the increase. Default is 100x of initial interval.\n  30: optional i32 maximumIntervalInSeconds\n\n  // Maximum number of attempts. When exceeded the retries stop even if not expired yet.\n  // Must be 1 or bigger. Default is unlimited.\n  40: optional i32 maximumAttempts\n\n  // Non-Retriable errors. Will stop retrying if error matches this list.\n  50: optional list<string> nonRetriableErrorReasons\n\n  // Expiration time for the whole retry process.\n  60: optional i32 expirationIntervalInSeconds\n}\n\n// HistoryBranchRange represents a piece of range for a branch.\nstruct HistoryBranchRange{\n  // branchID of original branch forked from\n  10: optional string branchID\n  // beinning node for the range, inclusive\n  20: optional i64 beginNodeID\n  // ending node for the range, exclusive\n  30: optional i64 endNodeID\n}\n\n// For history persistence to serialize/deserialize branch details\nstruct HistoryBranch{\n  10: optional string treeID\n  20: optional string branchID\n  30: optional list<HistoryBranchRange> ancestors\n}\n\n// VersionHistoryItem contains signal eventID and the corresponding version\nstruct VersionHistoryItem{\n  10: optional i64 (js.type = \"Long\") eventID\n  20: optional i64 (js.type = \"Long\") version\n}\n\n// VersionHistory contains the version history of a branch\nstruct VersionHistory{\n  10: optional binary branchToken\n  20: optional list<VersionHistoryItem> items\n}\n\n// VersionHistories contains all version histories from all branches\nstruct VersionHistories{\n  10: optional i32 currentVersionHistoryIndex\n  20: optional list<VersionHistory> histories\n}\n\n\n// SupportedClientVersions contains the support versions for client library\nstruct SupportedClientVersions{\n  10: optional string goSdk\n  20: optional string javaSdk\n}\n\n// ClusterInfo contains information about cadence cluster\nstruct ClusterInfo{\n  10: optional SupportedClientVersions supportedClientVersions\n}\n\n\n"
