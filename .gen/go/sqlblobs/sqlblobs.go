// The MIT License (MIT)
// 
// Copyright (c) 2020 Uber Technologies, Inc.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// Code generated by thriftrw v1.20.2. DO NOT EDIT.
// @generated

package sqlblobs

import (
	bytes "bytes"
	base64 "encoding/base64"
	fmt "fmt"
	shared "github.com/temporalio/temporal/.gen/go/shared"
	multierr "go.uber.org/multierr"
	thriftreflect "go.uber.org/thriftrw/thriftreflect"
	wire "go.uber.org/thriftrw/wire"
	zapcore "go.uber.org/zap/zapcore"
	strings "strings"
)

type ActivityInfo struct {
	Version                       *int64   `json:"version,omitempty"`
	ScheduledEventBatchID         *int64   `json:"scheduledEventBatchID,omitempty"`
	ScheduledEvent                []byte   `json:"scheduledEvent,omitempty"`
	ScheduledEventEncoding        *string  `json:"scheduledEventEncoding,omitempty"`
	ScheduledTimeNanos            *int64   `json:"scheduledTimeNanos,omitempty"`
	StartedID                     *int64   `json:"startedID,omitempty"`
	StartedEvent                  []byte   `json:"startedEvent,omitempty"`
	StartedEventEncoding          *string  `json:"startedEventEncoding,omitempty"`
	StartedTimeNanos              *int64   `json:"startedTimeNanos,omitempty"`
	ActivityID                    *string  `json:"activityID,omitempty"`
	RequestID                     *string  `json:"requestID,omitempty"`
	ScheduleToStartTimeoutSeconds *int32   `json:"scheduleToStartTimeoutSeconds,omitempty"`
	ScheduleToCloseTimeoutSeconds *int32   `json:"scheduleToCloseTimeoutSeconds,omitempty"`
	StartToCloseTimeoutSeconds    *int32   `json:"startToCloseTimeoutSeconds,omitempty"`
	HeartbeatTimeoutSeconds       *int32   `json:"heartbeatTimeoutSeconds,omitempty"`
	CancelRequested               *bool    `json:"cancelRequested,omitempty"`
	CancelRequestID               *int64   `json:"cancelRequestID,omitempty"`
	TimerTaskStatus               *int32   `json:"timerTaskStatus,omitempty"`
	Attempt                       *int32   `json:"attempt,omitempty"`
	TaskList                      *string  `json:"taskList,omitempty"`
	StartedIdentity               *string  `json:"startedIdentity,omitempty"`
	HasRetryPolicy                *bool    `json:"hasRetryPolicy,omitempty"`
	RetryInitialIntervalSeconds   *int32   `json:"retryInitialIntervalSeconds,omitempty"`
	RetryMaximumIntervalSeconds   *int32   `json:"retryMaximumIntervalSeconds,omitempty"`
	RetryMaximumAttempts          *int32   `json:"retryMaximumAttempts,omitempty"`
	RetryExpirationTimeNanos      *int64   `json:"retryExpirationTimeNanos,omitempty"`
	RetryBackoffCoefficient       *float64 `json:"retryBackoffCoefficient,omitempty"`
	RetryNonRetryableErrors       []string `json:"retryNonRetryableErrors,omitempty"`
	RetryLastFailureReason        *string  `json:"retryLastFailureReason,omitempty"`
	RetryLastWorkerIdentity       *string  `json:"retryLastWorkerIdentity,omitempty"`
	RetryLastFailureDetails       []byte   `json:"retryLastFailureDetails,omitempty"`
}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_String_ValueList) Size() int {
	return len(v)
}

func (_List_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_String_ValueList) Close() {}

// ToWire translates a ActivityInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ActivityInfo) ToWire() (wire.Value, error) {
	var (
		fields [31]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Version != nil {
		w, err = wire.NewValueI64(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.ScheduledEventBatchID != nil {
		w, err = wire.NewValueI64(*(v.ScheduledEventBatchID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.ScheduledEvent != nil {
		w, err = wire.NewValueBinary(v.ScheduledEvent), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.ScheduledEventEncoding != nil {
		w, err = wire.NewValueString(*(v.ScheduledEventEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.ScheduledTimeNanos != nil {
		w, err = wire.NewValueI64(*(v.ScheduledTimeNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}
	if v.StartedID != nil {
		w, err = wire.NewValueI64(*(v.StartedID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.StartedEvent != nil {
		w, err = wire.NewValueBinary(v.StartedEvent), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 22, Value: w}
		i++
	}
	if v.StartedEventEncoding != nil {
		w, err = wire.NewValueString(*(v.StartedEventEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 24, Value: w}
		i++
	}
	if v.StartedTimeNanos != nil {
		w, err = wire.NewValueI64(*(v.StartedTimeNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 26, Value: w}
		i++
	}
	if v.ActivityID != nil {
		w, err = wire.NewValueString(*(v.ActivityID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 28, Value: w}
		i++
	}
	if v.RequestID != nil {
		w, err = wire.NewValueString(*(v.RequestID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.ScheduleToStartTimeoutSeconds != nil {
		w, err = wire.NewValueI32(*(v.ScheduleToStartTimeoutSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 32, Value: w}
		i++
	}
	if v.ScheduleToCloseTimeoutSeconds != nil {
		w, err = wire.NewValueI32(*(v.ScheduleToCloseTimeoutSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 34, Value: w}
		i++
	}
	if v.StartToCloseTimeoutSeconds != nil {
		w, err = wire.NewValueI32(*(v.StartToCloseTimeoutSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 36, Value: w}
		i++
	}
	if v.HeartbeatTimeoutSeconds != nil {
		w, err = wire.NewValueI32(*(v.HeartbeatTimeoutSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 38, Value: w}
		i++
	}
	if v.CancelRequested != nil {
		w, err = wire.NewValueBool(*(v.CancelRequested)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.CancelRequestID != nil {
		w, err = wire.NewValueI64(*(v.CancelRequestID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 42, Value: w}
		i++
	}
	if v.TimerTaskStatus != nil {
		w, err = wire.NewValueI32(*(v.TimerTaskStatus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 44, Value: w}
		i++
	}
	if v.Attempt != nil {
		w, err = wire.NewValueI32(*(v.Attempt)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 46, Value: w}
		i++
	}
	if v.TaskList != nil {
		w, err = wire.NewValueString(*(v.TaskList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 48, Value: w}
		i++
	}
	if v.StartedIdentity != nil {
		w, err = wire.NewValueString(*(v.StartedIdentity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 50, Value: w}
		i++
	}
	if v.HasRetryPolicy != nil {
		w, err = wire.NewValueBool(*(v.HasRetryPolicy)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 52, Value: w}
		i++
	}
	if v.RetryInitialIntervalSeconds != nil {
		w, err = wire.NewValueI32(*(v.RetryInitialIntervalSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 54, Value: w}
		i++
	}
	if v.RetryMaximumIntervalSeconds != nil {
		w, err = wire.NewValueI32(*(v.RetryMaximumIntervalSeconds)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 56, Value: w}
		i++
	}
	if v.RetryMaximumAttempts != nil {
		w, err = wire.NewValueI32(*(v.RetryMaximumAttempts)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 58, Value: w}
		i++
	}
	if v.RetryExpirationTimeNanos != nil {
		w, err = wire.NewValueI64(*(v.RetryExpirationTimeNanos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 60, Value: w}
		i++
	}
	if v.RetryBackoffCoefficient != nil {
		w, err = wire.NewValueDouble(*(v.RetryBackoffCoefficient)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 62, Value: w}
		i++
	}
	if v.RetryNonRetryableErrors != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.RetryNonRetryableErrors)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 64, Value: w}
		i++
	}
	if v.RetryLastFailureReason != nil {
		w, err = wire.NewValueString(*(v.RetryLastFailureReason)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 66, Value: w}
		i++
	}
	if v.RetryLastWorkerIdentity != nil {
		w, err = wire.NewValueString(*(v.RetryLastWorkerIdentity)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 68, Value: w}
		i++
	}
	if v.RetryLastFailureDetails != nil {
		w, err = wire.NewValueBinary(v.RetryLastFailureDetails), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 70, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_String_Read(l wire.ValueList) ([]string, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]string, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a ActivityInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ActivityInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ActivityInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ActivityInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ScheduledEventBatchID = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TBinary {
				v.ScheduledEvent, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ScheduledEventEncoding = &x
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ScheduledTimeNanos = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.StartedID = &x
				if err != nil {
					return err
				}

			}
		case 22:
			if field.Value.Type() == wire.TBinary {
				v.StartedEvent, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 24:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StartedEventEncoding = &x
				if err != nil {
					return err
				}

			}
		case 26:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.StartedTimeNanos = &x
				if err != nil {
					return err
				}

			}
		case 28:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ActivityID = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RequestID = &x
				if err != nil {
					return err
				}

			}
		case 32:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ScheduleToStartTimeoutSeconds = &x
				if err != nil {
					return err
				}

			}
		case 34:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ScheduleToCloseTimeoutSeconds = &x
				if err != nil {
					return err
				}

			}
		case 36:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.StartToCloseTimeoutSeconds = &x
				if err != nil {
					return err
				}

			}
		case 38:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.HeartbeatTimeoutSeconds = &x
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.CancelRequested = &x
				if err != nil {
					return err
				}

			}
		case 42:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.CancelRequestID = &x
				if err != nil {
					return err
				}

			}
		case 44:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.TimerTaskStatus = &x
				if err != nil {
					return err
				}

			}
		case 46:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Attempt = &x
				if err != nil {
					return err
				}

			}
		case 48:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.TaskList = &x
				if err != nil {
					return err
				}

			}
		case 50:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StartedIdentity = &x
				if err != nil {
					return err
				}

			}
		case 52:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.HasRetryPolicy = &x
				if err != nil {
					return err
				}

			}
		case 54:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.RetryInitialIntervalSeconds = &x
				if err != nil {
					return err
				}

			}
		case 56:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.RetryMaximumIntervalSeconds = &x
				if err != nil {
					return err
				}

			}
		case 58:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.RetryMaximumAttempts = &x
				if err != nil {
					return err
				}

			}
		case 60:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.RetryExpirationTimeNanos = &x
				if err != nil {
					return err
				}

			}
		case 62:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.RetryBackoffCoefficient = &x
				if err != nil {
					return err
				}

			}
		case 64:
			if field.Value.Type() == wire.TList {
				v.RetryNonRetryableErrors, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 66:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RetryLastFailureReason = &x
				if err != nil {
					return err
				}

			}
		case 68:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.RetryLastWorkerIdentity = &x
				if err != nil {
					return err
				}

			}
		case 70:
			if field.Value.Type() == wire.TBinary {
				v.RetryLastFailureDetails, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ActivityInfo
// struct.
func (v *ActivityInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [31]string
	i := 0
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	if v.ScheduledEventBatchID != nil {
		fields[i] = fmt.Sprintf("ScheduledEventBatchID: %v", *(v.ScheduledEventBatchID))
		i++
	}
	if v.ScheduledEvent != nil {
		fields[i] = fmt.Sprintf("ScheduledEvent: %v", v.ScheduledEvent)
		i++
	}
	if v.ScheduledEventEncoding != nil {
		fields[i] = fmt.Sprintf("ScheduledEventEncoding: %v", *(v.ScheduledEventEncoding))
		i++
	}
	if v.ScheduledTimeNanos != nil {
		fields[i] = fmt.Sprintf("ScheduledTimeNanos: %v", *(v.ScheduledTimeNanos))
		i++
	}
	if v.StartedID != nil {
		fields[i] = fmt.Sprintf("StartedID: %v", *(v.StartedID))
		i++
	}
	if v.StartedEvent != nil {
		fields[i] = fmt.Sprintf("StartedEvent: %v", v.StartedEvent)
		i++
	}
	if v.StartedEventEncoding != nil {
		fields[i] = fmt.Sprintf("StartedEventEncoding: %v", *(v.StartedEventEncoding))
		i++
	}
	if v.StartedTimeNanos != nil {
		fields[i] = fmt.Sprintf("StartedTimeNanos: %v", *(v.StartedTimeNanos))
		i++
	}
	if v.ActivityID != nil {
		fields[i] = fmt.Sprintf("ActivityID: %v", *(v.ActivityID))
		i++
	}
	if v.RequestID != nil {
		fields[i] = fmt.Sprintf("RequestID: %v", *(v.RequestID))
		i++
	}
	if v.ScheduleToStartTimeoutSeconds != nil {
		fields[i] = fmt.Sprintf("ScheduleToStartTimeoutSeconds: %v", *(v.ScheduleToStartTimeoutSeconds))
		i++
	}
	if v.ScheduleToCloseTimeoutSeconds != nil {
		fields[i] = fmt.Sprintf("ScheduleToCloseTimeoutSeconds: %v", *(v.ScheduleToCloseTimeoutSeconds))
		i++
	}
	if v.StartToCloseTimeoutSeconds != nil {
		fields[i] = fmt.Sprintf("StartToCloseTimeoutSeconds: %v", *(v.StartToCloseTimeoutSeconds))
		i++
	}
	if v.HeartbeatTimeoutSeconds != nil {
		fields[i] = fmt.Sprintf("HeartbeatTimeoutSeconds: %v", *(v.HeartbeatTimeoutSeconds))
		i++
	}
	if v.CancelRequested != nil {
		fields[i] = fmt.Sprintf("CancelRequested: %v", *(v.CancelRequested))
		i++
	}
	if v.CancelRequestID != nil {
		fields[i] = fmt.Sprintf("CancelRequestID: %v", *(v.CancelRequestID))
		i++
	}
	if v.TimerTaskStatus != nil {
		fields[i] = fmt.Sprintf("TimerTaskStatus: %v", *(v.TimerTaskStatus))
		i++
	}
	if v.Attempt != nil {
		fields[i] = fmt.Sprintf("Attempt: %v", *(v.Attempt))
		i++
	}
	if v.TaskList != nil {
		fields[i] = fmt.Sprintf("TaskList: %v", *(v.TaskList))
		i++
	}
	if v.StartedIdentity != nil {
		fields[i] = fmt.Sprintf("StartedIdentity: %v", *(v.StartedIdentity))
		i++
	}
	if v.HasRetryPolicy != nil {
		fields[i] = fmt.Sprintf("HasRetryPolicy: %v", *(v.HasRetryPolicy))
		i++
	}
	if v.RetryInitialIntervalSeconds != nil {
		fields[i] = fmt.Sprintf("RetryInitialIntervalSeconds: %v", *(v.RetryInitialIntervalSeconds))
		i++
	}
	if v.RetryMaximumIntervalSeconds != nil {
		fields[i] = fmt.Sprintf("RetryMaximumIntervalSeconds: %v", *(v.RetryMaximumIntervalSeconds))
		i++
	}
	if v.RetryMaximumAttempts != nil {
		fields[i] = fmt.Sprintf("RetryMaximumAttempts: %v", *(v.RetryMaximumAttempts))
		i++
	}
	if v.RetryExpirationTimeNanos != nil {
		fields[i] = fmt.Sprintf("RetryExpirationTimeNanos: %v", *(v.RetryExpirationTimeNanos))
		i++
	}
	if v.RetryBackoffCoefficient != nil {
		fields[i] = fmt.Sprintf("RetryBackoffCoefficient: %v", *(v.RetryBackoffCoefficient))
		i++
	}
	if v.RetryNonRetryableErrors != nil {
		fields[i] = fmt.Sprintf("RetryNonRetryableErrors: %v", v.RetryNonRetryableErrors)
		i++
	}
	if v.RetryLastFailureReason != nil {
		fields[i] = fmt.Sprintf("RetryLastFailureReason: %v", *(v.RetryLastFailureReason))
		i++
	}
	if v.RetryLastWorkerIdentity != nil {
		fields[i] = fmt.Sprintf("RetryLastWorkerIdentity: %v", *(v.RetryLastWorkerIdentity))
		i++
	}
	if v.RetryLastFailureDetails != nil {
		fields[i] = fmt.Sprintf("RetryLastFailureDetails: %v", v.RetryLastFailureDetails)
		i++
	}

	return fmt.Sprintf("ActivityInfo{%v}", strings.Join(fields[:i], ", "))
}

func _I64_EqualsPtr(lhs, rhs *int64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I32_EqualsPtr(lhs, rhs *int32) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Double_EqualsPtr(lhs, rhs *float64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _List_String_Equals(lhs, rhs []string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ActivityInfo match the
// provided ActivityInfo.
//
// This function performs a deep comparison.
func (v *ActivityInfo) Equals(rhs *ActivityInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	if !_I64_EqualsPtr(v.ScheduledEventBatchID, rhs.ScheduledEventBatchID) {
		return false
	}
	if !((v.ScheduledEvent == nil && rhs.ScheduledEvent == nil) || (v.ScheduledEvent != nil && rhs.ScheduledEvent != nil && bytes.Equal(v.ScheduledEvent, rhs.ScheduledEvent))) {
		return false
	}
	if !_String_EqualsPtr(v.ScheduledEventEncoding, rhs.ScheduledEventEncoding) {
		return false
	}
	if !_I64_EqualsPtr(v.ScheduledTimeNanos, rhs.ScheduledTimeNanos) {
		return false
	}
	if !_I64_EqualsPtr(v.StartedID, rhs.StartedID) {
		return false
	}
	if !((v.StartedEvent == nil && rhs.StartedEvent == nil) || (v.StartedEvent != nil && rhs.StartedEvent != nil && bytes.Equal(v.StartedEvent, rhs.StartedEvent))) {
		return false
	}
	if !_String_EqualsPtr(v.StartedEventEncoding, rhs.StartedEventEncoding) {
		return false
	}
	if !_I64_EqualsPtr(v.StartedTimeNanos, rhs.StartedTimeNanos) {
		return false
	}
	if !_String_EqualsPtr(v.ActivityID, rhs.ActivityID) {
		return false
	}
	if !_String_EqualsPtr(v.RequestID, rhs.RequestID) {
		return false
	}
	if !_I32_EqualsPtr(v.ScheduleToStartTimeoutSeconds, rhs.ScheduleToStartTimeoutSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.ScheduleToCloseTimeoutSeconds, rhs.ScheduleToCloseTimeoutSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.StartToCloseTimeoutSeconds, rhs.StartToCloseTimeoutSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.HeartbeatTimeoutSeconds, rhs.HeartbeatTimeoutSeconds) {
		return false
	}
	if !_Bool_EqualsPtr(v.CancelRequested, rhs.CancelRequested) {
		return false
	}
	if !_I64_EqualsPtr(v.CancelRequestID, rhs.CancelRequestID) {
		return false
	}
	if !_I32_EqualsPtr(v.TimerTaskStatus, rhs.TimerTaskStatus) {
		return false
	}
	if !_I32_EqualsPtr(v.Attempt, rhs.Attempt) {
		return false
	}
	if !_String_EqualsPtr(v.TaskList, rhs.TaskList) {
		return false
	}
	if !_String_EqualsPtr(v.StartedIdentity, rhs.StartedIdentity) {
		return false
	}
	if !_Bool_EqualsPtr(v.HasRetryPolicy, rhs.HasRetryPolicy) {
		return false
	}
	if !_I32_EqualsPtr(v.RetryInitialIntervalSeconds, rhs.RetryInitialIntervalSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.RetryMaximumIntervalSeconds, rhs.RetryMaximumIntervalSeconds) {
		return false
	}
	if !_I32_EqualsPtr(v.RetryMaximumAttempts, rhs.RetryMaximumAttempts) {
		return false
	}
	if !_I64_EqualsPtr(v.RetryExpirationTimeNanos, rhs.RetryExpirationTimeNanos) {
		return false
	}
	if !_Double_EqualsPtr(v.RetryBackoffCoefficient, rhs.RetryBackoffCoefficient) {
		return false
	}
	if !((v.RetryNonRetryableErrors == nil && rhs.RetryNonRetryableErrors == nil) || (v.RetryNonRetryableErrors != nil && rhs.RetryNonRetryableErrors != nil && _List_String_Equals(v.RetryNonRetryableErrors, rhs.RetryNonRetryableErrors))) {
		return false
	}
	if !_String_EqualsPtr(v.RetryLastFailureReason, rhs.RetryLastFailureReason) {
		return false
	}
	if !_String_EqualsPtr(v.RetryLastWorkerIdentity, rhs.RetryLastWorkerIdentity) {
		return false
	}
	if !((v.RetryLastFailureDetails == nil && rhs.RetryLastFailureDetails == nil) || (v.RetryLastFailureDetails != nil && rhs.RetryLastFailureDetails != nil && bytes.Equal(v.RetryLastFailureDetails, rhs.RetryLastFailureDetails))) {
		return false
	}

	return true
}

type _List_String_Zapper []string

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_String_Zapper.
func (l _List_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendString(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ActivityInfo.
func (v *ActivityInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Version != nil {
		enc.AddInt64("version", *v.Version)
	}
	if v.ScheduledEventBatchID != nil {
		enc.AddInt64("scheduledEventBatchID", *v.ScheduledEventBatchID)
	}
	if v.ScheduledEvent != nil {
		enc.AddString("scheduledEvent", base64.StdEncoding.EncodeToString(v.ScheduledEvent))
	}
	if v.ScheduledEventEncoding != nil {
		enc.AddString("scheduledEventEncoding", *v.ScheduledEventEncoding)
	}
	if v.ScheduledTimeNanos != nil {
		enc.AddInt64("scheduledTimeNanos", *v.ScheduledTimeNanos)
	}
	if v.StartedID != nil {
		enc.AddInt64("startedID", *v.StartedID)
	}
	if v.StartedEvent != nil {
		enc.AddString("startedEvent", base64.StdEncoding.EncodeToString(v.StartedEvent))
	}
	if v.StartedEventEncoding != nil {
		enc.AddString("startedEventEncoding", *v.StartedEventEncoding)
	}
	if v.StartedTimeNanos != nil {
		enc.AddInt64("startedTimeNanos", *v.StartedTimeNanos)
	}
	if v.ActivityID != nil {
		enc.AddString("activityID", *v.ActivityID)
	}
	if v.RequestID != nil {
		enc.AddString("requestID", *v.RequestID)
	}
	if v.ScheduleToStartTimeoutSeconds != nil {
		enc.AddInt32("scheduleToStartTimeoutSeconds", *v.ScheduleToStartTimeoutSeconds)
	}
	if v.ScheduleToCloseTimeoutSeconds != nil {
		enc.AddInt32("scheduleToCloseTimeoutSeconds", *v.ScheduleToCloseTimeoutSeconds)
	}
	if v.StartToCloseTimeoutSeconds != nil {
		enc.AddInt32("startToCloseTimeoutSeconds", *v.StartToCloseTimeoutSeconds)
	}
	if v.HeartbeatTimeoutSeconds != nil {
		enc.AddInt32("heartbeatTimeoutSeconds", *v.HeartbeatTimeoutSeconds)
	}
	if v.CancelRequested != nil {
		enc.AddBool("cancelRequested", *v.CancelRequested)
	}
	if v.CancelRequestID != nil {
		enc.AddInt64("cancelRequestID", *v.CancelRequestID)
	}
	if v.TimerTaskStatus != nil {
		enc.AddInt32("timerTaskStatus", *v.TimerTaskStatus)
	}
	if v.Attempt != nil {
		enc.AddInt32("attempt", *v.Attempt)
	}
	if v.TaskList != nil {
		enc.AddString("taskList", *v.TaskList)
	}
	if v.StartedIdentity != nil {
		enc.AddString("startedIdentity", *v.StartedIdentity)
	}
	if v.HasRetryPolicy != nil {
		enc.AddBool("hasRetryPolicy", *v.HasRetryPolicy)
	}
	if v.RetryInitialIntervalSeconds != nil {
		enc.AddInt32("retryInitialIntervalSeconds", *v.RetryInitialIntervalSeconds)
	}
	if v.RetryMaximumIntervalSeconds != nil {
		enc.AddInt32("retryMaximumIntervalSeconds", *v.RetryMaximumIntervalSeconds)
	}
	if v.RetryMaximumAttempts != nil {
		enc.AddInt32("retryMaximumAttempts", *v.RetryMaximumAttempts)
	}
	if v.RetryExpirationTimeNanos != nil {
		enc.AddInt64("retryExpirationTimeNanos", *v.RetryExpirationTimeNanos)
	}
	if v.RetryBackoffCoefficient != nil {
		enc.AddFloat64("retryBackoffCoefficient", *v.RetryBackoffCoefficient)
	}
	if v.RetryNonRetryableErrors != nil {
		err = multierr.Append(err, enc.AddArray("retryNonRetryableErrors", (_List_String_Zapper)(v.RetryNonRetryableErrors)))
	}
	if v.RetryLastFailureReason != nil {
		enc.AddString("retryLastFailureReason", *v.RetryLastFailureReason)
	}
	if v.RetryLastWorkerIdentity != nil {
		enc.AddString("retryLastWorkerIdentity", *v.RetryLastWorkerIdentity)
	}
	if v.RetryLastFailureDetails != nil {
		enc.AddString("retryLastFailureDetails", base64.StdEncoding.EncodeToString(v.RetryLastFailureDetails))
	}
	return err
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetVersion() (o int64) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *ActivityInfo) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

// GetScheduledEventBatchID returns the value of ScheduledEventBatchID if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetScheduledEventBatchID() (o int64) {
	if v != nil && v.ScheduledEventBatchID != nil {
		return *v.ScheduledEventBatchID
	}

	return
}

// IsSetScheduledEventBatchID returns true if ScheduledEventBatchID is not nil.
func (v *ActivityInfo) IsSetScheduledEventBatchID() bool {
	return v != nil && v.ScheduledEventBatchID != nil
}

// GetScheduledEvent returns the value of ScheduledEvent if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetScheduledEvent() (o []byte) {
	if v != nil && v.ScheduledEvent != nil {
		return v.ScheduledEvent
	}

	return
}

// IsSetScheduledEvent returns true if ScheduledEvent is not nil.
func (v *ActivityInfo) IsSetScheduledEvent() bool {
	return v != nil && v.ScheduledEvent != nil
}

// GetScheduledEventEncoding returns the value of ScheduledEventEncoding if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetScheduledEventEncoding() (o string) {
	if v != nil && v.ScheduledEventEncoding != nil {
		return *v.ScheduledEventEncoding
	}

	return
}

// IsSetScheduledEventEncoding returns true if ScheduledEventEncoding is not nil.
func (v *ActivityInfo) IsSetScheduledEventEncoding() bool {
	return v != nil && v.ScheduledEventEncoding != nil
}

// GetScheduledTimeNanos returns the value of ScheduledTimeNanos if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetScheduledTimeNanos() (o int64) {
	if v != nil && v.ScheduledTimeNanos != nil {
		return *v.ScheduledTimeNanos
	}

	return
}

// IsSetScheduledTimeNanos returns true if ScheduledTimeNanos is not nil.
func (v *ActivityInfo) IsSetScheduledTimeNanos() bool {
	return v != nil && v.ScheduledTimeNanos != nil
}

// GetStartedID returns the value of StartedID if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetStartedID() (o int64) {
	if v != nil && v.StartedID != nil {
		return *v.StartedID
	}

	return
}

// IsSetStartedID returns true if StartedID is not nil.
func (v *ActivityInfo) IsSetStartedID() bool {
	return v != nil && v.StartedID != nil
}

// GetStartedEvent returns the value of StartedEvent if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetStartedEvent() (o []byte) {
	if v != nil && v.StartedEvent != nil {
		return v.StartedEvent
	}

	return
}

// IsSetStartedEvent returns true if StartedEvent is not nil.
func (v *ActivityInfo) IsSetStartedEvent() bool {
	return v != nil && v.StartedEvent != nil
}

// GetStartedEventEncoding returns the value of StartedEventEncoding if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetStartedEventEncoding() (o string) {
	if v != nil && v.StartedEventEncoding != nil {
		return *v.StartedEventEncoding
	}

	return
}

// IsSetStartedEventEncoding returns true if StartedEventEncoding is not nil.
func (v *ActivityInfo) IsSetStartedEventEncoding() bool {
	return v != nil && v.StartedEventEncoding != nil
}

// GetStartedTimeNanos returns the value of StartedTimeNanos if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetStartedTimeNanos() (o int64) {
	if v != nil && v.StartedTimeNanos != nil {
		return *v.StartedTimeNanos
	}

	return
}

// IsSetStartedTimeNanos returns true if StartedTimeNanos is not nil.
func (v *ActivityInfo) IsSetStartedTimeNanos() bool {
	return v != nil && v.StartedTimeNanos != nil
}

// GetActivityID returns the value of ActivityID if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetActivityID() (o string) {
	if v != nil && v.ActivityID != nil {
		return *v.ActivityID
	}

	return
}

// IsSetActivityID returns true if ActivityID is not nil.
func (v *ActivityInfo) IsSetActivityID() bool {
	return v != nil && v.ActivityID != nil
}

// GetRequestID returns the value of RequestID if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRequestID() (o string) {
	if v != nil && v.RequestID != nil {
		return *v.RequestID
	}

	return
}

// IsSetRequestID returns true if RequestID is not nil.
func (v *ActivityInfo) IsSetRequestID() bool {
	return v != nil && v.RequestID != nil
}

// GetScheduleToStartTimeoutSeconds returns the value of ScheduleToStartTimeoutSeconds if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetScheduleToStartTimeoutSeconds() (o int32) {
	if v != nil && v.ScheduleToStartTimeoutSeconds != nil {
		return *v.ScheduleToStartTimeoutSeconds
	}

	return
}

// IsSetScheduleToStartTimeoutSeconds returns true if ScheduleToStartTimeoutSeconds is not nil.
func (v *ActivityInfo) IsSetScheduleToStartTimeoutSeconds() bool {
	return v != nil && v.ScheduleToStartTimeoutSeconds != nil
}

// GetScheduleToCloseTimeoutSeconds returns the value of ScheduleToCloseTimeoutSeconds if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetScheduleToCloseTimeoutSeconds() (o int32) {
	if v != nil && v.ScheduleToCloseTimeoutSeconds != nil {
		return *v.ScheduleToCloseTimeoutSeconds
	}

	return
}

// IsSetScheduleToCloseTimeoutSeconds returns true if ScheduleToCloseTimeoutSeconds is not nil.
func (v *ActivityInfo) IsSetScheduleToCloseTimeoutSeconds() bool {
	return v != nil && v.ScheduleToCloseTimeoutSeconds != nil
}

// GetStartToCloseTimeoutSeconds returns the value of StartToCloseTimeoutSeconds if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetStartToCloseTimeoutSeconds() (o int32) {
	if v != nil && v.StartToCloseTimeoutSeconds != nil {
		return *v.StartToCloseTimeoutSeconds
	}

	return
}

// IsSetStartToCloseTimeoutSeconds returns true if StartToCloseTimeoutSeconds is not nil.
func (v *ActivityInfo) IsSetStartToCloseTimeoutSeconds() bool {
	return v != nil && v.StartToCloseTimeoutSeconds != nil
}

// GetHeartbeatTimeoutSeconds returns the value of HeartbeatTimeoutSeconds if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetHeartbeatTimeoutSeconds() (o int32) {
	if v != nil && v.HeartbeatTimeoutSeconds != nil {
		return *v.HeartbeatTimeoutSeconds
	}

	return
}

// IsSetHeartbeatTimeoutSeconds returns true if HeartbeatTimeoutSeconds is not nil.
func (v *ActivityInfo) IsSetHeartbeatTimeoutSeconds() bool {
	return v != nil && v.HeartbeatTimeoutSeconds != nil
}

// GetCancelRequested returns the value of CancelRequested if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetCancelRequested() (o bool) {
	if v != nil && v.CancelRequested != nil {
		return *v.CancelRequested
	}

	return
}

// IsSetCancelRequested returns true if CancelRequested is not nil.
func (v *ActivityInfo) IsSetCancelRequested() bool {
	return v != nil && v.CancelRequested != nil
}

// GetCancelRequestID returns the value of CancelRequestID if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetCancelRequestID() (o int64) {
	if v != nil && v.CancelRequestID != nil {
		return *v.CancelRequestID
	}

	return
}

// IsSetCancelRequestID returns true if CancelRequestID is not nil.
func (v *ActivityInfo) IsSetCancelRequestID() bool {
	return v != nil && v.CancelRequestID != nil
}

// GetTimerTaskStatus returns the value of TimerTaskStatus if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetTimerTaskStatus() (o int32) {
	if v != nil && v.TimerTaskStatus != nil {
		return *v.TimerTaskStatus
	}

	return
}

// IsSetTimerTaskStatus returns true if TimerTaskStatus is not nil.
func (v *ActivityInfo) IsSetTimerTaskStatus() bool {
	return v != nil && v.TimerTaskStatus != nil
}

// GetAttempt returns the value of Attempt if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetAttempt() (o int32) {
	if v != nil && v.Attempt != nil {
		return *v.Attempt
	}

	return
}

// IsSetAttempt returns true if Attempt is not nil.
func (v *ActivityInfo) IsSetAttempt() bool {
	return v != nil && v.Attempt != nil
}

// GetTaskList returns the value of TaskList if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetTaskList() (o string) {
	if v != nil && v.TaskList != nil {
		return *v.TaskList
	}

	return
}

// IsSetTaskList returns true if TaskList is not nil.
func (v *ActivityInfo) IsSetTaskList() bool {
	return v != nil && v.TaskList != nil
}

// GetStartedIdentity returns the value of StartedIdentity if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetStartedIdentity() (o string) {
	if v != nil && v.StartedIdentity != nil {
		return *v.StartedIdentity
	}

	return
}

// IsSetStartedIdentity returns true if StartedIdentity is not nil.
func (v *ActivityInfo) IsSetStartedIdentity() bool {
	return v != nil && v.StartedIdentity != nil
}

// GetHasRetryPolicy returns the value of HasRetryPolicy if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetHasRetryPolicy() (o bool) {
	if v != nil && v.HasRetryPolicy != nil {
		return *v.HasRetryPolicy
	}

	return
}

// IsSetHasRetryPolicy returns true if HasRetryPolicy is not nil.
func (v *ActivityInfo) IsSetHasRetryPolicy() bool {
	return v != nil && v.HasRetryPolicy != nil
}

// GetRetryInitialIntervalSeconds returns the value of RetryInitialIntervalSeconds if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryInitialIntervalSeconds() (o int32) {
	if v != nil && v.RetryInitialIntervalSeconds != nil {
		return *v.RetryInitialIntervalSeconds
	}

	return
}

// IsSetRetryInitialIntervalSeconds returns true if RetryInitialIntervalSeconds is not nil.
func (v *ActivityInfo) IsSetRetryInitialIntervalSeconds() bool {
	return v != nil && v.RetryInitialIntervalSeconds != nil
}

// GetRetryMaximumIntervalSeconds returns the value of RetryMaximumIntervalSeconds if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryMaximumIntervalSeconds() (o int32) {
	if v != nil && v.RetryMaximumIntervalSeconds != nil {
		return *v.RetryMaximumIntervalSeconds
	}

	return
}

// IsSetRetryMaximumIntervalSeconds returns true if RetryMaximumIntervalSeconds is not nil.
func (v *ActivityInfo) IsSetRetryMaximumIntervalSeconds() bool {
	return v != nil && v.RetryMaximumIntervalSeconds != nil
}

// GetRetryMaximumAttempts returns the value of RetryMaximumAttempts if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryMaximumAttempts() (o int32) {
	if v != nil && v.RetryMaximumAttempts != nil {
		return *v.RetryMaximumAttempts
	}

	return
}

// IsSetRetryMaximumAttempts returns true if RetryMaximumAttempts is not nil.
func (v *ActivityInfo) IsSetRetryMaximumAttempts() bool {
	return v != nil && v.RetryMaximumAttempts != nil
}

// GetRetryExpirationTimeNanos returns the value of RetryExpirationTimeNanos if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryExpirationTimeNanos() (o int64) {
	if v != nil && v.RetryExpirationTimeNanos != nil {
		return *v.RetryExpirationTimeNanos
	}

	return
}

// IsSetRetryExpirationTimeNanos returns true if RetryExpirationTimeNanos is not nil.
func (v *ActivityInfo) IsSetRetryExpirationTimeNanos() bool {
	return v != nil && v.RetryExpirationTimeNanos != nil
}

// GetRetryBackoffCoefficient returns the value of RetryBackoffCoefficient if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryBackoffCoefficient() (o float64) {
	if v != nil && v.RetryBackoffCoefficient != nil {
		return *v.RetryBackoffCoefficient
	}

	return
}

// IsSetRetryBackoffCoefficient returns true if RetryBackoffCoefficient is not nil.
func (v *ActivityInfo) IsSetRetryBackoffCoefficient() bool {
	return v != nil && v.RetryBackoffCoefficient != nil
}

// GetRetryNonRetryableErrors returns the value of RetryNonRetryableErrors if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryNonRetryableErrors() (o []string) {
	if v != nil && v.RetryNonRetryableErrors != nil {
		return v.RetryNonRetryableErrors
	}

	return
}

// IsSetRetryNonRetryableErrors returns true if RetryNonRetryableErrors is not nil.
func (v *ActivityInfo) IsSetRetryNonRetryableErrors() bool {
	return v != nil && v.RetryNonRetryableErrors != nil
}

// GetRetryLastFailureReason returns the value of RetryLastFailureReason if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryLastFailureReason() (o string) {
	if v != nil && v.RetryLastFailureReason != nil {
		return *v.RetryLastFailureReason
	}

	return
}

// IsSetRetryLastFailureReason returns true if RetryLastFailureReason is not nil.
func (v *ActivityInfo) IsSetRetryLastFailureReason() bool {
	return v != nil && v.RetryLastFailureReason != nil
}

// GetRetryLastWorkerIdentity returns the value of RetryLastWorkerIdentity if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryLastWorkerIdentity() (o string) {
	if v != nil && v.RetryLastWorkerIdentity != nil {
		return *v.RetryLastWorkerIdentity
	}

	return
}

// IsSetRetryLastWorkerIdentity returns true if RetryLastWorkerIdentity is not nil.
func (v *ActivityInfo) IsSetRetryLastWorkerIdentity() bool {
	return v != nil && v.RetryLastWorkerIdentity != nil
}

// GetRetryLastFailureDetails returns the value of RetryLastFailureDetails if it is set or its
// zero value if it is unset.
func (v *ActivityInfo) GetRetryLastFailureDetails() (o []byte) {
	if v != nil && v.RetryLastFailureDetails != nil {
		return v.RetryLastFailureDetails
	}

	return
}

// IsSetRetryLastFailureDetails returns true if RetryLastFailureDetails is not nil.
func (v *ActivityInfo) IsSetRetryLastFailureDetails() bool {
	return v != nil && v.RetryLastFailureDetails != nil
}

type ChildExecutionInfo struct {
	Version                *int64  `json:"version,omitempty"`
	InitiatedEventBatchID  *int64  `json:"initiatedEventBatchID,omitempty"`
	StartedID              *int64  `json:"startedID,omitempty"`
	InitiatedEvent         []byte  `json:"initiatedEvent,omitempty"`
	InitiatedEventEncoding *string `json:"initiatedEventEncoding,omitempty"`
	StartedWorkflowID      *string `json:"startedWorkflowID,omitempty"`
	StartedRunID           []byte  `json:"startedRunID,omitempty"`
	StartedEvent           []byte  `json:"startedEvent,omitempty"`
	StartedEventEncoding   *string `json:"startedEventEncoding,omitempty"`
	CreateRequestID        *string `json:"createRequestID,omitempty"`
	DomainName             *string `json:"domainName,omitempty"`
	WorkflowTypeName       *string `json:"workflowTypeName,omitempty"`
	ParentClosePolicy      *int32  `json:"parentClosePolicy,omitempty"`
}

// ToWire translates a ChildExecutionInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ChildExecutionInfo) ToWire() (wire.Value, error) {
	var (
		fields [13]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Version != nil {
		w, err = wire.NewValueI64(*(v.Version)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.InitiatedEventBatchID != nil {
		w, err = wire.NewValueI64(*(v.InitiatedEventBatchID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.StartedID != nil {
		w, err = wire.NewValueI64(*(v.StartedID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.InitiatedEvent != nil {
		w, err = wire.NewValueBinary(v.InitiatedEvent), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.InitiatedEventEncoding != nil {
		w, err = wire.NewValueString(*(v.InitiatedEventEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}
	if v.StartedWorkflowID != nil {
		w, err = wire.NewValueString(*(v.StartedWorkflowID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.StartedRunID != nil {
		w, err = wire.NewValueBinary(v.StartedRunID), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 22, Value: w}
		i++
	}
	if v.StartedEvent != nil {
		w, err = wire.NewValueBinary(v.StartedEvent), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 24, Value: w}
		i++
	}
	if v.StartedEventEncoding != nil {
		w, err = wire.NewValueString(*(v.StartedEventEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 26, Value: w}
		i++
	}
	if v.CreateRequestID != nil {
		w, err = wire.NewValueString(*(v.CreateRequestID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 28, Value: w}
		i++
	}
	if v.DomainName != nil {
		w, err = wire.NewValueString(*(v.DomainName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.WorkflowTypeName != nil {
		w, err = wire.NewValueString(*(v.WorkflowTypeName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 32, Value: w}
		i++
	}
	if v.ParentClosePolicy != nil {
		w, err = wire.NewValueI32(*(v.ParentClosePolicy)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 35, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ChildExecutionInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ChildExecutionInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ChildExecutionInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ChildExecutionInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Version = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.InitiatedEventBatchID = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.StartedID = &x
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TBinary {
				v.InitiatedEvent, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.InitiatedEventEncoding = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StartedWorkflowID = &x
				if err != nil {
					return err
				}

			}
		case 22:
			if field.Value.Type() == wire.TBinary {
				v.StartedRunID, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 24:
			if field.Value.Type() == wire.TBinary {
				v.StartedEvent, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 26:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StartedEventEncoding = &x
				if err != nil {
					return err
				}

			}
		case 28:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.CreateRequestID = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.DomainName = &x
				if err != nil {
					return err
				}

			}
		case 32:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.WorkflowTypeName = &x
				if err != nil {
					return err
				}

			}
		case 35:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ParentClosePolicy = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ChildExecutionInfo
// struct.
func (v *ChildExecutionInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [13]string
	i := 0
	if v.Version != nil {
		fields[i] = fmt.Sprintf("Version: %v", *(v.Version))
		i++
	}
	if v.InitiatedEventBatchID != nil {
		fields[i] = fmt.Sprintf("InitiatedEventBatchID: %v", *(v.InitiatedEventBatchID))
		i++
	}
	if v.StartedID != nil {
		fields[i] = fmt.Sprintf("StartedID: %v", *(v.StartedID))
		i++
	}
	if v.InitiatedEvent != nil {
		fields[i] = fmt.Sprintf("InitiatedEvent: %v", v.InitiatedEvent)
		i++
	}
	if v.InitiatedEventEncoding != nil {
		fields[i] = fmt.Sprintf("InitiatedEventEncoding: %v", *(v.InitiatedEventEncoding))
		i++
	}
	if v.StartedWorkflowID != nil {
		fields[i] = fmt.Sprintf("StartedWorkflowID: %v", *(v.StartedWorkflowID))
		i++
	}
	if v.StartedRunID != nil {
		fields[i] = fmt.Sprintf("StartedRunID: %v", v.StartedRunID)
		i++
	}
	if v.StartedEvent != nil {
		fields[i] = fmt.Sprintf("StartedEvent: %v", v.StartedEvent)
		i++
	}
	if v.StartedEventEncoding != nil {
		fields[i] = fmt.Sprintf("StartedEventEncoding: %v", *(v.StartedEventEncoding))
		i++
	}
	if v.CreateRequestID != nil {
		fields[i] = fmt.Sprintf("CreateRequestID: %v", *(v.CreateRequestID))
		i++
	}
	if v.DomainName != nil {
		fields[i] = fmt.Sprintf("DomainName: %v", *(v.DomainName))
		i++
	}
	if v.WorkflowTypeName != nil {
		fields[i] = fmt.Sprintf("WorkflowTypeName: %v", *(v.WorkflowTypeName))
		i++
	}
	if v.ParentClosePolicy != nil {
		fields[i] = fmt.Sprintf("ParentClosePolicy: %v", *(v.ParentClosePolicy))
		i++
	}

	return fmt.Sprintf("ChildExecutionInfo{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ChildExecutionInfo match the
// provided ChildExecutionInfo.
//
// This function performs a deep comparison.
func (v *ChildExecutionInfo) Equals(rhs *ChildExecutionInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Version, rhs.Version) {
		return false
	}
	if !_I64_EqualsPtr(v.InitiatedEventBatchID, rhs.InitiatedEventBatchID) {
		return false
	}
	if !_I64_EqualsPtr(v.StartedID, rhs.StartedID) {
		return false
	}
	if !((v.InitiatedEvent == nil && rhs.InitiatedEvent == nil) || (v.InitiatedEvent != nil && rhs.InitiatedEvent != nil && bytes.Equal(v.InitiatedEvent, rhs.InitiatedEvent))) {
		return false
	}
	if !_String_EqualsPtr(v.InitiatedEventEncoding, rhs.InitiatedEventEncoding) {
		return false
	}
	if !_String_EqualsPtr(v.StartedWorkflowID, rhs.StartedWorkflowID) {
		return false
	}
	if !((v.StartedRunID == nil && rhs.StartedRunID == nil) || (v.StartedRunID != nil && rhs.StartedRunID != nil && bytes.Equal(v.StartedRunID, rhs.StartedRunID))) {
		return false
	}
	if !((v.StartedEvent == nil && rhs.StartedEvent == nil) || (v.StartedEvent != nil && rhs.StartedEvent != nil && bytes.Equal(v.StartedEvent, rhs.StartedEvent))) {
		return false
	}
	if !_String_EqualsPtr(v.StartedEventEncoding, rhs.StartedEventEncoding) {
		return false
	}
	if !_String_EqualsPtr(v.CreateRequestID, rhs.CreateRequestID) {
		return false
	}
	if !_String_EqualsPtr(v.DomainName, rhs.DomainName) {
		return false
	}
	if !_String_EqualsPtr(v.WorkflowTypeName, rhs.WorkflowTypeName) {
		return false
	}
	if !_I32_EqualsPtr(v.ParentClosePolicy, rhs.ParentClosePolicy) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ChildExecutionInfo.
func (v *ChildExecutionInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Version != nil {
		enc.AddInt64("version", *v.Version)
	}
	if v.InitiatedEventBatchID != nil {
		enc.AddInt64("initiatedEventBatchID", *v.InitiatedEventBatchID)
	}
	if v.StartedID != nil {
		enc.AddInt64("startedID", *v.StartedID)
	}
	if v.InitiatedEvent != nil {
		enc.AddString("initiatedEvent", base64.StdEncoding.EncodeToString(v.InitiatedEvent))
	}
	if v.InitiatedEventEncoding != nil {
		enc.AddString("initiatedEventEncoding", *v.InitiatedEventEncoding)
	}
	if v.StartedWorkflowID != nil {
		enc.AddString("startedWorkflowID", *v.StartedWorkflowID)
	}
	if v.StartedRunID != nil {
		enc.AddString("startedRunID", base64.StdEncoding.EncodeToString(v.StartedRunID))
	}
	if v.StartedEvent != nil {
		enc.AddString("startedEvent", base64.StdEncoding.EncodeToString(v.StartedEvent))
	}
	if v.StartedEventEncoding != nil {
		enc.AddString("startedEventEncoding", *v.StartedEventEncoding)
	}
	if v.CreateRequestID != nil {
		enc.AddString("createRequestID", *v.CreateRequestID)
	}
	if v.DomainName != nil {
		enc.AddString("domainName", *v.DomainName)
	}
	if v.WorkflowTypeName != nil {
		enc.AddString("workflowTypeName", *v.WorkflowTypeName)
	}
	if v.ParentClosePolicy != nil {
		enc.AddInt32("parentClosePolicy", *v.ParentClosePolicy)
	}
	return err
}

// GetVersion returns the value of Version if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetVersion() (o int64) {
	if v != nil && v.Version != nil {
		return *v.Version
	}

	return
}

// IsSetVersion returns true if Version is not nil.
func (v *ChildExecutionInfo) IsSetVersion() bool {
	return v != nil && v.Version != nil
}

// GetInitiatedEventBatchID returns the value of InitiatedEventBatchID if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetInitiatedEventBatchID() (o int64) {
	if v != nil && v.InitiatedEventBatchID != nil {
		return *v.InitiatedEventBatchID
	}

	return
}

// IsSetInitiatedEventBatchID returns true if InitiatedEventBatchID is not nil.
func (v *ChildExecutionInfo) IsSetInitiatedEventBatchID() bool {
	return v != nil && v.InitiatedEventBatchID != nil
}

// GetStartedID returns the value of StartedID if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetStartedID() (o int64) {
	if v != nil && v.StartedID != nil {
		return *v.StartedID
	}

	return
}

// IsSetStartedID returns true if StartedID is not nil.
func (v *ChildExecutionInfo) IsSetStartedID() bool {
	return v != nil && v.StartedID != nil
}

// GetInitiatedEvent returns the value of InitiatedEvent if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetInitiatedEvent() (o []byte) {
	if v != nil && v.InitiatedEvent != nil {
		return v.InitiatedEvent
	}

	return
}

// IsSetInitiatedEvent returns true if InitiatedEvent is not nil.
func (v *ChildExecutionInfo) IsSetInitiatedEvent() bool {
	return v != nil && v.InitiatedEvent != nil
}

// GetInitiatedEventEncoding returns the value of InitiatedEventEncoding if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetInitiatedEventEncoding() (o string) {
	if v != nil && v.InitiatedEventEncoding != nil {
		return *v.InitiatedEventEncoding
	}

	return
}

// IsSetInitiatedEventEncoding returns true if InitiatedEventEncoding is not nil.
func (v *ChildExecutionInfo) IsSetInitiatedEventEncoding() bool {
	return v != nil && v.InitiatedEventEncoding != nil
}

// GetStartedWorkflowID returns the value of StartedWorkflowID if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetStartedWorkflowID() (o string) {
	if v != nil && v.StartedWorkflowID != nil {
		return *v.StartedWorkflowID
	}

	return
}

// IsSetStartedWorkflowID returns true if StartedWorkflowID is not nil.
func (v *ChildExecutionInfo) IsSetStartedWorkflowID() bool {
	return v != nil && v.StartedWorkflowID != nil
}

// GetStartedRunID returns the value of StartedRunID if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetStartedRunID() (o []byte) {
	if v != nil && v.StartedRunID != nil {
		return v.StartedRunID
	}

	return
}

// IsSetStartedRunID returns true if StartedRunID is not nil.
func (v *ChildExecutionInfo) IsSetStartedRunID() bool {
	return v != nil && v.StartedRunID != nil
}

// GetStartedEvent returns the value of StartedEvent if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetStartedEvent() (o []byte) {
	if v != nil && v.StartedEvent != nil {
		return v.StartedEvent
	}

	return
}

// IsSetStartedEvent returns true if StartedEvent is not nil.
func (v *ChildExecutionInfo) IsSetStartedEvent() bool {
	return v != nil && v.StartedEvent != nil
}

// GetStartedEventEncoding returns the value of StartedEventEncoding if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetStartedEventEncoding() (o string) {
	if v != nil && v.StartedEventEncoding != nil {
		return *v.StartedEventEncoding
	}

	return
}

// IsSetStartedEventEncoding returns true if StartedEventEncoding is not nil.
func (v *ChildExecutionInfo) IsSetStartedEventEncoding() bool {
	return v != nil && v.StartedEventEncoding != nil
}

// GetCreateRequestID returns the value of CreateRequestID if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetCreateRequestID() (o string) {
	if v != nil && v.CreateRequestID != nil {
		return *v.CreateRequestID
	}

	return
}

// IsSetCreateRequestID returns true if CreateRequestID is not nil.
func (v *ChildExecutionInfo) IsSetCreateRequestID() bool {
	return v != nil && v.CreateRequestID != nil
}

// GetDomainName returns the value of DomainName if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetDomainName() (o string) {
	if v != nil && v.DomainName != nil {
		return *v.DomainName
	}

	return
}

// IsSetDomainName returns true if DomainName is not nil.
func (v *ChildExecutionInfo) IsSetDomainName() bool {
	return v != nil && v.DomainName != nil
}

// GetWorkflowTypeName returns the value of WorkflowTypeName if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetWorkflowTypeName() (o string) {
	if v != nil && v.WorkflowTypeName != nil {
		return *v.WorkflowTypeName
	}

	return
}

// IsSetWorkflowTypeName returns true if WorkflowTypeName is not nil.
func (v *ChildExecutionInfo) IsSetWorkflowTypeName() bool {
	return v != nil && v.WorkflowTypeName != nil
}

// GetParentClosePolicy returns the value of ParentClosePolicy if it is set or its
// zero value if it is unset.
func (v *ChildExecutionInfo) GetParentClosePolicy() (o int32) {
	if v != nil && v.ParentClosePolicy != nil {
		return *v.ParentClosePolicy
	}

	return
}

// IsSetParentClosePolicy returns true if ParentClosePolicy is not nil.
func (v *ChildExecutionInfo) IsSetParentClosePolicy() bool {
	return v != nil && v.ParentClosePolicy != nil
}

type DomainInfo struct {
	Name                        *string           `json:"name,omitempty"`
	Description                 *string           `json:"description,omitempty"`
	Owner                       *string           `json:"owner,omitempty"`
	Status                      *int32            `json:"status,omitempty"`
	RetentionDays               *int16            `json:"retentionDays,omitempty"`
	EmitMetric                  *bool             `json:"emitMetric,omitempty"`
	ArchivalBucket              *string           `json:"archivalBucket,omitempty"`
	ArchivalStatus              *int16            `json:"archivalStatus,omitempty"`
	ConfigVersion               *int64            `json:"configVersion,omitempty"`
	NotificationVersion         *int64            `json:"notificationVersion,omitempty"`
	FailoverNotificationVersion *int64            `json:"failoverNotificationVersion,omitempty"`
	FailoverVersion             *int64            `json:"failoverVersion,omitempty"`
	ActiveClusterName           *string           `json:"activeClusterName,omitempty"`
	Clusters                    []string          `json:"clusters,omitempty"`
	Data                        map[string]string `json:"data,omitempty"`
	BadBinaries                 []byte            `json:"badBinaries,omitempty"`
	BadBinariesEncoding         *string           `json:"badBinariesEncoding,omitempty"`
	HistoryArchivalStatus       *int16            `json:"historyArchivalStatus,omitempty"`
	HistoryArchivalURI          *string           `json:"historyArchivalURI,omitempty"`
	VisibilityArchivalStatus    *int16            `json:"visibilityArchivalStatus,omitempty"`
	VisibilityArchivalURI       *string           `json:"visibilityArchivalURI,omitempty"`
}

type _Map_String_String_MapItemList map[string]string

func (m _Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) Close() {}

// ToWire translates a DomainInfo struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *DomainInfo) ToWire() (wire.Value, error) {
	var (
		fields [21]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Name != nil {
		w, err = wire.NewValueString(*(v.Name)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Description != nil {
		w, err = wire.NewValueString(*(v.Description)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	if v.Owner != nil {
		w, err = wire.NewValueString(*(v.Owner)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}
	if v.Status != nil {
		w, err = wire.NewValueI32(*(v.Status)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.RetentionDays != nil {
		w, err = wire.NewValueI16(*(v.RetentionDays)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}
	if v.EmitMetric != nil {
		w, err = wire.NewValueBool(*(v.EmitMetric)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.ArchivalBucket != nil {
		w, err = wire.NewValueString(*(v.ArchivalBucket)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 22, Value: w}
		i++
	}
	if v.ArchivalStatus != nil {
		w, err = wire.NewValueI16(*(v.ArchivalStatus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 24, Value: w}
		i++
	}
	if v.ConfigVersion != nil {
		w, err = wire.NewValueI64(*(v.ConfigVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 26, Value: w}
		i++
	}
	if v.NotificationVersion != nil {
		w, err = wire.NewValueI64(*(v.NotificationVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 28, Value: w}
		i++
	}
	if v.FailoverNotificationVersion != nil {
		w, err = wire.NewValueI64(*(v.FailoverNotificationVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 30, Value: w}
		i++
	}
	if v.FailoverVersion != nil {
		w, err = wire.NewValueI64(*(v.FailoverVersion)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 32, Value: w}
		i++
	}
	if v.ActiveClusterName != nil {
		w, err = wire.NewValueString(*(v.ActiveClusterName)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 34, Value: w}
		i++
	}
	if v.Clusters != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.Clusters)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 36, Value: w}
		i++
	}
	if v.Data != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Data)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 38, Value: w}
		i++
	}
	if v.BadBinaries != nil {
		w, err = wire.NewValueBinary(v.BadBinaries), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 39, Value: w}
		i++
	}
	if v.BadBinariesEncoding != nil {
		w, err = wire.NewValueString(*(v.BadBinariesEncoding)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 40, Value: w}
		i++
	}
	if v.HistoryArchivalStatus != nil {
		w, err = wire.NewValueI16(*(v.HistoryArchivalStatus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 42, Value: w}
		i++
	}
	if v.HistoryArchivalURI != nil {
		w, err = wire.NewValueString(*(v.HistoryArchivalURI)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 44, Value: w}
		i++
	}
	if v.VisibilityArchivalStatus != nil {
		w, err = wire.NewValueI16(*(v.VisibilityArchivalStatus)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 46, Value: w}
		i++
	}
	if v.VisibilityArchivalURI != nil {
		w, err = wire.NewValueString(*(v.VisibilityArchivalURI)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 48, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_String_String_Read(m wire.MapItemList) (map[string]string, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a DomainInfo struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a DomainInfo struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v DomainInfo
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *DomainInfo) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 10:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Name = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Description = &x
				if err != nil {
					return err
				}

			}
		case 14:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Owner = &x
				if err != nil {
					return err
				}

			}
		case 16:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Status = &x
				if err != nil {
					return err
				}

			}
		case 18:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.RetentionDays = &x
				if err != nil {
					return err
				}

			}
		case 20:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.EmitMetric = &x
				if err != nil {
					return err
				}

			}
		case 22:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ArchivalBucket = &x
				if err != nil {
					return err
				}

			}
		case 24:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.ArchivalStatus = &x
				if err != nil {
					return err
				}

			}
		case 26:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.ConfigVersion = &x
				if err != nil {
					return err
				}

			}
		case 28:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.NotificationVersion = &x
				if err != nil {
					return err
				}

			}
		case 30:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.FailoverNotificationVersion = &x
				if err != nil {
					return err
				}

			}
		case 32:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.FailoverVersion = &x
				if err != nil {
					return err
				}

			}
		case 34:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.ActiveClusterName = &x
				if err != nil {
					return err
				}

			}
		case 36:
			if field.Value.Type() == wire.TList {
				v.Clusters, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 38:
			if field.Value.Type() == wire.TMap {
				v.Data, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 39:
			if field.Value.Type() == wire.TBinary {
				v.BadBinaries, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		case 40:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.BadBinariesEncoding = &x
				if err != nil {
					return err
				}

			}
		case 42:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.HistoryArchivalStatus = &x
				if err != nil {
					return err
				}

			}
		case 44:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.HistoryArchivalURI = &x
				if err != nil {
					return err
				}

			}
		case 46:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.VisibilityArchivalStatus = &x
				if err != nil {
					return err
				}

			}
		case 48:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.VisibilityArchivalURI = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a DomainInfo
// struct.
func (v *DomainInfo) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [21]string
	i := 0
	if v.Name != nil {
		fields[i] = fmt.Sprintf("Name: %v", *(v.Name))
		i++
	}
	if v.Description != nil {
		fields[i] = fmt.Sprintf("Description: %v", *(v.Description))
		i++
	}
	if v.Owner != nil {
		fields[i] = fmt.Sprintf("Owner: %v", *(v.Owner))
		i++
	}
	if v.Status != nil {
		fields[i] = fmt.Sprintf("Status: %v", *(v.Status))
		i++
	}
	if v.RetentionDays != nil {
		fields[i] = fmt.Sprintf("RetentionDays: %v", *(v.RetentionDays))
		i++
	}
	if v.EmitMetric != nil {
		fields[i] = fmt.Sprintf("EmitMetric: %v", *(v.EmitMetric))
		i++
	}
	if v.ArchivalBucket != nil {
		fields[i] = fmt.Sprintf("ArchivalBucket: %v", *(v.ArchivalBucket))
		i++
	}
	if v.ArchivalStatus != nil {
		fields[i] = fmt.Sprintf("ArchivalStatus: %v", *(v.ArchivalStatus))
		i++
	}
	if v.ConfigVersion != nil {
		fields[i] = fmt.Sprintf("ConfigVersion: %v", *(v.ConfigVersion))
		i++
	}
	if v.NotificationVersion != nil {
		fields[i] = fmt.Sprintf("NotificationVersion: %v", *(v.NotificationVersion))
		i++
	}
	if v.FailoverNotificationVersion != nil {
		fields[i] = fmt.Sprintf("FailoverNotificationVersion: %v", *(v.FailoverNotificationVersion))
		i++
	}
	if v.FailoverVersion != nil {
		fields[i] = fmt.Sprintf("FailoverVersion: %v", *(v.FailoverVersion))
		i++
	}
	if v.ActiveClusterName != nil {
		fields[i] = fmt.Sprintf("ActiveClusterName: %v", *(v.ActiveClusterName))
		i++
	}
	if v.Clusters != nil {
		fields[i] = fmt.Sprintf("Clusters: %v", v.Clusters)
		i++
	}
	if v.Data != nil {
		fields[i] = fmt.Sprintf("Data: %v", v.Data)
		i++
	}
	if v.BadBinaries != nil {
		fields[i] = fmt.Sprintf("BadBinaries: %v", v.BadBinaries)
		i++
	}
	if v.BadBinariesEncoding != nil {
		fields[i] = fmt.Sprintf("BadBinariesEncoding: %v", *(v.BadBinariesEncoding))
		i++
	}
	if v.HistoryArchivalStatus != nil {
		fields[i] = fmt.Sprintf("HistoryArchivalStatus: %v", *(v.HistoryArchivalStatus))
		i++
	}
	if v.HistoryArchivalURI != nil {
		fields[i] = fmt.Sprintf("HistoryArchivalURI: %v", *(v.HistoryArchivalURI))
		i++
	}
	if v.VisibilityArchivalStatus != nil {
		fields[i] = fmt.Sprintf("VisibilityArchivalStatus: %v", *(v.VisibilityArchivalStatus))
		i++
	}
	if v.VisibilityArchivalURI != nil {
		fields[i] = fmt.Sprintf("VisibilityArchivalURI: %v", *(v.VisibilityArchivalURI))
		i++
	}

	return fmt.Sprintf("DomainInfo{%v}", strings.Join(fields[:i], ", "))
}

func _I16_EqualsPtr(lhs, rhs *int16) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Map_String_String_Equals(lhs, rhs map[string]string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this DomainInfo match the
// provided DomainInfo.
//
// This function performs a deep comparison.
func (v *DomainInfo) Equals(rhs *DomainInfo) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Name, rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.Description, rhs.Description) {
		return false
	}
	if !_String_EqualsPtr(v.Owner, rhs.Owner) {
		return false
	}
	if !_I32_EqualsPtr(v.Status, rhs.Status) {
		return false
	}
	if !_I16_EqualsPtr(v.RetentionDays, rhs.RetentionDays) {
		return false
	}
	if !_Bool_EqualsPtr(v.EmitMetric, rhs.EmitMetric) {
		return false
	}
	if !_String_EqualsPtr(v.ArchivalBucket, rhs.ArchivalBucket) {
		return false
	}
	if !_I16_EqualsPtr(v.ArchivalStatus, rhs.ArchivalStatus) {
		return false
	}
	if !_I64_EqualsPtr(v.ConfigVersion, rhs.ConfigVersion) {
		return false
	}
	if !_I64_EqualsPtr(v.NotificationVersion, rhs.NotificationVersion) {
		return false
	}
	if !_I64_EqualsPtr(v.FailoverNotificationVersion, rhs.FailoverNotificationVersion) {
		return false
	}
	if !_I64_EqualsPtr(v.FailoverVersion, rhs.FailoverVersion) {
		return false
	}
	if !_String_EqualsPtr(v.ActiveClusterName, rhs.ActiveClusterName) {
		return false
	}
	if !((v.Clusters == nil && rhs.Clusters == nil) || (v.Clusters != nil && rhs.Clusters != nil && _List_String_Equals(v.Clusters, rhs.Clusters))) {
		return false
	}
	if !((v.Data == nil && rhs.Data == nil) || (v.Data != nil && rhs.Data != nil && _Map_String_String_Equals(v.Data, rhs.Data))) {
		return false
	}
	if !((v.BadBinaries == nil && rhs.BadBinaries == nil) || (v.BadBinaries != nil && rhs.BadBinaries != nil && bytes.Equal(v.BadBinaries, rhs.BadBinaries))) {
		return false
	}
	if !_String_EqualsPtr(v.BadBinariesEncoding, rhs.BadBinariesEncoding) {
		return false
	}
	if !_I16_EqualsPtr(v.HistoryArchivalStatus, rhs.HistoryArchivalStatus) {
		return false
	}
	if !_String_EqualsPtr(v.HistoryArchivalURI, rhs.HistoryArchivalURI) {
		return false
	}
	if !_I16_EqualsPtr(v.VisibilityArchivalStatus, rhs.VisibilityArchivalStatus) {
		return false
	}
	if !_String_EqualsPtr(v.VisibilityArchivalURI, rhs.VisibilityArchivalURI) {
		return false
	}

	return true
}

type _Map_String_String_Zapper map[string]string

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_String_Zapper.
func (m _Map_String_String_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddString((string)(k), v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DomainInfo.
func (v *DomainInfo) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Name != nil {
		enc.AddString("name", *v.Name)
	}
	if v.Description != nil {
		enc.AddString("description", *v.Description)
	}
	if v.Owner != nil {
		enc.AddString("owner", *v.Owner)
	}
	if v.Status != nil {
		enc.AddInt32("status", *v.Status)
	}
	if v.RetentionDays != nil {
		enc.AddInt16("retentionDays", *v.RetentionDays)
	}
	if v.EmitMetric != nil {
		enc.AddBool("emitMetric", *v.EmitMetric)
	}
	if v.ArchivalBucket != nil {
		enc.AddString("archivalBucket", *v.ArchivalBucket)
	}
	if v.ArchivalStatus != nil {
		enc.AddInt16("archivalStatus", *v.ArchivalStatus)
	}
	if v.ConfigVersion != nil {
		enc.AddInt64("configVersion", *v.ConfigVersion)
	}
	if v.NotificationVersion != nil {
		enc.AddInt64("notificationVersion", *v.NotificationVersion)
	}
	if v.FailoverNotificationVersion != nil {
		enc.AddInt64("failoverNotificationVersion", *v.FailoverNotificationVersion)
	}
	if v.FailoverVersion != nil {
		enc.AddInt64("failoverVersion", *v.FailoverVersion)
	}
	if v.ActiveClusterName != nil {
		enc.AddString("activeClusterName", *v.ActiveClusterName)
	}
	if v.Clusters != nil {
		err = multierr.Append(err, enc.AddArray("clusters", (_List_String_Zapper)(v.Clusters)))
	}
	if v.Data != nil {
		err = multierr.Append(err, enc.AddObject("data", (_Map_String_String_Zapper)(v.Data)))
	}
	if v.BadBinaries != nil {
		enc.AddString("badBinaries", base64.StdEncoding.EncodeToString(v.BadBinaries))
	}
	if v.BadBinariesEncoding != nil {
		enc.AddString("badBinariesEncoding", *v.BadBinariesEncoding)
	}
	if v.HistoryArchivalStatus != nil {
		enc.AddInt16("historyArchivalStatus", *v.HistoryArchivalStatus)
	}
	if v.HistoryArchivalURI != nil {
		enc.AddString("historyArchivalURI", *v.HistoryArchivalURI)
	}
	if v.VisibilityArchivalStatus != nil {
		enc.AddInt16("visibilityArchivalStatus", *v.VisibilityArchivalStatus)
	}
	if v.VisibilityArchivalURI != nil {
		enc.AddString("visibilityArchivalURI", *v.VisibilityArchivalURI)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetName() (o string) {
	if v != nil && v.Name != nil {
		return *v.Name
	}

	return
}

// IsSetName returns true if Name is not nil.
func (v *DomainInfo) IsSetName() bool {
	return v != nil && v.Name != nil
}

// GetDescription returns the value of Description if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetDescription() (o string) {
	if v != nil && v.Description != nil {
		return *v.Description
	}

	return
}

// IsSetDescription returns true if Description is not nil.
func (v *DomainInfo) IsSetDescription() bool {
	return v != nil && v.Description != nil
}

// GetOwner returns the value of Owner if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetOwner() (o string) {
	if v != nil && v.Owner != nil {
		return *v.Owner
	}

	return
}

// IsSetOwner returns true if Owner is not nil.
func (v *DomainInfo) IsSetOwner() bool {
	return v != nil && v.Owner != nil
}

// GetStatus returns the value of Status if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetStatus() (o int32) {
	if v != nil && v.Status != nil {
		return *v.Status
	}

	return
}

// IsSetStatus returns true if Status is not nil.
func (v *DomainInfo) IsSetStatus() bool {
	return v != nil && v.Status != nil
}

// GetRetentionDays returns the value of RetentionDays if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetRetentionDays() (o int16) {
	if v != nil && v.RetentionDays != nil {
		return *v.RetentionDays
	}

	return
}

// IsSetRetentionDays returns true if RetentionDays is not nil.
func (v *DomainInfo) IsSetRetentionDays() bool {
	return v != nil && v.RetentionDays != nil
}

// GetEmitMetric returns the value of EmitMetric if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetEmitMetric() (o bool) {
	if v != nil && v.EmitMetric != nil {
		return *v.EmitMetric
	}

	return
}

// IsSetEmitMetric returns true if EmitMetric is not nil.
func (v *DomainInfo) IsSetEmitMetric() bool {
	return v != nil && v.EmitMetric != nil
}

// GetArchivalBucket returns the value of ArchivalBucket if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetArchivalBucket() (o string) {
	if v != nil && v.ArchivalBucket != nil {
		return *v.ArchivalBucket
	}

	return
}

// IsSetArchivalBucket returns true if ArchivalBucket is not nil.
func (v *DomainInfo) IsSetArchivalBucket() bool {
	return v != nil && v.ArchivalBucket != nil
}

// GetArchivalStatus returns the value of ArchivalStatus if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetArchivalStatus() (o int16) {
	if v != nil && v.ArchivalStatus != nil {
		return *v.ArchivalStatus
	}

	return
}

// IsSetArchivalStatus returns true if ArchivalStatus is not nil.
func (v *DomainInfo) IsSetArchivalStatus() bool {
	return v != nil && v.ArchivalStatus != nil
}

// GetConfigVersion returns the value of ConfigVersion if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetConfigVersion() (o int64) {
	if v != nil && v.ConfigVersion != nil {
		return *v.ConfigVersion
	}

	return
}

// IsSetConfigVersion returns true if ConfigVersion is not nil.
func (v *DomainInfo) IsSetConfigVersion() bool {
	return v != nil && v.ConfigVersion != nil
}

// GetNotificationVersion returns the value of NotificationVersion if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetNotificationVersion() (o int64) {
	if v != nil && v.NotificationVersion != nil {
		return *v.NotificationVersion
	}

	return
}

// IsSetNotificationVersion returns true if NotificationVersion is not nil.
func (v *DomainInfo) IsSetNotificationVersion() bool {
	return v != nil && v.NotificationVersion != nil
}

// GetFailoverNotificationVersion returns the value of FailoverNotificationVersion if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetFailoverNotificationVersion() (o int64) {
	if v != nil && v.FailoverNotificationVersion != nil {
		return *v.FailoverNotificationVersion
	}

	return
}

// IsSetFailoverNotificationVersion returns true if FailoverNotificationVersion is not nil.
func (v *DomainInfo) IsSetFailoverNotificationVersion() bool {
	return v != nil && v.FailoverNotificationVersion != nil
}

// GetFailoverVersion returns the value of FailoverVersion if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetFailoverVersion() (o int64) {
	if v != nil && v.FailoverVersion != nil {
		return *v.FailoverVersion
	}

	return
}

// IsSetFailoverVersion returns true if FailoverVersion is not nil.
func (v *DomainInfo) IsSetFailoverVersion() bool {
	return v != nil && v.FailoverVersion != nil
}

// GetActiveClusterName returns the value of ActiveClusterName if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetActiveClusterName() (o string) {
	if v != nil && v.ActiveClusterName != nil {
		return *v.ActiveClusterName
	}

	return
}

// IsSetActiveClusterName returns true if ActiveClusterName is not nil.
func (v *DomainInfo) IsSetActiveClusterName() bool {
	return v != nil && v.ActiveClusterName != nil
}

// GetClusters returns the value of Clusters if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetClusters() (o []string) {
	if v != nil && v.Clusters != nil {
		return v.Clusters
	}

	return
}

// IsSetClusters returns true if Clusters is not nil.
func (v *DomainInfo) IsSetClusters() bool {
	return v != nil && v.Clusters != nil
}

// GetData returns the value of Data if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetData() (o map[string]string) {
	if v != nil && v.Data != nil {
		return v.Data
	}

	return
}

// IsSetData returns true if Data is not nil.
func (v *DomainInfo) IsSetData() bool {
	return v != nil && v.Data != nil
}

// GetBadBinaries returns the value of BadBinaries if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetBadBinaries() (o []byte) {
	if v != nil && v.BadBinaries != nil {
		return v.BadBinaries
	}

	return
}

// IsSetBadBinaries returns true if BadBinaries is not nil.
func (v *DomainInfo) IsSetBadBinaries() bool {
	return v != nil && v.BadBinaries != nil
}

// GetBadBinariesEncoding returns the value of BadBinariesEncoding if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetBadBinariesEncoding() (o string) {
	if v != nil && v.BadBinariesEncoding != nil {
		return *v.BadBinariesEncoding
	}

	return
}

// IsSetBadBinariesEncoding returns true if BadBinariesEncoding is not nil.
func (v *DomainInfo) IsSetBadBinariesEncoding() bool {
	return v != nil && v.BadBinariesEncoding != nil
}

// GetHistoryArchivalStatus returns the value of HistoryArchivalStatus if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetHistoryArchivalStatus() (o int16) {
	if v != nil && v.HistoryArchivalStatus != nil {
		return *v.HistoryArchivalStatus
	}

	return
}

// IsSetHistoryArchivalStatus returns true if HistoryArchivalStatus is not nil.
func (v *DomainInfo) IsSetHistoryArchivalStatus() bool {
	return v != nil && v.HistoryArchivalStatus != nil
}

// GetHistoryArchivalURI returns the value of HistoryArchivalURI if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetHistoryArchivalURI() (o string) {
	if v != nil && v.HistoryArchivalURI != nil {
		return *v.HistoryArchivalURI
	}

	return
}

// IsSetHistoryArchivalURI returns true if HistoryArchivalURI is not nil.
func (v *DomainInfo) IsSetHistoryArchivalURI() bool {
	return v != nil && v.HistoryArchivalURI != nil
}

// GetVisibilityArchivalStatus returns the value of VisibilityArchivalStatus if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetVisibilityArchivalStatus() (o int16) {
	if v != nil && v.VisibilityArchivalStatus != nil {
		return *v.VisibilityArchivalStatus
	}

	return
}

// IsSetVisibilityArchivalStatus returns true if VisibilityArchivalStatus is not nil.
func (v *DomainInfo) IsSetVisibilityArchivalStatus() bool {
	return v != nil && v.VisibilityArchivalStatus != nil
}

// GetVisibilityArchivalURI returns the value of VisibilityArchivalURI if it is set or its
// zero value if it is unset.
func (v *DomainInfo) GetVisibilityArchivalURI() (o string) {
	if v != nil && v.VisibilityArchivalURI != nil {
		return *v.VisibilityArchivalURI
	}

	return
}

// IsSetVisibilityArchivalURI returns true if VisibilityArchivalURI is not nil.
func (v *DomainInfo) IsSetVisibilityArchivalURI() bool {
	return v != nil && v.VisibilityArchivalURI != nil
}

// ThriftModule represents the IDL file used to generate this package.
var ThriftModule = &thriftreflect.ThriftModule{
	Name:     "sqlblobs",
	Package:  "github.com/temporalio/temporal/.gen/go/sqlblobs",
	FilePath: "sqlblobs.thrift",
	SHA1:     "314f8c9f2d03a5f8793a926e989b68205be4ee84",
	Includes: []*thriftreflect.ThriftModule{
		shared.ThriftModule,
	},
	Raw: rawIDL,
}

const rawIDL = "// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nnamespace java com.temporalio.temporal.sqlblobs\n\ninclude \"shared.thrift\"\n\nstruct DomainInfo {\n  10: optional string name\n  12: optional string description\n  14: optional string owner\n  16: optional i32 status\n  18: optional i16 retentionDays\n  20: optional bool emitMetric\n  22: optional string archivalBucket\n  24: optional i16 archivalStatus\n  26: optional i64 (js.type = \"Long\") configVersion\n  28: optional i64 (js.type = \"Long\") notificationVersion\n  30: optional i64 (js.type = \"Long\") failoverNotificationVersion\n  32: optional i64 (js.type = \"Long\") failoverVersion\n  34: optional string activeClusterName\n  36: optional list<string> clusters\n  38: optional map<string, string> data\n  39: optional binary badBinaries\n  40: optional string badBinariesEncoding\n  42: optional i16 historyArchivalStatus\n  44: optional string historyArchivalURI\n  46: optional i16 visibilityArchivalStatus\n  48: optional string visibilityArchivalURI\n}\n\nstruct ActivityInfo {\n  10: optional i64 (js.type = \"Long\") version\n  12: optional i64 (js.type = \"Long\") scheduledEventBatchID\n  14: optional binary scheduledEvent\n  16: optional string scheduledEventEncoding\n  18: optional i64 (js.type = \"Long\") scheduledTimeNanos\n  20: optional i64 (js.type = \"Long\") startedID\n  22: optional binary startedEvent\n  24: optional string startedEventEncoding\n  26: optional i64 (js.type = \"Long\") startedTimeNanos\n  28: optional string activityID\n  30: optional string requestID\n  32: optional i32 scheduleToStartTimeoutSeconds\n  34: optional i32 scheduleToCloseTimeoutSeconds\n  36: optional i32 startToCloseTimeoutSeconds\n  38: optional i32 heartbeatTimeoutSeconds\n  40: optional bool cancelRequested\n  42: optional i64 (js.type = \"Long\") cancelRequestID\n  44: optional i32 timerTaskStatus\n  46: optional i32 attempt\n  48: optional string taskList\n  50: optional string startedIdentity\n  52: optional bool hasRetryPolicy\n  54: optional i32 retryInitialIntervalSeconds\n  56: optional i32 retryMaximumIntervalSeconds\n  58: optional i32 retryMaximumAttempts\n  60: optional i64 (js.type = \"Long\") retryExpirationTimeNanos\n  62: optional double retryBackoffCoefficient\n  64: optional list<string> retryNonRetryableErrors\n  66: optional string retryLastFailureReason\n  68: optional string retryLastWorkerIdentity\n  70: optional binary retryLastFailureDetails\n}\n\nstruct ChildExecutionInfo {\n  10: optional i64 (js.type = \"Long\") version\n  12: optional i64 (js.type = \"Long\") initiatedEventBatchID\n  14: optional i64 (js.type = \"Long\") startedID\n  16: optional binary initiatedEvent\n  18: optional string initiatedEventEncoding\n  20: optional string startedWorkflowID\n  22: optional binary startedRunID\n  24: optional binary startedEvent\n  26: optional string startedEventEncoding\n  28: optional string createRequestID\n  30: optional string domainName\n  32: optional string workflowTypeName\n  35: optional i32 parentClosePolicy\n}\n"
