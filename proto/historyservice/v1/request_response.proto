// Copyright (c) 2019 Temporal Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

syntax = "proto3";

package historyservice.v1;
option go_package = "github.com/temporalio/temporal/.gen/proto/historyservice/v1;historyservice";

import "common/v1/message.proto";
import "history/v1/message.proto";
import "tasklist/v1/message.proto";
import "enums/v1/workflow.proto";
import "execution/v1/message.proto";
import "query/v1/message.proto";
import "failure/v1/message.proto";

import "history/v1/server_message.proto";
import "enums/v1/server_common.proto";
import "enums/v1/server_workflow.proto";
import "enums/v1/server_task.proto";
import "workflow/v1/server_message.proto";
import "namespace/v1/server_message.proto";
import "replication/v1/server_message.proto";

// TODO: remove these dependencies
import "workflowservice/v1/request_response.proto";
import "adminservice/v1/request_response.proto";

message StartWorkflowExecutionRequest {
    string namespaceId = 1;
    workflowservice.v1.StartWorkflowExecutionRequest startRequest = 2;
    workflow.v1.ParentExecutionInfo parentExecutionInfo = 3;
    int32 attempt = 4;
    int64 workflowExecutionExpirationTimestamp = 5;
    enums.v1.ContinueAsNewInitiator continueAsNewInitiator = 6;
    failure.v1.Failure continuedFailure = 7;
    common.v1.Payloads lastCompletionResult = 8;
    int32 firstDecisionTaskBackoffSeconds = 9;
}

message StartWorkflowExecutionResponse {
    string runId = 1;
}

message GetMutableStateRequest {
    string namespaceId = 1;
    common.v1.WorkflowExecution execution = 2;
    int64 expectedNextEventId = 3;
    bytes currentBranchToken = 4;
}

message GetMutableStateResponse {
    common.v1.WorkflowExecution execution = 1;
    common.v1.WorkflowType workflowType = 2;
    int64 nextEventId = 3;
    int64 previousStartedEventId = 4;
    int64 lastFirstEventId = 5;
    tasklist.v1.TaskList taskList = 6;
    tasklist.v1.TaskList stickyTaskList = 7;
    string clientLibraryVersion = 8;
    string clientFeatureVersion = 9;
    string clientImpl = 10;
    //TODO: isWorkflowRunning is deprecating. workflowState is going replace this field
    bool isWorkflowRunning = 11;
    int32 stickyTaskListScheduleToStartTimeout = 12;
    int32 eventStoreVersion = 13;
    bytes currentBranchToken = 14;
    map<string, replication.v1.ReplicationInfo> replicationInfo = 15;
    enums.v1.WorkflowExecutionState workflowState = 16;
    enums.v1.WorkflowExecutionStatus workflowStatus = 17;
    history.v1.VersionHistories versionHistories = 18;
    bool isStickyTaskListEnabled = 19;
}

message PollMutableStateRequest {
    string namespaceId = 1;
    common.v1.WorkflowExecution execution = 2;
    int64 expectedNextEventId = 3;
    bytes currentBranchToken = 4;
}

message PollMutableStateResponse {
    common.v1.WorkflowExecution execution = 1;
    common.v1.WorkflowType workflowType = 2;
    int64 nextEventId = 3;
    int64 previousStartedEventId = 4;
    int64 lastFirstEventId = 5;
    tasklist.v1.TaskList taskList = 6;
    tasklist.v1.TaskList stickyTaskList = 7;
    string clientLibraryVersion = 8;
    string clientFeatureVersion = 9;
    string clientImpl = 10;
    int32 stickyTaskListScheduleToStartTimeout = 11;
    bytes currentBranchToken = 12;
    map<string, replication.v1.ReplicationInfo> replicationInfo = 13;
    history.v1.VersionHistories versionHistories = 14;
    enums.v1.WorkflowExecutionState workflowState = 15;
    enums.v1.WorkflowExecutionStatus workflowStatus = 16;
}

message ResetStickyTaskListRequest {
    string namespaceId = 1;
    common.v1.WorkflowExecution execution = 2;
}

message ResetStickyTaskListResponse {
}

message RecordDecisionTaskStartedRequest {
    string namespaceId = 1;
    common.v1.WorkflowExecution workflowExecution = 2;
    int64 scheduleId = 3;
    int64 taskId = 4;
    // Unique id of each poll request. Used to ensure at most once delivery of tasks.
    string requestId = 5;
    workflowservice.v1.PollForDecisionTaskRequest pollRequest = 6;
}

message RecordDecisionTaskStartedResponse {
    common.v1.WorkflowType workflowType = 1;
    int64 previousStartedEventId = 2;
    int64 scheduledEventId = 3;
    int64 startedEventId = 4;
    int64 nextEventId = 5;
    int64 attempt = 6;
    bool stickyExecutionEnabled = 7;
    history.v1.TransientDecisionInfo decisionInfo = 8;
    tasklist.v1.TaskList WorkflowExecutionTaskList = 9;
    int32 eventStoreVersion = 10;
    bytes branchToken = 11;
    int64 scheduledTimestamp = 12;
    int64 startedTimestamp = 13;
    map<string, query.v1.WorkflowQuery> queries = 14;
}

message RecordActivityTaskStartedRequest {
    string namespaceId = 1;
    common.v1.WorkflowExecution workflowExecution = 2;
    int64 scheduleId = 3;
    int64 taskId = 4;
    // Unique id of each poll request. Used to ensure at most once delivery of tasks.
    string requestId = 5;
    workflowservice.v1.PollForActivityTaskRequest pollRequest = 6;
}

message RecordActivityTaskStartedResponse {
    history.v1.HistoryEvent scheduledEvent = 1;
    int64 startedTimestamp = 2;
    int64 attempt = 3;
    int64 scheduledTimestampOfThisAttempt = 4;
    common.v1.Payloads heartbeatDetails = 5;
    common.v1.WorkflowType workflowType = 6;
    string workflowNamespace = 7;
}

message RespondDecisionTaskCompletedRequest {
    string namespaceId = 1;
    workflowservice.v1.RespondDecisionTaskCompletedRequest completeRequest = 2;
}

message RespondDecisionTaskCompletedResponse {
    RecordDecisionTaskStartedResponse startedResponse = 1;
}

message RespondDecisionTaskFailedRequest {
    string namespaceId = 1;
    workflowservice.v1.RespondDecisionTaskFailedRequest failedRequest = 2;
}

message RespondDecisionTaskFailedResponse {
}

message RecordActivityTaskHeartbeatRequest {
    string namespaceId = 1;
    workflowservice.v1.RecordActivityTaskHeartbeatRequest heartbeatRequest = 2;
}

message RecordActivityTaskHeartbeatResponse {
    bool cancelRequested = 1;
}

message RespondActivityTaskCompletedRequest {
    string namespaceId = 1;
    workflowservice.v1.RespondActivityTaskCompletedRequest completeRequest = 2;
}

message RespondActivityTaskCompletedResponse {
}

message RespondActivityTaskFailedRequest {
    string namespaceId = 1;
    workflowservice.v1.RespondActivityTaskFailedRequest failedRequest = 2;
}

message RespondActivityTaskFailedResponse {
}

message RespondActivityTaskCanceledRequest {
    string namespaceId = 1;
    workflowservice.v1.RespondActivityTaskCanceledRequest cancelRequest = 2;
}

message RespondActivityTaskCanceledResponse {
}

message SignalWorkflowExecutionRequest {
    string namespaceId = 1;
    workflowservice.v1.SignalWorkflowExecutionRequest signalRequest = 2;
    common.v1.WorkflowExecution externalWorkflowExecution = 3;
    bool childWorkflowOnly = 4;
}

message SignalWorkflowExecutionResponse {
}

message SignalWithStartWorkflowExecutionRequest {
    string namespaceId = 1;
    workflowservice.v1.SignalWithStartWorkflowExecutionRequest signalWithStartRequest = 2;
}

message SignalWithStartWorkflowExecutionResponse {
    string runId = 1;
}

message RemoveSignalMutableStateRequest {
    string namespaceId = 1;
    common.v1.WorkflowExecution workflowExecution = 2;
    string requestId = 3;
}

message RemoveSignalMutableStateResponse {
}

message TerminateWorkflowExecutionRequest {
    string namespaceId = 1;
    workflowservice.v1.TerminateWorkflowExecutionRequest terminateRequest = 2;
}

message TerminateWorkflowExecutionResponse {
}

message ResetWorkflowExecutionRequest {
    string namespaceId = 1;
    workflowservice.v1.ResetWorkflowExecutionRequest resetRequest = 2;
}

message ResetWorkflowExecutionResponse {
    string runId = 1;
}

message RequestCancelWorkflowExecutionRequest {
    string namespaceId = 1;
    workflowservice.v1.RequestCancelWorkflowExecutionRequest cancelRequest = 2;
    int64 externalInitiatedEventId = 3;
    common.v1.WorkflowExecution externalWorkflowExecution = 4;
    bool childWorkflowOnly = 5;
}

message RequestCancelWorkflowExecutionResponse {
}

message ScheduleDecisionTaskRequest {
    string namespaceId = 1;
    common.v1.WorkflowExecution workflowExecution = 2;
    bool isFirstDecision = 3;
}

message ScheduleDecisionTaskResponse {
}

/**
* RecordChildExecutionCompletedRequest is used for reporting the completion of child execution to parent workflow
* execution which started it.  When a child execution is completed it creates this request and calls the
* RecordChildExecutionCompleted API with the workflowExecution of parent.  It also sets the completedExecution of the
* child as it could potentially be different than the ChildExecutionStartedEvent of parent in the situation when
* child creates multiple runs through ContinueAsNew before finally completing.
**/
message RecordChildExecutionCompletedRequest {
    string namespaceId = 1;
    common.v1.WorkflowExecution workflowExecution = 2;
    int64 initiatedId = 3;
    common.v1.WorkflowExecution completedExecution = 4;
    history.v1.HistoryEvent completionEvent = 5;
}

message RecordChildExecutionCompletedResponse {
}

message DescribeWorkflowExecutionRequest {
    string namespaceId = 1;
    workflowservice.v1.DescribeWorkflowExecutionRequest request = 2;
}

message DescribeWorkflowExecutionResponse {
    execution.v1.WorkflowExecutionConfiguration executionConfiguration = 1;
    execution.v1.WorkflowExecutionInfo workflowExecutionInfo = 2;
    repeated execution.v1.PendingActivityInfo pendingActivities = 3;
    repeated execution.v1.PendingChildExecutionInfo pendingChildren = 4;
}

message ReplicateEventsRequest {
    string sourceCluster = 1;
    string namespaceId = 2;
    common.v1.WorkflowExecution workflowExecution = 3;
    int64 firstEventId = 4;
    int64 nextEventId = 5;
    int64 version = 6;
    map<string, replication.v1.ReplicationInfo> replicationInfo = 7;
    history.v1.History history = 8;
    history.v1.History newRunHistory = 9;
    // this attribute is deprecated
    bool forceBufferEvents = 10;
    int32 eventStoreVersion = 11;
    int32 newRunEventStoreVersion = 12;
    bool resetWorkflow = 13;
    bool newRunNDC = 14;
}

message ReplicateEventsResponse {
}

message ReplicateRawEventsRequest {
    string namespaceId = 1;
    common.v1.WorkflowExecution workflowExecution = 2;
    map<string, replication.v1.ReplicationInfo> replicationInfo = 3;
    common.v1.DataBlob history = 4;
    common.v1.DataBlob newRunHistory = 5;
    int32 eventStoreVersion = 6;
    int32 newRunEventStoreVersion = 7;
}

message ReplicateRawEventsResponse {
}

message ReplicateEventsV2Request {
    string namespaceId = 1;
    common.v1.WorkflowExecution workflowExecution = 2;
    repeated history.v1.VersionHistoryItem versionHistoryItems = 3;
    common.v1.DataBlob events = 4;
    // New run events does not need version history since there is no prior events.
    common.v1.DataBlob newRunEvents = 5;
}

message ReplicateEventsV2Response {
}

message SyncShardStatusRequest {
    string sourceCluster = 1;
    int64 shardId = 2;
    int64 timestamp = 3;
}

message SyncShardStatusResponse {
}

message SyncActivityRequest {
    string namespaceId = 1;
    string workflowId = 2;
    string runId = 3;
    int64 version = 4;
    int64 scheduledId = 5;
    int64 scheduledTime = 6;
    int64 startedId = 7;
    int64 startedTime = 8;
    int64 lastHeartbeatTime = 9;
    common.v1.Payloads details = 10;
    int32 attempt = 11;
    failure.v1.Failure lastFailure = 12;
    string lastWorkerIdentity = 13;
    history.v1.VersionHistory versionHistory = 14;
}

message SyncActivityResponse {
}

message DescribeMutableStateRequest {
    string namespaceId = 1;
    common.v1.WorkflowExecution execution = 2;
}

message DescribeMutableStateResponse {
    string mutableStateInCache = 1;
    string mutableStateInDatabase = 2;
}

//At least one of the parameters needs to be provided
message DescribeHistoryHostRequest {
    //ip:port
    string hostAddress = 1;
    int32 shardIdForHost = 2;
    common.v1.WorkflowExecution executionForHost = 3;
}

message DescribeHistoryHostResponse {
    int32 numberOfShards = 1;
    repeated int32
    shardIds = 2;
    namespace.v1.NamespaceCacheInfo namespaceCache = 3;
    string shardControllerStatus = 4;
    string address = 5;
}

message CloseShardRequest {
    int32 shardId = 1;
}

message CloseShardResponse {
}

message RemoveTaskRequest {
    int32 shardId = 1;
    enums.v1.TaskCategory category = 2;
    int64 taskId = 3;
    int64 visibilityTimestamp = 4;
}

message RemoveTaskResponse {
}

message GetReplicationMessagesRequest {
    repeated replication.v1.ReplicationToken tokens = 1;
    string clusterName = 2;
}

message GetReplicationMessagesResponse {
    map<int32, replication.v1.ReplicationMessages> messagesByShard = 1;
}

message GetDLQReplicationMessagesRequest {
    repeated replication.v1.ReplicationTaskInfo taskInfos = 1;
}

message GetDLQReplicationMessagesResponse {
    repeated replication.v1.ReplicationTask replicationTasks = 1;
}

message QueryWorkflowRequest {
    string namespaceId = 1;
    workflowservice.v1.QueryWorkflowRequest request = 2;
}

message QueryWorkflowResponse {
    workflowservice.v1.QueryWorkflowResponse response = 1;
}

message ReapplyEventsRequest {
    string namespaceId = 1;
    adminservice.v1.ReapplyEventsRequest request = 2;
}

message ReapplyEventsResponse {
}

message ReadDLQMessagesRequest {
    enums.v1.DeadLetterQueueType type = 1;
    int32 shardId = 2;
    string sourceCluster = 3;
    int64 inclusiveEndMessageId = 4;
    int32 maximumPageSize = 5;
    bytes nextPageToken = 6;
}

message ReadDLQMessagesResponse {
    enums.v1.DeadLetterQueueType type = 1;
    repeated replication.v1.ReplicationTask replicationTasks = 2;
    bytes nextPageToken = 3;
}

message PurgeDLQMessagesRequest {
    enums.v1.DeadLetterQueueType type = 1;
    int32 shardId = 2;
    string sourceCluster = 3;
    int64 inclusiveEndMessageId = 4;
}

message PurgeDLQMessagesResponse {
}

message MergeDLQMessagesRequest {
    enums.v1.DeadLetterQueueType type = 1;
    int32 shardId = 2;
    string sourceCluster = 3;
    int64 inclusiveEndMessageId = 4;
    int32 maximumPageSize = 5;
    bytes nextPageToken = 6;
}

message MergeDLQMessagesResponse {
    bytes nextPageToken = 1;
}

message RefreshWorkflowTasksRequest {
    string namespaceId = 1;
    adminservice.v1.RefreshWorkflowTasksRequest request = 2;
}

message RefreshWorkflowTasksResponse {
}
