syntax = "proto3";

package temporal.server.api.batch.v1;
option go_package = "go.temporal.io/server/api/batch/v1;batch";

import "google/protobuf/duration.proto";

import "temporal/api/batch/v1/message.proto";
import "temporal/api/common/v1/message.proto";
import "temporal/api/workflow/v1/message.proto";
import "temporal/api/enums/v1/workflow.proto";
import "temporal/api/failure/v1/message.proto";
import "temporal/api/sdk/v1/user_metadata.proto";
import "temporal/api/taskqueue/v1/message.proto";

import "temporal/api/workflowservice/v1/request_response.proto";

import "temporal/server/api/clock/v1/message.proto";

message BatchOperation {
  // The namespace of the batch operation.
  string namespace = 1;

  // The query to perform.
  string query = 2;

  repeated temporal.api.common.v1.WorkflowExecution workflow_executions = 3;

  string reason = 4;

  oneof operation {
    temporal.api.batch.v1.BatchOperationTermination termination_operation = 5;
    temporal.api.batch.v1.BatchOperationCancellation cancellation_operation = 6;
    temporal.api.batch.v1.BatchOperationSignal signal_operation = 7;
    temporal.api.batch.v1.BatchOperationDeletion deletion_operation = 8;
    temporal.api.batch.v1.BatchOperationReset reset_operation = 9;
    temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions update_workflow_execution_options_operation = 10;
    temporal.api.batch.v1.BatchOperationUnpauseActivities unpause_activities_operation = 11;
    temporal.api.batch.v1.BatchOperationUpdateActivityOptions update_activity_options_operation = 12;
    temporal.api.batch.v1.BatchOperationResetActivities reset_activities_operation = 13;
  }

  double rps = 14;

  int64 concurrency = 15;

  int64 attempts_on_retryable_error = 16;

  google.protobuf.Duration activity_heartbeat_timeout = 17;

  repeated string non_retryable_errors = 18;

  string batch_type = 19;
}


message StartBatchWorkflowExecutionRequest {
    string namespace = 1;
    string workflow_id = 2;
    temporal.api.common.v1.WorkflowType workflow_type = 3;
    temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
    // Serialized arguments to the workflow. These are passed as arguments to the workflow function.
    BatchOperation input = 5;
    // Total workflow execution timeout including retries and continue as new.
    google.protobuf.Duration workflow_execution_timeout = 6;
    // Timeout of a single workflow run.
    google.protobuf.Duration workflow_run_timeout = 7;
    // Timeout of a single workflow task.
    google.protobuf.Duration workflow_task_timeout = 8;
    // The identity of the client who initiated this request
    string identity = 9;
    // A unique identifier for this start request. Typically UUIDv4.
    string request_id = 10;
    // Defines whether to allow re-using the workflow id from a previously *closed* workflow.
    // The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    //
    // See `workflow_id_conflict_policy` for handling a workflow id duplication with a *running* workflow.
    temporal.api.enums.v1.WorkflowIdReusePolicy workflow_id_reuse_policy = 11;
    // Defines how to resolve a workflow id conflict with a *running* workflow.
    // The default policy is WORKFLOW_ID_CONFLICT_POLICY_FAIL.
    //
    // See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
    temporal.api.enums.v1.WorkflowIdConflictPolicy workflow_id_conflict_policy = 22;
    // The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
    temporal.api.common.v1.RetryPolicy retry_policy = 12;
    // See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
    string cron_schedule = 13;
    temporal.api.common.v1.Memo memo = 14;
    temporal.api.common.v1.SearchAttributes search_attributes = 15;
    temporal.api.common.v1.Header header = 16;
    // Request to get the first workflow task inline in the response bypassing matching service and worker polling.
    // If set to `true` the caller is expected to have a worker available and capable of processing the task.
    // The returned task will be marked as started and is expected to be completed by the specified
    // `workflow_task_timeout`.
    bool request_eager_execution = 17;
    // These values will be available as ContinuedFailure and LastCompletionResult in the
    // WorkflowExecutionStarted event and through SDKs. The are currently only used by the
    // server itself (for the schedules feature) and are not intended to be exposed in
    // StartWorkflowExecution.
    temporal.api.failure.v1.Failure continued_failure = 18;
    temporal.api.common.v1.Payloads last_completion_result = 19;
    // Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
    // If the workflow gets a signal before the delay, a workflow task will be dispatched and the rest
    // of the delay will be ignored.
    google.protobuf.Duration workflow_start_delay = 20;
    // Callbacks to be called by the server when this workflow reaches a terminal state.
    // If the workflow continues-as-new, these callbacks will be carried over to the new execution.
    // Callback addresses must be whitelisted in the server's dynamic configuration.
    repeated temporal.api.common.v1.Callback completion_callbacks = 21;
    // Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo
    // for use by user interfaces to display the fixed as-of-start summary and details of the
    // workflow.
    temporal.api.sdk.v1.UserMetadata user_metadata = 23;
    // Links to be associated with the workflow.
    repeated temporal.api.common.v1.Link links = 24;
    // If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
    // To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
    temporal.api.workflow.v1.VersioningOverride versioning_override = 25;
    // Defines actions to be done to the existing running workflow when the conflict policy
    // WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING is used. If not set (ie., nil value) or set to a
    // empty object (ie., all options with default value), it won't do anything to the existing
    // running workflow. If set, it will add a history event to the running workflow.
    temporal.api.workflow.v1.OnConflictOptions on_conflict_options = 26;
    // Priority metadata
    temporal.api.common.v1.Priority priority = 27;
}


message StartBatchWorkflowExecutionResponse {
    string run_id = 1;
    temporal.server.api.clock.v1.VectorClock clock = 2;
    // Set if request_eager_execution is set on the start request
    temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponse eager_workflow_task = 3;
    bool started = 4;
    temporal.api.enums.v1.WorkflowExecutionStatus status = 5;
    temporal.api.common.v1.Link link = 6;
}