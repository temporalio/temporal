// Copyright (c) 2020 Temporal Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

syntax = "proto3";

package temporal.server.api.persistenceblobs.v1;
option go_package = "go.temporal.io/server/api/persistenceblobs/v1;persistenceblobs";

import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "temporal/api/common/v1/message.proto";
import "temporal/api/enums/v1/workflow.proto";
import "temporal/api/enums/v1/namespace.proto";
import "temporal/api/namespace/v1/message.proto";
import "temporal/api/enums/v1/task_queue.proto";
import "temporal/api/failure/v1/message.proto";
import "temporal/api/history/v1/message.proto";

import "dependencies/gogoproto/v1/gogo.proto";
import "temporal/server/api/enums/v1/common.proto";
import "temporal/server/api/enums/v1/workflow.proto";
import "temporal/server/api/enums/v1/task.proto";
import "temporal/server/api/replication/v1/message.proto";

// ImmutableClusterMetadata contains initialization configuration and metadata for the cluster.
message ImmutableClusterMetadata {
    string cluster_name = 1;
    int32 history_shard_count = 2;
}

message ActivityInfo {
    int64 version = 1;
    int64 scheduled_event_batch_id = 2;
    temporal.api.history.v1.HistoryEvent scheduled_event = 3;
    google.protobuf.Timestamp scheduled_time = 5 [(gogoproto.stdtime) = true];
    int64 started_id = 6;
    temporal.api.history.v1.HistoryEvent started_event = 7;
    google.protobuf.Timestamp started_time = 9 [(gogoproto.stdtime) = true];
    string activity_id = 10;
    string request_id = 11;
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration schedule_to_start_timeout = 12 [(gogoproto.stdduration) = true];
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration schedule_to_close_timeout = 13 [(gogoproto.stdduration) = true];
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration start_to_close_timeout = 14 [(gogoproto.stdduration) = true];
    google.protobuf.Duration heartbeat_timeout = 15 [(gogoproto.stdduration) = true];
    bool cancel_requested = 16;
    int64 cancel_request_id = 17;
    int32 timer_task_status = 18;
    int32 attempt = 19;
    string task_queue = 20;
    string started_identity = 21;
    bool has_retry_policy = 22;
    google.protobuf.Duration retry_initial_interval = 23 [(gogoproto.stdduration) = true];
    google.protobuf.Duration retry_maximum_interval = 24 [(gogoproto.stdduration) = true];
    int32 retry_maximum_attempts = 25;
    google.protobuf.Timestamp retry_expiration_time = 26 [(gogoproto.stdtime) = true];
    double retry_backoff_coefficient = 27;
    repeated string retry_non_retryable_error_types = 28;
    temporal.api.failure.v1.Failure retry_last_failure = 29;
    string retry_last_worker_identity = 30;
    string namespace_id = 31;
    int64 schedule_id = 32;
    temporal.api.common.v1.Payloads last_heartbeat_details = 33;
    google.protobuf.Timestamp last_heartbeat_update_time = 34 [(gogoproto.stdtime) = true];
}

message ShardInfo {
    int32 shard_id = 1;
    int64 range_id = 2;
    string owner = 3;
    int64 replication_ack_level = 4;
    int64 transfer_ack_level = 5;
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "since" is needed here. --)
    int32 stolen_since_renew = 6;
    google.protobuf.Timestamp update_time = 7;
    google.protobuf.Timestamp timer_ack_level_time = 8;
    int64 namespace_notification_version = 9;
    map<string, int64> cluster_transfer_ack_level = 10;
    map<string, google.protobuf.Timestamp> cluster_timer_ack_level = 11;
    map<string, int64> cluster_replication_level = 12;
    map<string, int64> replication_dlq_ack_level = 13;
}


message ReplicationTaskInfo {
    string namespace_id = 1;
    string workflow_id = 2;
    string run_id = 3;
    temporal.server.api.enums.v1.TaskType task_type = 4;
    int64 version = 5;
    int64 first_event_id = 6;
    int64 next_event_id = 7;
    int64 scheduled_id = 8;
    int32 event_store_version = 9;
    int32 new_run_event_store_version = 10;
    bytes branch_token = 11;
    map<string, temporal.server.api.replication.v1.ReplicationInfo> last_replication_info = 12;
    bytes new_run_branch_token = 13;
    bool reset_workflow = 14;
    int64 task_id = 15;
}

message TimerTaskInfo {
    string namespace_id = 1;
    string workflow_id = 2;
    string run_id = 3;
    temporal.server.api.enums.v1.TaskType task_type = 4;
    temporal.api.enums.v1.TimeoutType timeout_type = 5;
    temporal.server.api.enums.v1.WorkflowBackoffType workflow_backoff_type = 6;
    int64 version = 7;
    int64 schedule_attempt = 8;
    int64 event_id = 9;
    int64 task_id = 10;
    google.protobuf.Timestamp visibility_time = 11;
}

message TransferTaskInfo {
    string namespace_id = 1;
    string workflow_id = 2;
    string run_id = 3;
    temporal.server.api.enums.v1.TaskType task_type = 4;
    string target_namespace_id = 5;
    string target_workflow_id = 6;
    string target_run_id = 7;
    string task_queue = 8;
    bool target_child_workflow_only = 9;
    int64 schedule_id = 10;
    int64 version = 11;
    int64 task_id = 12;
    google.protobuf.Timestamp visibility_time = 13;
    bool record_visibility = 14;
}

// HistoryBranchRange represents a piece of range for a branch.
message HistoryBranchRange {
    // BranchId of original branch forked from.
    string branch_id = 1;
    // Beginning node for the range, inclusive.
    int64 begin_node_id = 2;
    // Ending node for the range, exclusive.
    int64 end_node_id = 3;
}

// For history persistence to serialize/deserialize branch details.
message HistoryBranch {
    string tree_id = 1;
    string branch_id = 2;
    repeated HistoryBranchRange ancestors = 3;
}

message HistoryTreeInfo {
    HistoryBranch branch_info = 1;
    // For fork operation to prevent race condition of leaking event data when forking branches fail. Also can be used for clean up leaked data.
    google.protobuf.Timestamp fork_time = 2;
    // For lookup back to workflow during debugging, also background cleanup when fork operation cannot finish self cleanup due to crash.
    string info = 3;
}

message TimerInfo {
    int64 version = 1;
    int64 started_id = 2;
    google.protobuf.Timestamp expiry_time = 3;
    int64 task_status = 4;
    // timerId serves the purpose of indicating whether a timer task is generated for this timer info.
    string timer_id = 5;
}

message TaskInfo {
    string namespace_id = 1;
    string workflow_id = 2;
    string run_id = 3;
    int64 schedule_id = 4;
    google.protobuf.Timestamp create_time = 5;
    google.protobuf.Timestamp expiry_time = 6;
}

message AllocatedTaskInfo {
    TaskInfo data = 1;
    int64 task_id = 8;
}

message TaskQueueInfo {
    string namespace_id = 1;
    string name = 2;
    temporal.api.enums.v1.TaskQueueType task_type = 3;
    temporal.api.enums.v1.TaskQueueKind kind = 5;
    int64 ack_level = 6;
    google.protobuf.Timestamp expiry_time = 7;
    google.protobuf.Timestamp last_update_time = 8;
}

message SignalInfo {
    int64 version = 1;
    int64 initiated_event_batch_id = 2;
    string request_id = 3;
    string name = 4;
    temporal.api.common.v1.Payloads input = 5;
    string control = 6;
    int64 initiated_id = 7;
}

message RequestCancelInfo {
    int64 version = 1;
    int64 initiated_event_batch_id = 2;
    string cancel_request_id = 3;
    int64 initiated_id = 4;
}

message WorkflowExecutionState {
    string create_request_id = 1;
    string run_id = 2;
    temporal.server.api.enums.v1.WorkflowExecutionState state = 3;
    temporal.api.enums.v1.WorkflowExecutionStatus status = 4;
}

message WorkflowExecutionInfo {
    string namespace_id = 61;
    string workflow_id = 62;
    string parent_namespace_id = 1;
    string parent_workflow_id = 2;
    string parent_run_id = 3;
    int64 initiated_id = 4;
    int64 completion_event_batch_id = 5;
    bytes completion_event = 6;
    string completion_event_encoding = 7;
    string task_queue = 8;
    string workflow_type_name = 9;
    google.protobuf.Duration workflow_execution_timeout = 10 [(gogoproto.stdduration) = true];
    google.protobuf.Duration workflow_run_timeout = 11 [(gogoproto.stdduration) = true];
    google.protobuf.Duration default_workflow_task_timeout = 12 [(gogoproto.stdduration) = true];
    int64 start_version = 15;
    int64 current_version = 16;
    ReplicationData replication_data = 17;
    int64 last_event_task_id = 19;
    int64 last_first_event_id = 20;
    int64 last_processed_event = 21;
    google.protobuf.Timestamp start_time = 22 [(gogoproto.stdtime) = true];
    google.protobuf.Timestamp last_update_time = 23 [(gogoproto.stdtime) = true];
    int64 workflow_task_version = 24;
    int64 workflow_task_schedule_id = 25;
    int64 workflow_task_started_id = 26;
    google.protobuf.Duration workflow_task_timeout = 27 [(gogoproto.stdduration) = true];
    int64 workflow_task_attempt = 28;
    google.protobuf.Timestamp workflow_task_started_time = 29 [(gogoproto.stdtime) = true];
    google.protobuf.Timestamp workflow_task_scheduled_time = 30 [(gogoproto.stdtime) = true];
    bool cancel_requested = 31;
    google.protobuf.Timestamp workflow_task_original_scheduled_time = 32 [(gogoproto.stdtime) = true];
    string workflow_task_request_id = 34;
    string cancel_request_id = 35;
    string sticky_task_queue = 36;
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration sticky_schedule_to_start_timeout = 37 [(gogoproto.stdduration) = true];
    int64 retry_attempt = 38;
    google.protobuf.Duration retry_initial_interval = 39 [(gogoproto.stdduration) = true];
    google.protobuf.Duration retry_maximum_interval = 40 [(gogoproto.stdduration) = true];
    int32 retry_maximum_attempts = 41;
    double retry_backoff_coefficient = 42;
    google.protobuf.Timestamp retry_expiration_time = 43 [(gogoproto.stdtime) = true];
    repeated string retry_non_retryable_error_types = 44;
    bool has_retry_policy = 45;
    string cron_schedule = 46;
    int32 event_store_version = 47;
    bytes event_branch_token = 48;
    int64 signal_count = 49;
    int64 history_size = 50;
    string client_library_version = 51;
    string client_feature_version = 52;
    string client_impl = 53;
    bytes auto_reset_points = 54;
    string auto_reset_points_encoding = 55;
    map<string, temporal.api.common.v1.Payload> search_attributes = 56;
    map<string, temporal.api.common.v1.Payload> memo = 57;
    bytes version_histories = 58;
    string version_histories_encoding = 59;
}

message Checksum {
    int32 version = 1;
    temporal.server.api.enums.v1.ChecksumFlavor flavor = 2;
    bytes value = 3;
}

message ChildExecutionInfo {
    int64 version = 1;
    int64 initiated_event_batch_id = 2;
    int64 started_id = 3;
    temporal.api.history.v1.HistoryEvent initiated_event = 4;
    string started_workflow_id = 5;
    string started_run_id = 6;
    temporal.api.history.v1.HistoryEvent started_event = 7;
    string create_request_id = 8;
    string namespace = 9;
    string workflow_type_name = 10;
    temporal.api.enums.v1.ParentClosePolicy parent_close_policy = 11;
    int64 initiated_id = 12;
}

message NamespaceDetail {
    NamespaceInfo info = 1;
    NamespaceConfig config = 2;
    NamespaceReplicationConfig replication_config = 3;

    int64 config_version = 9;
    int64 failover_notification_version = 11;
    int64 failover_version = 12;
    int64 failover_end_time = 13;
}

message NamespaceInfo {
    string id = 1;
    temporal.api.enums.v1.NamespaceState state = 2;
    string name = 3;
    string description = 4;
    string owner = 5;
    map<string, string> data = 6;
}

message NamespaceReplicationConfig {
    string active_cluster_name = 1;
    repeated string clusters = 2;
}

message NamespaceConfig {
    google.protobuf.Duration retention = 1 [(gogoproto.stdduration) = true];
    string archival_bucket = 2;
    temporal.api.namespace.v1.BadBinaries bad_binaries = 3;
    temporal.api.enums.v1.ArchivalState history_archival_state = 4;
    string history_archival_uri = 5;
    temporal.api.enums.v1.ArchivalState visibility_archival_state = 6;
    string visibility_archival_uri = 7;
}

// ReplicationData represents mutable state information for global namespaces.
// This information is used by replication protocol when applying events from remote clusters
// only used in cassandra
message ReplicationData {
    int64 last_write_event_id = 1;
    map<string, temporal.server.api.replication.v1.ReplicationInfo> last_replication_info = 2;
}

message ReplicationVersions {
    google.protobuf.Int64Value start_version = 15;
    google.protobuf.Int64Value last_write_version = 16;
}
