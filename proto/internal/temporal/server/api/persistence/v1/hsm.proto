// The MIT License
//
// Copyright (c) 2024 Temporal Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

syntax = "proto3";

package temporal.server.api.persistence.v1;
option go_package = "go.temporal.io/server/api/persistence/v1;persistence";

// A node in a hierarchical state machine tree.
message StateMachineNode {
    // Number of transitions on this state machine object.
    // Used to verify that a task is not stale if the state machine does not allow concurrent task execution.
    int64 transition_count = 1;

    // Seralized data of the underlying state machine.
    bytes data = 2;
    map<int32, StateMachineMap> children = 3;
}

// Map of state machine ID to StateMachineNode.
message StateMachineMap {
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "by" is used to clarify the keys and values. --)
    map<string, StateMachineNode> machines_by_id = 1;
}

message StateMachineKey {
    // Addressable type of the corresponding state machine in a single tree level.
    int32 type = 1;
    // Addressable ID of the corresponding state machine in a single tree level.
    string id = 2;
}

// A reference to a state machine at a point in time.
message StateMachineRef {
    // Nested path to a state machine.
    repeated StateMachineKey path = 1;
    // Namespace failover version on the corresponding mutable state object, used for staleness detection when global
    // namespaces are enabled.
    int64 mutable_state_namespace_failover_version = 2;
    // Number of transitions on the corresponding mutable state object. Used to verify that a task is not referencing a
    // stale state or, in some situations, that the task itself is not stale.
    int64 mutable_state_transition_count = 3;
    // Number of transitions executed on the referenced state machine node at the time this Ref is instantiated.
    // If non-zero, the state machine is assumed to support only non-concurrent tasks, and this number should match the
    // number of state transitions on the corresponding state machine object.
    int64 machine_transition_count = 4;
}

message StateMachineTaskInfo {
    // Reference to a state machine.
    StateMachineRef ref = 1;
    // Task type. Not to be confused with the state machine's type in the `ref` field.
    int32 type = 2;
    // Opaque data attached to this task. May be nil. Deserialized by a registered TaskSerializer for this type.
    bytes data = 3;
}

// Keeps track of the ranges of transition counts per namespace failover version.
// Each task generated by the HSM framework is imprinted with the current transactionâ€™s `NamespaceFailoverVersion` and
// `MaxTransitionCount` at the end of the transaction.
// When a task is being processed, the `StateTransitionHistory` is compared with the imprinted task information to
// verify that a task is not referencing a stale state or that the task itself is not stale.
// For example, if the state has a history of `[{v: 1, t: 3}, {v: 2, t: 5}]`, task A `{v: 2, t: 4}` **is not**
// referencing stale state because for version `2` transitions `4-5` are valid, while task B `{v: 2, t: 6}` **is**
// referencing stale state because the transition count is out of range for version `2`.
// Furthermore, task C `{v: 1, t: 4}` itself is stale because it is referencing an impossible state, likely due to post
// split-brain reconciliation.
message VersionedTransition {
    // The namespace failover version at transition time.
    int64 namespace_failover_version = 1;
    // Maximum state transition count perceived during the specified namespace_failover_version.
    int64 max_transition_count = 2;
}

