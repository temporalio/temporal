// The MIT License
//
// Copyright (c) 2019 Temporal Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

syntax = "proto3";

package temporal.server.api.historyservice.v1;
option go_package = "go.temporal.io/server/api/historyservice/v1;historyservice";

import "google/protobuf/descriptor.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

import "temporal/api/activity/v1/message.proto";
import "temporal/api/common/v1/message.proto";
import "temporal/api/history/v1/message.proto";
import "temporal/api/taskqueue/v1/message.proto";
import "temporal/api/enums/v1/workflow.proto";
import "temporal/api/workflow/v1/message.proto";
import "temporal/api/query/v1/message.proto";
import "temporal/api/protocol/v1/message.proto";
import "temporal/api/failure/v1/message.proto";
import "temporal/api/nexus/v1/message.proto";

import "temporal/server/api/clock/v1/message.proto";
import "temporal/server/api/history/v1/message.proto";
import "temporal/server/api/enums/v1/cluster.proto";
import "temporal/server/api/enums/v1/common.proto";
import "temporal/server/api/enums/v1/workflow.proto";
import "temporal/server/api/workflow/v1/message.proto";
import "temporal/server/api/namespace/v1/message.proto";
import "temporal/server/api/replication/v1/message.proto";
import "temporal/server/api/persistence/v1/executions.proto";
import "temporal/server/api/persistence/v1/hsm.proto";
import "temporal/server/api/persistence/v1/workflow_mutable_state.proto";
import "temporal/server/api/taskqueue/v1/message.proto";
import "temporal/server/api/token/v1/message.proto";

import "temporal/api/workflowservice/v1/request_response.proto";
import "temporal/server/api/adminservice/v1/request_response.proto";
import "temporal/server/api/common/v1/dlq.proto";

extend google.protobuf.MessageOptions {
    optional RoutingOptions routing = 7234;
}

// RoutingOptions define how a request is routed to the appropriate host.
message RoutingOptions {
    // Routing is custom and implemented in the non-generated client/history/client.go.
    bool custom = 1;
    // Request will be routed to a random host.
    bool any_host = 2;
    // Request will be routed according to the specified shard ID field.
    string shard_id = 3;
    // Requested routed by task token or workflow ID may also specify how to obtain the namespace ID. Defaults to the
    // "namespace_id" field.
    string namespace_id = 4;
    // Request will be routed by resolving the namespace ID and workflow ID to a given shard.
    string workflow_id = 5;
    // Request will be routed by resolving the namespace ID and the workflow ID from this task token to a given shard.
    string task_token = 6;
    // Request will be routed by resolving the namespace ID and the workflow ID from the first task info element.
    string task_infos = 7;
}

message StartWorkflowExecutionRequest {
    option (routing).workflow_id = "start_request.workflow_id";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.StartWorkflowExecutionRequest start_request = 2;
    temporal.server.api.workflow.v1.ParentExecutionInfo parent_execution_info = 3;
    int32 attempt = 4;
    google.protobuf.Timestamp workflow_execution_expiration_time = 5;
    temporal.api.enums.v1.ContinueAsNewInitiator continue_as_new_initiator = 6;
    // History service should use the values of continued_failure and last_completion_result
    // here, not the ones in start_request (those are moved into here in the frontend).
    temporal.api.failure.v1.Failure continued_failure = 7;
    temporal.api.common.v1.Payloads last_completion_result = 8;
    google.protobuf.Duration first_workflow_task_backoff = 9;
    // For child or continued-as-new workflows, including a version here from the source
    // (parent/previous) will set the initial version stamp of this workflow.
    // Deprecated. use `inherited_build_id`
    temporal.api.common.v1.WorkerVersionStamp source_version_stamp = 10;
    // The root execution info of the new workflow.
    // For top-level workflows (ie., without parent), this field must be nil.
    temporal.server.api.workflow.v1.RootExecutionInfo root_execution_info = 11;
    // inherited build ID from parent/previous execution
    string inherited_build_id = 12;
}

message StartWorkflowExecutionResponse {
    string run_id = 1;
    temporal.server.api.clock.v1.VectorClock clock = 2;
    // Set if request_eager_execution is set on the start request 
    temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponse eager_workflow_task = 3;
    bool started = 4;
}

message GetMutableStateRequest {
    option (routing).workflow_id = "execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
    int64 expected_next_event_id = 3;
    bytes current_branch_token = 4;
    temporal.server.api.history.v1.VersionHistoryItem version_history_item = 5;
}

message GetMutableStateResponse {
    temporal.api.common.v1.WorkflowExecution execution = 1;
    temporal.api.common.v1.WorkflowType workflow_type = 2;
    int64 next_event_id = 3;
    int64 previous_started_event_id = 4;
    int64 last_first_event_id = 5;
    temporal.api.taskqueue.v1.TaskQueue task_queue = 6;
    temporal.api.taskqueue.v1.TaskQueue sticky_task_queue = 7;
    reserved 8;
    reserved 9;
    reserved 10;
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration sticky_task_queue_schedule_to_start_timeout = 11;
    reserved 12;
    bytes current_branch_token = 13;
    reserved 14;
    temporal.server.api.enums.v1.WorkflowExecutionState workflow_state = 15;
    temporal.api.enums.v1.WorkflowExecutionStatus workflow_status = 16;
    temporal.server.api.history.v1.VersionHistories version_histories = 17;
    bool is_sticky_task_queue_enabled = 18;
    int64 last_first_event_txn_id = 19;
    string first_execution_run_id = 20;
    // If using build-id based versioning: version stamp of last worker to complete a workflow
    // task for this workflow.
    temporal.api.common.v1.WorkerVersionStamp most_recent_worker_version_stamp = 21;
    // The currently assigned build ID for this execution. Presence of this value means worker versioning is used
    // for this execution.
    string assigned_build_id = 22;
    string inherited_build_id = 23;
    repeated temporal.server.api.persistence.v1.VersionedTransition transition_history = 24;
}

message PollMutableStateRequest {
    option (routing).workflow_id = "execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
    int64 expected_next_event_id = 3;
    bytes current_branch_token = 4;
    temporal.server.api.history.v1.VersionHistoryItem version_history_item = 5;
}

message PollMutableStateResponse {
    temporal.api.common.v1.WorkflowExecution execution = 1;
    temporal.api.common.v1.WorkflowType workflow_type = 2;
    int64 next_event_id = 3;
    int64 previous_started_event_id = 4;
    int64 last_first_event_id = 5;
    temporal.api.taskqueue.v1.TaskQueue task_queue = 6;
    temporal.api.taskqueue.v1.TaskQueue sticky_task_queue = 7;
    reserved 8;
    reserved 9;
    reserved 10;
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration sticky_task_queue_schedule_to_start_timeout = 11;
    bytes current_branch_token = 12;
    reserved 13;
    temporal.server.api.history.v1.VersionHistories version_histories = 14;
    temporal.server.api.enums.v1.WorkflowExecutionState workflow_state = 15;
    temporal.api.enums.v1.WorkflowExecutionStatus workflow_status = 16;
    int64 last_first_event_txn_id = 17;
    string first_execution_run_id = 18;
}

message ResetStickyTaskQueueRequest {
    option (routing).workflow_id = "execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
}

message ResetStickyTaskQueueResponse {
}

message ExecuteMultiOperationRequest {
    option (routing).workflow_id = "workflow_id";

    string namespace_id = 1;
    string workflow_id = 2;
    repeated Operation operations = 3;

    message Operation {
        oneof operation {
            StartWorkflowExecutionRequest start_workflow = 1;
            UpdateWorkflowExecutionRequest update_workflow = 2;
        }
    }
}

message ExecuteMultiOperationResponse {
    repeated Response responses = 1;

    message Response {
        oneof response {
            StartWorkflowExecutionResponse start_workflow = 1;
            UpdateWorkflowExecutionResponse update_workflow = 2;
        }
    }
}

message RecordWorkflowTaskStartedRequest {
    option (routing).workflow_id = "workflow_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    int64 scheduled_event_id = 3;
    reserved 4;
    // Unique id of each poll request. Used to ensure at most once delivery of tasks.
    string request_id = 5;
    temporal.api.workflowservice.v1.PollWorkflowTaskQueueRequest poll_request = 6;
    temporal.server.api.clock.v1.VectorClock clock = 7;
    temporal.server.api.taskqueue.v1.BuildIdRedirectInfo build_id_redirect_info = 8;
}

message RecordWorkflowTaskStartedResponse {
    temporal.api.common.v1.WorkflowType workflow_type = 1;
    int64 previous_started_event_id = 2;
    int64 scheduled_event_id = 3;
    int64 started_event_id = 4;
    int64 next_event_id = 5;
    int32 attempt = 6;
    bool sticky_execution_enabled = 7;
    temporal.server.api.history.v1.TransientWorkflowTaskInfo transient_workflow_task = 8;
    temporal.api.taskqueue.v1.TaskQueue workflow_execution_task_queue = 9;
    reserved 10;
    bytes branch_token = 11;
    google.protobuf.Timestamp scheduled_time = 12;
    google.protobuf.Timestamp started_time = 13;
    map<string, temporal.api.query.v1.WorkflowQuery> queries = 14;
    temporal.server.api.clock.v1.VectorClock clock = 15;
    repeated temporal.api.protocol.v1.Message messages = 16;
    int64 version = 17;
    temporal.api.history.v1.History history = 18;
    bytes next_page_token = 19;
}

message RecordActivityTaskStartedRequest {
    option (routing).workflow_id = "workflow_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    int64 scheduled_event_id = 3;
    reserved 4;
    // Unique id of each poll request. Used to ensure at most once delivery of tasks.
    string request_id = 5;
    temporal.api.workflowservice.v1.PollActivityTaskQueueRequest poll_request = 6;
    temporal.server.api.clock.v1.VectorClock clock = 7;
    temporal.server.api.taskqueue.v1.BuildIdRedirectInfo build_id_redirect_info = 8;
}

message RecordActivityTaskStartedResponse {
    temporal.api.history.v1.HistoryEvent scheduled_event = 1;
    google.protobuf.Timestamp started_time = 2;
    int32 attempt = 3;
    google.protobuf.Timestamp current_attempt_scheduled_time = 4;
    temporal.api.common.v1.Payloads heartbeat_details = 5;
    temporal.api.common.v1.WorkflowType workflow_type = 6;
    string workflow_namespace = 7;
    temporal.server.api.clock.v1.VectorClock clock = 8;
    int64 version = 9;
}

message RespondWorkflowTaskCompletedRequest {
    option (routing).task_token = "complete_request.task_token";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.RespondWorkflowTaskCompletedRequest complete_request = 2;
}

message RespondWorkflowTaskCompletedResponse {
    RecordWorkflowTaskStartedResponse started_response = 1 [deprecated = true];
    repeated temporal.api.workflowservice.v1.PollActivityTaskQueueResponse activity_tasks = 2;
    int64 reset_history_event_id = 3;
    temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponse new_workflow_task = 4;
}

message RespondWorkflowTaskFailedRequest {
    option (routing).task_token = "failed_request.task_token";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.RespondWorkflowTaskFailedRequest failed_request = 2;
}

message RespondWorkflowTaskFailedResponse {
}

message IsWorkflowTaskValidRequest {
    option (routing).workflow_id = "execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
    temporal.server.api.clock.v1.VectorClock clock = 3;
    int64 scheduled_event_id = 4;
}

message IsWorkflowTaskValidResponse {
    // whether matching service can call history service to start the workflow task
    bool is_valid = 1;
}

message RecordActivityTaskHeartbeatRequest {
    option (routing).task_token = "heartbeat_request.task_token";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.RecordActivityTaskHeartbeatRequest heartbeat_request = 2;
}

message RecordActivityTaskHeartbeatResponse {
    bool cancel_requested = 1;
}

message RespondActivityTaskCompletedRequest {
    option (routing).task_token = "complete_request.task_token";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest complete_request = 2;
}

message RespondActivityTaskCompletedResponse {
}

message RespondActivityTaskFailedRequest {
    option (routing).task_token = "failed_request.task_token";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.RespondActivityTaskFailedRequest failed_request = 2;
}

message RespondActivityTaskFailedResponse {
}

message RespondActivityTaskCanceledRequest {
    option (routing).task_token = "cancel_request.task_token";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.RespondActivityTaskCanceledRequest cancel_request = 2;
}

message RespondActivityTaskCanceledResponse {
}

message IsActivityTaskValidRequest {
    option (routing).workflow_id = "execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
    temporal.server.api.clock.v1.VectorClock clock = 3;
    int64 scheduled_event_id = 4;
}

message IsActivityTaskValidResponse {
    // whether matching service can call history service to start the activity task
    bool is_valid = 1;
}

message SignalWorkflowExecutionRequest {
    option (routing).workflow_id = "signal_request.workflow_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest signal_request = 2;
    temporal.api.common.v1.WorkflowExecution external_workflow_execution = 3;
    bool child_workflow_only = 4;
}

message SignalWorkflowExecutionResponse {
}

message SignalWithStartWorkflowExecutionRequest {
    option (routing).workflow_id = "signal_with_start_request.workflow_id";

    string namespace_id = 1;
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "with" is needed here. --)
    temporal.api.workflowservice.v1.SignalWithStartWorkflowExecutionRequest signal_with_start_request = 2;
}

message SignalWithStartWorkflowExecutionResponse {
    string run_id = 1;
    bool started = 2;
}

message RemoveSignalMutableStateRequest {
    option (routing).workflow_id = "workflow_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    string request_id = 3;
}

message RemoveSignalMutableStateResponse {
}

message TerminateWorkflowExecutionRequest {
    option (routing).workflow_id = "terminate_request.workflow_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest terminate_request = 2;
    temporal.api.common.v1.WorkflowExecution external_workflow_execution = 3;
    bool child_workflow_only = 4;
}

message TerminateWorkflowExecutionResponse {
}

message DeleteWorkflowExecutionRequest {
    option (routing).workflow_id = "workflow_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    reserved 3;
    bool closed_workflow_only = 4;
}

message DeleteWorkflowExecutionResponse {
}

message ResetWorkflowExecutionRequest {
    option (routing).workflow_id = "reset_request.workflow_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest reset_request = 2;
}

message ResetWorkflowExecutionResponse {
    string run_id = 1;
}

message RequestCancelWorkflowExecutionRequest {
    option (routing).workflow_id = "cancel_request.workflow_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest cancel_request = 2;
    int64 external_initiated_event_id = 3;
    temporal.api.common.v1.WorkflowExecution external_workflow_execution = 4;
    bool child_workflow_only = 5;
}

message RequestCancelWorkflowExecutionResponse {
}

message ScheduleWorkflowTaskRequest {
    option (routing).workflow_id = "workflow_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    bool is_first_workflow_task = 3;
    temporal.server.api.clock.v1.VectorClock child_clock = 4;
    temporal.server.api.clock.v1.VectorClock parent_clock = 5;
}

message ScheduleWorkflowTaskResponse {
}

message VerifyFirstWorkflowTaskScheduledRequest {
    option (routing).workflow_id = "workflow_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    temporal.server.api.clock.v1.VectorClock clock = 3;
}

message VerifyFirstWorkflowTaskScheduledResponse {
}

/**
* RecordChildExecutionCompletedRequest is used for reporting the completion of child execution to parent workflow
* execution which started it.  When a child execution is completed it creates this request and calls the
* RecordChildExecutionCompleted API with the workflowExecution of parent.  It also sets the completedExecution of the
* child as it could potentially be different than the ChildExecutionStartedEvent of parent in the situation when
* child creates multiple runs through ContinueAsNew before finally completing.
**/
message RecordChildExecutionCompletedRequest {
    option (routing).workflow_id = "parent_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution parent_execution = 2;
    int64 parent_initiated_id = 3;
    temporal.api.common.v1.WorkflowExecution child_execution = 4;
    temporal.api.history.v1.HistoryEvent completion_event = 5;
    temporal.server.api.clock.v1.VectorClock clock = 6;
    int64 parent_initiated_version = 7;
}

message RecordChildExecutionCompletedResponse {
}

message VerifyChildExecutionCompletionRecordedRequest {
    option (routing).workflow_id = "parent_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution parent_execution = 2;
    temporal.api.common.v1.WorkflowExecution child_execution = 3;
    int64 parent_initiated_id = 4;
    int64 parent_initiated_version = 5;
    temporal.server.api.clock.v1.VectorClock clock = 6;
}

message VerifyChildExecutionCompletionRecordedResponse {
}

message DescribeWorkflowExecutionRequest {
    option (routing).workflow_id = "request.execution.workflow_id";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.DescribeWorkflowExecutionRequest request = 2;
}

message DescribeWorkflowExecutionResponse {
    temporal.api.workflow.v1.WorkflowExecutionConfig execution_config = 1;
    temporal.api.workflow.v1.WorkflowExecutionInfo workflow_execution_info = 2;
    repeated temporal.api.workflow.v1.PendingActivityInfo pending_activities = 3;
    repeated temporal.api.workflow.v1.PendingChildExecutionInfo pending_children = 4;
    temporal.api.workflow.v1.PendingWorkflowTaskInfo pending_workflow_task = 5;
    repeated temporal.api.workflow.v1.CallbackInfo callbacks = 6;
    repeated temporal.api.workflow.v1.PendingNexusOperationInfo pending_nexus_operations = 7;
}

message ReplicateEventsV2Request {
    option (routing).workflow_id = "workflow_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    repeated temporal.server.api.history.v1.VersionHistoryItem version_history_items = 3;
    temporal.api.common.v1.DataBlob events = 4;
    // New run events does not need version history since there is no prior events.
    temporal.api.common.v1.DataBlob new_run_events = 5;
    temporal.server.api.workflow.v1.BaseExecutionInfo base_execution_info = 6;
    string new_run_id = 7;
}

message ReplicateEventsV2Response {
}

message ReplicateWorkflowStateRequest {
    option (routing).workflow_id = "workflow_state.execution_info.workflow_id";

    temporal.server.api.persistence.v1.WorkflowMutableState workflow_state = 1;
    string remote_cluster = 2;
    string namespace_id= 3;
}

message ReplicateWorkflowStateResponse {
}

message SyncShardStatusRequest {
    option (routing).shard_id = "shard_id";

    string source_cluster = 1;
    int32 shard_id = 2;
    google.protobuf.Timestamp status_time = 3;
}

message SyncShardStatusResponse {
}

message SyncActivityRequest {
    option (routing).workflow_id = "workflow_id";

    string namespace_id = 1;
    string workflow_id = 2;
    string run_id = 3;
    int64 version = 4;
    int64 scheduled_event_id = 5;
    google.protobuf.Timestamp scheduled_time = 6;
    int64 started_event_id = 7;
    google.protobuf.Timestamp started_time = 8;
    google.protobuf.Timestamp last_heartbeat_time = 9;
    temporal.api.common.v1.Payloads details = 10;
    int32 attempt = 11;
    temporal.api.failure.v1.Failure last_failure = 12;
    string last_worker_identity = 13;
    temporal.server.api.history.v1.VersionHistory version_history = 14;
    temporal.server.api.workflow.v1.BaseExecutionInfo base_execution_info = 15;
    // build ID of the worker who received this activity last time
    string last_started_build_id = 16;
    // workflows redirect_counter value when this activity started last time
    int64 last_started_redirect_counter = 17;
}

message SyncActivitiesRequest {
    option (routing).workflow_id = "workflow_id";

    string namespace_id = 1;
    string workflow_id = 2;
    string run_id = 3;
    repeated ActivitySyncInfo activities_info = 4;
}
message ActivitySyncInfo {
    int64 version = 1;
    int64 scheduled_event_id = 2;
    google.protobuf.Timestamp scheduled_time = 3;
    int64 started_event_id = 4;
    google.protobuf.Timestamp started_time = 5 ;
    google.protobuf.Timestamp last_heartbeat_time = 6;
    temporal.api.common.v1.Payloads details = 7;
    int32 attempt = 8;
    temporal.api.failure.v1.Failure last_failure = 9;
    string last_worker_identity = 10;
    temporal.server.api.history.v1.VersionHistory version_history = 11;
    // build ID of the worker who received this activity last time
    string last_started_build_id = 12;
    // workflows redirect_counter value when this activity started last time
    int64 last_started_redirect_counter = 13;
}

message SyncActivityResponse {
}

message DescribeMutableStateRequest {
    option (routing).workflow_id = "execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
}

message DescribeMutableStateResponse {
    temporal.server.api.persistence.v1.WorkflowMutableState cache_mutable_state = 1;
    temporal.server.api.persistence.v1.WorkflowMutableState database_mutable_state = 2;
}

// At least one of the parameters needs to be provided.
message DescribeHistoryHostRequest {
    option (routing).custom = true;

    //ip:port
    string host_address = 1;
    int32 shard_id = 2;
    string namespace_id = 3;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 4;
}

message DescribeHistoryHostResponse {
    int32 shards_number = 1;
    repeated int32
    shard_ids = 2;
    temporal.server.api.namespace.v1.NamespaceCacheInfo namespace_cache = 3;
    reserved 4;
    string address = 5;
}

message CloseShardRequest {
    option (routing).shard_id = "shard_id";

    int32 shard_id = 1;
}

message CloseShardResponse {
}

message GetShardRequest {
    option (routing).shard_id = "shard_id";

    int32 shard_id = 1;
}

message GetShardResponse {
    temporal.server.api.persistence.v1.ShardInfo shard_info = 1;
}

message RemoveTaskRequest {
    option (routing).shard_id = "shard_id";

    int32 shard_id = 1;
    // The task category. See tasks.TaskCategoryRegistry for more.
    int32 category = 2;
    int64 task_id = 3;
    google.protobuf.Timestamp visibility_time = 4;
}

message RemoveTaskResponse {
}

message GetReplicationMessagesRequest {
    option (routing).custom = true;

    repeated temporal.server.api.replication.v1.ReplicationToken tokens = 1;
    string cluster_name = 2;
}

message GetReplicationMessagesResponse {
    map<int32, temporal.server.api.replication.v1.ReplicationMessages> shard_messages = 1;
}

message GetDLQReplicationMessagesRequest {
    option (routing).task_infos = "task_infos";

    repeated temporal.server.api.replication.v1.ReplicationTaskInfo task_infos = 1;
}

message GetDLQReplicationMessagesResponse {
    repeated temporal.server.api.replication.v1.ReplicationTask replication_tasks = 1;
}

message QueryWorkflowRequest {
    option (routing).workflow_id = "request.execution.workflow_id";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.QueryWorkflowRequest request = 2;
}

message QueryWorkflowResponse {
    temporal.api.workflowservice.v1.QueryWorkflowResponse response = 1;
}

message ReapplyEventsRequest {
    option (routing).workflow_id = "request.workflow_execution.workflow_id";

    string namespace_id = 1;
    temporal.server.api.adminservice.v1.ReapplyEventsRequest request = 2;
}

message ReapplyEventsResponse {
}

message GetDLQMessagesRequest {
    option (routing).shard_id = "shard_id";

    temporal.server.api.enums.v1.DeadLetterQueueType type = 1;
    int32 shard_id = 2;
    string source_cluster = 3;
    int64 inclusive_end_message_id = 4;
    int32 maximum_page_size = 5;
    bytes next_page_token = 6;
}

message GetDLQMessagesResponse {
    temporal.server.api.enums.v1.DeadLetterQueueType type = 1;
    repeated temporal.server.api.replication.v1.ReplicationTask replication_tasks = 2;
    bytes next_page_token = 3;
    repeated temporal.server.api.replication.v1.ReplicationTaskInfo replication_tasks_info = 4;
}

message PurgeDLQMessagesRequest {
    option (routing).shard_id = "shard_id";

    temporal.server.api.enums.v1.DeadLetterQueueType type = 1;
    int32 shard_id = 2;
    string source_cluster = 3;
    int64 inclusive_end_message_id = 4;
}

message PurgeDLQMessagesResponse {
}

message MergeDLQMessagesRequest {
    option (routing).shard_id = "shard_id";

    temporal.server.api.enums.v1.DeadLetterQueueType type = 1;
    int32 shard_id = 2;
    string source_cluster = 3;
    int64 inclusive_end_message_id = 4;
    int32 maximum_page_size = 5;
    bytes next_page_token = 6;
}

message MergeDLQMessagesResponse {
    bytes next_page_token = 1;
}

message RefreshWorkflowTasksRequest {
    option (routing).workflow_id = "request.execution.workflow_id";

    string namespace_id = 1;
    temporal.server.api.adminservice.v1.RefreshWorkflowTasksRequest request = 2;
}

message RefreshWorkflowTasksResponse {
}

message GenerateLastHistoryReplicationTasksRequest {
    option (routing).workflow_id = "execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
}

message GenerateLastHistoryReplicationTasksResponse {
    int64 state_transition_count = 1;
    int64 history_length = 2;
}

message GetReplicationStatusRequest {
    option (routing).custom = true;

    // Remote cluster names to query for. If omit, will return for all remote clusters.
    repeated string remote_clusters = 1;
}

message GetReplicationStatusResponse {
    repeated ShardReplicationStatus shards = 1;
}

message ShardReplicationStatus {
    int32 shard_id = 1;
    // Max replication task id of current cluster
    int64 max_replication_task_id = 2;
    // Local time on this shard
    google.protobuf.Timestamp shard_local_time = 3;
    map<string, ShardReplicationStatusPerCluster> remote_clusters = 4;
    map<string, HandoverNamespaceInfo> handover_namespaces = 5;

    google.protobuf.Timestamp max_replication_task_visibility_time = 6;
}

message HandoverNamespaceInfo {
    // max replication task id when namespace transition to Handover state
    int64 handover_replication_task_id = 1;
}

message ShardReplicationStatusPerCluster {
    // Acked replication task id
    int64 acked_task_id = 1;
    // Acked replication task creation time
    google.protobuf.Timestamp acked_task_visibility_time = 2;
}

message RebuildMutableStateRequest {
    option (routing).workflow_id = "execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
}

message RebuildMutableStateResponse {
}

message ImportWorkflowExecutionRequest {
    option (routing).workflow_id = "execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
    repeated temporal.api.common.v1.DataBlob history_batches = 3;
    temporal.server.api.history.v1.VersionHistory version_history = 4;
    bytes token = 5;
}

message ImportWorkflowExecutionResponse {
    bytes token = 1;
    bool events_applied = 2;
}

message DeleteWorkflowVisibilityRecordRequest {
    option (routing).workflow_id = "execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
    google.protobuf.Timestamp workflow_start_time = 3;
    google.protobuf.Timestamp workflow_close_time = 4;
}

message DeleteWorkflowVisibilityRecordResponse {
}

// (-- api-linter: core::0134=disabled
//     aip.dev/not-precedent: This service does not follow the update method AIP --)
message UpdateWorkflowExecutionRequest {
    option (routing).workflow_id = "request.workflow_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.UpdateWorkflowExecutionRequest request = 2;
}

message UpdateWorkflowExecutionResponse {
    temporal.api.workflowservice.v1.UpdateWorkflowExecutionResponse response = 1;
}

message StreamWorkflowReplicationMessagesRequest {
    option (routing).custom = true;

    oneof attributes {
        temporal.server.api.replication.v1.SyncReplicationState sync_replication_state = 1;
    }
}

message StreamWorkflowReplicationMessagesResponse {
    oneof attributes {
        temporal.server.api.replication.v1.WorkflowReplicationMessages messages = 1;
    }
}

message PollWorkflowExecutionUpdateRequest {
    option (routing).workflow_id = "request.update_ref.workflow_execution.workflow_id";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.PollWorkflowExecutionUpdateRequest request = 2;
}

message PollWorkflowExecutionUpdateResponse {
    temporal.api.workflowservice.v1.PollWorkflowExecutionUpdateResponse response = 1;
}

message GetWorkflowExecutionHistoryRequest {
    option (routing).workflow_id = "request.execution.workflow_id";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryRequest request = 2;
}

message GetWorkflowExecutionHistoryResponse {
    temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryResponse response = 1;
}

message GetWorkflowExecutionHistoryReverseRequest {
    option (routing).workflow_id = "request.execution.workflow_id";

    string namespace_id = 1;
    temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryReverseRequest request = 2;
}

message GetWorkflowExecutionHistoryReverseResponse {
    temporal.api.workflowservice.v1.GetWorkflowExecutionHistoryReverseResponse response = 1;
}

/**
  * StartEventId defines the beginning of the event to fetch. The first event is exclusive.
  * EndEventId and EndEventVersion defines the end of the event to fetch. The end event is exclusive.
  **/
message GetWorkflowExecutionRawHistoryV2Request {
    option (routing).workflow_id = "request.execution.workflow_id";

    string namespace_id = 1;
    temporal.server.api.adminservice.v1.GetWorkflowExecutionRawHistoryV2Request request = 2;
}

message GetWorkflowExecutionRawHistoryV2Response {
    temporal.server.api.adminservice.v1.GetWorkflowExecutionRawHistoryV2Response response = 1;
}

message GetWorkflowExecutionRawHistoryRequest {
    option (routing).workflow_id = "request.execution.workflow_id";

    string namespace_id = 1;
    temporal.server.api.adminservice.v1.GetWorkflowExecutionRawHistoryRequest request = 2;
}

message GetWorkflowExecutionRawHistoryResponse {
    temporal.server.api.adminservice.v1.GetWorkflowExecutionRawHistoryResponse response = 1;
}

message ForceDeleteWorkflowExecutionRequest {
    option (routing).workflow_id = "request.execution.workflow_id";

    string namespace_id = 1;
    temporal.server.api.adminservice.v1.DeleteWorkflowExecutionRequest request = 2;
}

message ForceDeleteWorkflowExecutionResponse {
    temporal.server.api.adminservice.v1.DeleteWorkflowExecutionResponse response = 1;
}

message GetDLQTasksRequest {
    option (routing).any_host = true;

    temporal.server.api.common.v1.HistoryDLQKey dlq_key = 1;
    // page_size must be positive. Up to this many tasks will be returned.
    int32 page_size = 2;
    bytes next_page_token = 3;
}

message GetDLQTasksResponse {
    repeated temporal.server.api.common.v1.HistoryDLQTask dlq_tasks = 1;
    // next_page_token is empty if there are no more results. However, the converse is not true. If there are no more
    // results, this field may still be non-empty. This is to avoid having to do a count query to determine whether
    // there are more results.
    bytes next_page_token = 2;
}

message DeleteDLQTasksRequest {
    option (routing).any_host = true;

    temporal.server.api.common.v1.HistoryDLQKey dlq_key = 1;
    temporal.server.api.common.v1.HistoryDLQTaskMetadata inclusive_max_task_metadata = 2;
}

message DeleteDLQTasksResponse {
    // messages_deleted is the total number of messages deleted in DeleteDLQTasks operation.
    int64 messages_deleted = 1;
}

message ListQueuesRequest {
    option (routing).any_host = true;

    int32 queue_type = 1;
    int32 page_size = 2;
    bytes next_page_token = 3;
}

message ListQueuesResponse {
    message QueueInfo {
        string queue_name = 1;
        int64 message_count = 2;
    }
    repeated QueueInfo queues = 1;
    bytes next_page_token = 2;
}

message AddTasksRequest {
    option (routing).shard_id = "shard_id";

    // Even though we can obtain the shard ID from the tasks, we still need the shard_id in the request for routing. If
    // not, it would be possible to include tasks for shards that belong to different hosts, and we'd need to fan-out the
    // request, which would be more complicated.
    int32 shard_id = 1;

    message Task {
        // category_id is needed to deserialize the tasks. See TaskCategory for a list of options here. However, keep in mind
        // that the list of valid options is registered dynamically with the server in the history/tasks package, so that
        // enum is not comprehensive.
        int32 category_id = 1;
        // blob is the serialized task.
        temporal.api.common.v1.DataBlob blob = 2;
    }

    // A list of tasks to enqueue or re-enqueue.
    repeated Task tasks = 2;
}

message AddTasksResponse {}

message ListTasksRequest {
    option (routing).shard_id = "request.shard_id";

    temporal.server.api.adminservice.v1.ListHistoryTasksRequest request = 1;
}

message ListTasksResponse {
    temporal.server.api.adminservice.v1.ListHistoryTasksResponse response = 1;
}

message CompleteNexusOperationRequest {
    option (routing) = {
        namespace_id: "completion.namespace_id"
        workflow_id: "completion.workflow_id"
    };

    // Completion token - holds information for locating a run and the corresponding operation state machine.
    temporal.server.api.token.v1.NexusOperationCompletion completion = 1;
    // Operation state - may only be successful / failed / canceled.
    string state = 2;
    oneof outcome {
        // Result of a successful operation, only set if state == successful.
        temporal.api.common.v1.Payload success = 3;
        // Operation failure, only set if state != successful.
        temporal.api.nexus.v1.Failure failure = 4;
    }
}

message CompleteNexusOperationResponse {
}

message InvokeStateMachineMethodRequest {
    option (routing).workflow_id = "workflow_id";

    // TODO(Tianyu): This is the same as NexusOperationsCompletion but obviously is not about Nexus. This is because
    // State machine signaling is a generalization of the Nexus mechanisms. Perhaps eventually they should be merged.
    // Namespace UUID.
    string namespace_id = 1;
    // Workflow ID.
    string workflow_id = 2;
    // Run ID at the time this token was generated.
    string run_id = 3;
    // Reference including the path to the backing Operation state machine and a version + transition count for
    // staleness checks.
    temporal.server.api.persistence.v1.StateMachineRef ref = 4;

    // The method name to invoke. Methods must be explicitly registered for the target state machine in the state
    // machine registry, and accept an argument type of HistoryEvent that is the completion event of the completed
    // workflow.
    string method_name = 5;

    // Input, in serialized bytes, to the method. Users specify a deserializer during method registration for each state machine.
    bytes input = 6;
}

message InvokeStateMachineMethodResponse {
    // Output, in serialized bytes, of the method. Users specify a serializer during method registration for each state machine.
    bytes output = 1;
}

message DeepHealthCheckRequest {
    option (routing).custom = true;

    string host_address = 1;
}

message DeepHealthCheckResponse {
    temporal.server.api.enums.v1.HealthState state = 1;
}

message SyncWorkflowStateRequest {
    option (routing).workflow_id = "execution.workflow_id";

    string namespace_id = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
    temporal.server.api.persistence.v1.VersionedTransition versioned_transition = 3;
    temporal.server.api.history.v1.VersionHistories version_histories = 4;
    int32 target_cluster_id = 5;
}

message SyncWorkflowStateResponse {
    reserved 1;
    reserved 2;
    reserved 3;
    reserved 4;
    replication.v1.VersionedTransitionArtifact versioned_transition_artifact = 5;
}
// (-- api-linter: core::0134::request-mask-required=disabled
// (-- api-linter: core::0134::request-resource-required=disabled
message UpdateActivityOptionsRequest {
    option (routing).workflow_id = "update_request.workflow_id";

    // Namespace ID of the workflow which scheduled this activity
    string namespace_id = 1;

    temporal.api.workflowservice.v1.UpdateActivityOptionsByIdRequest update_request = 2;
}

message UpdateActivityOptionsResponse {
    // Activity options after an update
    temporal.api.activity.v1.ActivityOptions activity_options = 1;
}
