// The MIT License
//
// Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.
//
// Copyright (c) 2020 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Code generated by MockGen. DO NOT EDIT.
// Source: executor_factory.go

// Package history is a generated GoMock package.
package history

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	log "go.temporal.io/server/common/log"
	xdc "go.temporal.io/server/common/xdc"
	deletemanager "go.temporal.io/server/service/history/deletemanager"
	queues "go.temporal.io/server/service/history/queues"
	shard "go.temporal.io/server/service/history/shard"
	cache "go.temporal.io/server/service/history/workflow/cache"
)

// MockExecutorFactory is a mock of ExecutorFactory interface.
type MockExecutorFactory struct {
	ctrl     *gomock.Controller
	recorder *MockExecutorFactoryMockRecorder
}

// MockExecutorFactoryMockRecorder is the mock recorder for MockExecutorFactory.
type MockExecutorFactoryMockRecorder struct {
	mock *MockExecutorFactory
}

// NewMockExecutorFactory creates a new mock instance.
func NewMockExecutorFactory(ctrl *gomock.Controller) *MockExecutorFactory {
	mock := &MockExecutorFactory{ctrl: ctrl}
	mock.recorder = &MockExecutorFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExecutorFactory) EXPECT() *MockExecutorFactoryMockRecorder {
	return m.recorder
}

// CreateArchivalExecutor mocks base method.
func (m *MockExecutorFactory) CreateArchivalExecutor(shardCtx shard.Context, workflowCache cache.Cache, logger log.Logger) queues.Executor {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateArchivalExecutor", shardCtx, workflowCache, logger)
	ret0, _ := ret[0].(queues.Executor)
	return ret0
}

// CreateArchivalExecutor indicates an expected call of CreateArchivalExecutor.
func (mr *MockExecutorFactoryMockRecorder) CreateArchivalExecutor(shardCtx, workflowCache, logger interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateArchivalExecutor", reflect.TypeOf((*MockExecutorFactory)(nil).CreateArchivalExecutor), shardCtx, workflowCache, logger)
}

// CreateExecutorWrapper mocks base method.
func (m *MockExecutorFactory) CreateExecutorWrapper(currentClusterName string, activeExecutor, standbyExecutor queues.Executor, logger log.Logger) queues.Executor {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateExecutorWrapper", currentClusterName, activeExecutor, standbyExecutor, logger)
	ret0, _ := ret[0].(queues.Executor)
	return ret0
}

// CreateExecutorWrapper indicates an expected call of CreateExecutorWrapper.
func (mr *MockExecutorFactoryMockRecorder) CreateExecutorWrapper(currentClusterName, activeExecutor, standbyExecutor, logger interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateExecutorWrapper", reflect.TypeOf((*MockExecutorFactory)(nil).CreateExecutorWrapper), currentClusterName, activeExecutor, standbyExecutor, logger)
}

// CreateTimerActiveExecutor mocks base method.
func (m *MockExecutorFactory) CreateTimerActiveExecutor(shardCtx shard.Context, workflowCache cache.Cache, workflowDeleteManager deletemanager.DeleteManager, logger log.Logger) queues.Executor {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTimerActiveExecutor", shardCtx, workflowCache, workflowDeleteManager, logger)
	ret0, _ := ret[0].(queues.Executor)
	return ret0
}

// CreateTimerActiveExecutor indicates an expected call of CreateTimerActiveExecutor.
func (mr *MockExecutorFactoryMockRecorder) CreateTimerActiveExecutor(shardCtx, workflowCache, workflowDeleteManager, logger interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTimerActiveExecutor", reflect.TypeOf((*MockExecutorFactory)(nil).CreateTimerActiveExecutor), shardCtx, workflowCache, workflowDeleteManager, logger)
}

// CreateTimerExecutor mocks base method.
func (m *MockExecutorFactory) CreateTimerExecutor(shardCtx shard.Context, workflowCache cache.Cache, logger log.Logger, clusterName string) queues.Executor {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTimerExecutor", shardCtx, workflowCache, logger, clusterName)
	ret0, _ := ret[0].(queues.Executor)
	return ret0
}

// CreateTimerExecutor indicates an expected call of CreateTimerExecutor.
func (mr *MockExecutorFactoryMockRecorder) CreateTimerExecutor(shardCtx, workflowCache, logger, clusterName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTimerExecutor", reflect.TypeOf((*MockExecutorFactory)(nil).CreateTimerExecutor), shardCtx, workflowCache, logger, clusterName)
}

// CreateTimerStandbyExecutor mocks base method.
func (m *MockExecutorFactory) CreateTimerStandbyExecutor(shardCtx shard.Context, workflowCache cache.Cache, workflowDeleteManager deletemanager.DeleteManager, nDCHistoryResender xdc.NDCHistoryResender, logger log.Logger, clusterName string) queues.Executor {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTimerStandbyExecutor", shardCtx, workflowCache, workflowDeleteManager, nDCHistoryResender, logger, clusterName)
	ret0, _ := ret[0].(queues.Executor)
	return ret0
}

// CreateTimerStandbyExecutor indicates an expected call of CreateTimerStandbyExecutor.
func (mr *MockExecutorFactoryMockRecorder) CreateTimerStandbyExecutor(shardCtx, workflowCache, workflowDeleteManager, nDCHistoryResender, logger, clusterName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTimerStandbyExecutor", reflect.TypeOf((*MockExecutorFactory)(nil).CreateTimerStandbyExecutor), shardCtx, workflowCache, workflowDeleteManager, nDCHistoryResender, logger, clusterName)
}

// CreateTransferActiveExecutor mocks base method.
func (m *MockExecutorFactory) CreateTransferActiveExecutor(shardCtx shard.Context, workflowCache cache.Cache, logger log.Logger) queues.Executor {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTransferActiveExecutor", shardCtx, workflowCache, logger)
	ret0, _ := ret[0].(queues.Executor)
	return ret0
}

// CreateTransferActiveExecutor indicates an expected call of CreateTransferActiveExecutor.
func (mr *MockExecutorFactoryMockRecorder) CreateTransferActiveExecutor(shardCtx, workflowCache, logger interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTransferActiveExecutor", reflect.TypeOf((*MockExecutorFactory)(nil).CreateTransferActiveExecutor), shardCtx, workflowCache, logger)
}

// CreateTransferExecutor mocks base method.
func (m *MockExecutorFactory) CreateTransferExecutor(shardCtx shard.Context, workflowCache cache.Cache, logger log.Logger, clusterName string) queues.Executor {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTransferExecutor", shardCtx, workflowCache, logger, clusterName)
	ret0, _ := ret[0].(queues.Executor)
	return ret0
}

// CreateTransferExecutor indicates an expected call of CreateTransferExecutor.
func (mr *MockExecutorFactoryMockRecorder) CreateTransferExecutor(shardCtx, workflowCache, logger, clusterName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTransferExecutor", reflect.TypeOf((*MockExecutorFactory)(nil).CreateTransferExecutor), shardCtx, workflowCache, logger, clusterName)
}

// CreateTransferStandbyExecutor mocks base method.
func (m *MockExecutorFactory) CreateTransferStandbyExecutor(shardCtx shard.Context, workflowCache cache.Cache, nDCHistoryResender xdc.NDCHistoryResender, logger log.Logger, clusterName string) queues.Executor {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTransferStandbyExecutor", shardCtx, workflowCache, nDCHistoryResender, logger, clusterName)
	ret0, _ := ret[0].(queues.Executor)
	return ret0
}

// CreateTransferStandbyExecutor indicates an expected call of CreateTransferStandbyExecutor.
func (mr *MockExecutorFactoryMockRecorder) CreateTransferStandbyExecutor(shardCtx, workflowCache, nDCHistoryResender, logger, clusterName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTransferStandbyExecutor", reflect.TypeOf((*MockExecutorFactory)(nil).CreateTransferStandbyExecutor), shardCtx, workflowCache, nDCHistoryResender, logger, clusterName)
}

// CreateVisibilityExecutor mocks base method.
func (m *MockExecutorFactory) CreateVisibilityExecutor(shardCtx shard.Context, workflowCache cache.Cache, logger log.Logger) queues.Executor {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateVisibilityExecutor", shardCtx, workflowCache, logger)
	ret0, _ := ret[0].(queues.Executor)
	return ret0
}

// CreateVisibilityExecutor indicates an expected call of CreateVisibilityExecutor.
func (mr *MockExecutorFactoryMockRecorder) CreateVisibilityExecutor(shardCtx, workflowCache, logger interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateVisibilityExecutor", reflect.TypeOf((*MockExecutorFactory)(nil).CreateVisibilityExecutor), shardCtx, workflowCache, logger)
}
