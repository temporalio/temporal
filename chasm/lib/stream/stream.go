package stream

import (
	commonpb "go.temporal.io/api/common/v1"
	"go.temporal.io/api/workflowservice/v1"
	"go.temporal.io/server/chasm"
	streampb "go.temporal.io/server/chasm/lib/stream/gen/streampb/v1"
)

type Stream struct {
	chasm.UnimplementedComponent
	*streampb.StreamState
	Messages chasm.Map[int64, *commonpb.Payload]
	// Metadata ensures that even empty streams create at least one CHASM data field
	// Using an empty Payload as a marker to ensure CHASM persistence works correctly
	Metadata chasm.Field[*commonpb.Payload]
}

// NewStream returns an initialized CHASM stream root component.
func NewStream(
	ctx chasm.MutableContext,
	namespaceID, streamID, runID string,
	initialMessages []*commonpb.Payload,
) *Stream {
	s := &Stream{
		StreamState: &streampb.StreamState{
			Head:        0, // Read cursor
			Tail:        0, // Write cursor
			NamespaceId: namespaceID,
			StreamId:    streamID,
			RunId:       runID,
		},
		Messages: make(chasm.Map[int64, *commonpb.Payload]),
		// Always initialize Metadata to ensure at least one CHASM data field exists
		// This ensures proper persistence even for empty streams with no messages
		Metadata: chasm.NewDataField(ctx, &commonpb.Payload{}),
	}

	// Add initial messages if provided
	if len(initialMessages) > 0 {
		_, _ = s.AddMessages(ctx, initialMessages)
	}

	return s
}

// CreateStream initializes a new Stream for CreateStream requests.
func CreateStream(
	ctx chasm.MutableContext,
	req *streampb.CreateStreamRequest,
) (*Stream, *streampb.CreateStreamResponse, error) {
	// Get the RunID from the execution context (generated by CHASM)
	executionKey := ctx.ExecutionKey()

	stream := NewStream(
		ctx,
		req.NamespaceId,
		req.FrontendRequest.StreamId,
		executionKey.RunID,
		req.FrontendRequest.Messages,
	)

	return stream, &streampb.CreateStreamResponse{
		FrontendResponse: &workflowservice.CreateStreamResponse{
			RunId: stream.StreamState.RunId,
		},
	}, nil
}

func (s *Stream) LifecycleState(_ chasm.Context) chasm.LifecycleState {
	return chasm.LifecycleStateRunning
}

func (s *Stream) AddMessages(ctx chasm.MutableContext, messages []*commonpb.Payload) (int64, error) {
	// Initialize Messages map if nil (can happen after deserialization of empty stream)
	if s.Messages == nil {
		s.Messages = make(chasm.Map[int64, *commonpb.Payload])
	}

	var messageID int64
	for _, message := range messages {
		messageID = s.StreamState.Tail
		s.StreamState.Tail++
		s.Messages[messageID] = chasm.NewDataField(ctx, message)
	}
	return messageID, nil
}
