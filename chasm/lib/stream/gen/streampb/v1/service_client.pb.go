// Code generated by protoc-gen-go-chasm. DO NOT EDIT.
package streampb

import (
	"context"
	"time"

	"go.temporal.io/server/client/history"
	"go.temporal.io/server/common"
	"go.temporal.io/server/common/backoff"
	"go.temporal.io/server/common/config"
	"go.temporal.io/server/common/dynamicconfig"
	"go.temporal.io/server/common/headers"
	"go.temporal.io/server/common/log"
	"go.temporal.io/server/common/membership"
	"go.temporal.io/server/common/metrics"
	"go.temporal.io/server/common/primitives"
	"google.golang.org/grpc"
)

// StreamServiceLayeredClient is a client for StreamService.
type StreamServiceLayeredClient struct {
	metricsHandler metrics.Handler
	numShards      int32
	redirector     history.Redirector[StreamServiceClient]
	retryPolicy    backoff.RetryPolicy
}

// NewStreamServiceLayeredClient initializes a new StreamServiceLayeredClient.
func NewStreamServiceLayeredClient(
	dc *dynamicconfig.Collection,
	rpcFactory common.RPCFactory,
	monitor membership.Monitor,
	config *config.Persistence,
	logger log.Logger,
	metricsHandler metrics.Handler,
) (StreamServiceClient, error) {
	resolver, err := monitor.GetResolver(primitives.HistoryService)
	if err != nil {
		return nil, err
	}
	connections := history.NewConnectionPool(resolver, rpcFactory, NewStreamServiceClient)
	var redirector history.Redirector[StreamServiceClient]
	if dynamicconfig.HistoryClientOwnershipCachingEnabled.Get(dc)() {
		redirector = history.NewCachingRedirector(
			connections,
			resolver,
			logger,
			dynamicconfig.HistoryClientOwnershipCachingStaleTTL.Get(dc),
		)
	} else {
		redirector = history.NewBasicRedirector(connections, resolver)
	}
	return &StreamServiceLayeredClient{
		metricsHandler: metricsHandler,
		redirector:     redirector,
		numShards:      config.NumHistoryShards,
		retryPolicy:    common.CreateHistoryClientRetryPolicy(),
	}, nil
}
func (c *StreamServiceLayeredClient) callAddToStreamNoRetry(
	ctx context.Context,
	request *AddToStreamRequest,
	opts ...grpc.CallOption,
) (*AddToStreamResponse, error) {
	var response *AddToStreamResponse
	var err error
	startTime := time.Now().UTC()
	// the caller is a namespace, hence the tag below.
	caller := headers.GetCallerInfo(ctx).CallerName
	metricsHandler := c.metricsHandler.WithTags(
		metrics.OperationTag("StreamService.AddToStream"),
		metrics.NamespaceTag(caller),
		metrics.ServiceRoleTag(metrics.HistoryRoleTagValue),
	)
	metrics.ClientRequests.With(metricsHandler).Record(1)
	defer func() {
		if err != nil {
			metrics.ClientFailures.With(metricsHandler).Record(1, metrics.ServiceErrorTypeTag(err))
		}
		metrics.ClientLatency.With(metricsHandler).Record(time.Since(startTime))
	}()
	shardID := common.WorkflowIDToHistoryShard(request.GetNamespaceId(), request.GetFrontendRequest().GetStreamId(), c.numShards)
	op := func(ctx context.Context, client StreamServiceClient) error {
		var err error
		ctx, cancel := context.WithTimeout(ctx, history.DefaultTimeout)
		defer cancel()
		response, err = client.AddToStream(ctx, request, opts...)
		return err
	}
	err = c.redirector.Execute(ctx, shardID, op)
	return response, err
}
func (c *StreamServiceLayeredClient) AddToStream(
	ctx context.Context,
	request *AddToStreamRequest,
	opts ...grpc.CallOption,
) (*AddToStreamResponse, error) {
	call := func(ctx context.Context) (*AddToStreamResponse, error) {
		return c.callAddToStreamNoRetry(ctx, request, opts...)
	}
	return backoff.ThrottleRetryContextWithReturn(ctx, call, c.retryPolicy, common.IsServiceClientTransientError)
}
func (c *StreamServiceLayeredClient) callPollStreamNoRetry(
	ctx context.Context,
	request *PollStreamRequest,
	opts ...grpc.CallOption,
) (*PollStreamResponse, error) {
	var response *PollStreamResponse
	var err error
	startTime := time.Now().UTC()
	// the caller is a namespace, hence the tag below.
	caller := headers.GetCallerInfo(ctx).CallerName
	metricsHandler := c.metricsHandler.WithTags(
		metrics.OperationTag("StreamService.PollStream"),
		metrics.NamespaceTag(caller),
		metrics.ServiceRoleTag(metrics.HistoryRoleTagValue),
	)
	metrics.ClientRequests.With(metricsHandler).Record(1)
	defer func() {
		if err != nil {
			metrics.ClientFailures.With(metricsHandler).Record(1, metrics.ServiceErrorTypeTag(err))
		}
		metrics.ClientLatency.With(metricsHandler).Record(time.Since(startTime))
	}()
	shardID := common.WorkflowIDToHistoryShard(request.GetNamespaceId(), request.GetFrontendRequest().GetStreamId(), c.numShards)
	op := func(ctx context.Context, client StreamServiceClient) error {
		var err error
		ctx, cancel := context.WithTimeout(ctx, history.DefaultTimeout)
		defer cancel()
		response, err = client.PollStream(ctx, request, opts...)
		return err
	}
	err = c.redirector.Execute(ctx, shardID, op)
	return response, err
}
func (c *StreamServiceLayeredClient) PollStream(
	ctx context.Context,
	request *PollStreamRequest,
	opts ...grpc.CallOption,
) (*PollStreamResponse, error) {
	call := func(ctx context.Context) (*PollStreamResponse, error) {
		return c.callPollStreamNoRetry(ctx, request, opts...)
	}
	return backoff.ThrottleRetryContextWithReturn(ctx, call, c.retryPolicy, common.IsServiceClientTransientError)
}
