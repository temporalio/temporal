// Code generated by protoc-gen-go. DO NOT EDIT.
// plugins:
// 	protoc-gen-go
// 	protoc
// source: temporal/server/chasm/lib/scheduler/proto/v1/message.proto

package schedulerpb

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	v12 "go.temporal.io/api/common/v1"
	v13 "go.temporal.io/api/failure/v1"
	v1 "go.temporal.io/api/schedule/v1"
	v11 "go.temporal.io/server/api/schedule/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// CHASM scheduler top-level state.
type SchedulerState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Scheduler request parameters and metadata.
	Schedule *v1.Schedule     `protobuf:"bytes,2,opt,name=schedule,proto3" json:"schedule,omitempty"`
	Info     *v1.ScheduleInfo `protobuf:"bytes,3,opt,name=info,proto3" json:"info,omitempty"`
	// State common to all generators is stored in the top-level machine.
	Namespace   string `protobuf:"bytes,5,opt,name=namespace,proto3" json:"namespace,omitempty"`
	NamespaceId string `protobuf:"bytes,6,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	ScheduleId  string `protobuf:"bytes,7,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`
	// Implemented as a sequence number. Used for optimistic locking against
	// update requests.
	ConflictToken int64 `protobuf:"varint,8,opt,name=conflict_token,json=conflictToken,proto3" json:"conflict_token,omitempty"`
	// The closed flag is set true after a schedule completes, and the idle timer
	// expires.
	Closed        bool `protobuf:"varint,9,opt,name=closed,proto3" json:"closed,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchedulerState) Reset() {
	*x = SchedulerState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchedulerState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchedulerState) ProtoMessage() {}

func (x *SchedulerState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchedulerState.ProtoReflect.Descriptor instead.
func (*SchedulerState) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{0}
}

func (x *SchedulerState) GetSchedule() *v1.Schedule {
	if x != nil {
		return x.Schedule
	}
	return nil
}

func (x *SchedulerState) GetInfo() *v1.ScheduleInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

func (x *SchedulerState) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *SchedulerState) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *SchedulerState) GetScheduleId() string {
	if x != nil {
		return x.ScheduleId
	}
	return ""
}

func (x *SchedulerState) GetConflictToken() int64 {
	if x != nil {
		return x.ConflictToken
	}
	return 0
}

func (x *SchedulerState) GetClosed() bool {
	if x != nil {
		return x.Closed
	}
	return false
}

// CHASM scheduler's Generator internal state.
type GeneratorState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// High water mark.
	LastProcessedTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=last_processed_time,json=lastProcessedTime,proto3" json:"last_processed_time,omitempty"`
	// A list of upcoming times an action will be triggered.
	FutureActionTimes []*timestamppb.Timestamp `protobuf:"bytes,4,rep,name=future_action_times,json=futureActionTimes,proto3" json:"future_action_times,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GeneratorState) Reset() {
	*x = GeneratorState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeneratorState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeneratorState) ProtoMessage() {}

func (x *GeneratorState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeneratorState.ProtoReflect.Descriptor instead.
func (*GeneratorState) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{1}
}

func (x *GeneratorState) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastProcessedTime
	}
	return nil
}

func (x *GeneratorState) GetFutureActionTimes() []*timestamppb.Timestamp {
	if x != nil {
		return x.FutureActionTimes
	}
	return nil
}

// CHASM scheduler's Invoker internal state.
type InvokerState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Buffered starts that will be started by the Invoker.
	BufferedStarts []*v11.BufferedStart `protobuf:"bytes,2,rep,name=buffered_starts,json=bufferedStarts,proto3" json:"buffered_starts,omitempty"`
	// Workflow executions that will be cancelled due to overlap policy.
	CancelWorkflows []*v12.WorkflowExecution `protobuf:"bytes,3,rep,name=cancel_workflows,json=cancelWorkflows,proto3" json:"cancel_workflows,omitempty"`
	// Workflow executions that will be terminated due to overlap policy.
	TerminateWorkflows []*v12.WorkflowExecution `protobuf:"bytes,4,rep,name=terminate_workflows,json=terminateWorkflows,proto3" json:"terminate_workflows,omitempty"`
	// High water mark, used for evaluating when to fire tasks that are backing
	// off from a retry. LastProcessedTime is stored as state so that task
	// generation will be consistent, regardless of when generation occurs, such
	// as after applying a replicated state (as opposed to evaluating based on
	// present time).
	LastProcessedTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=last_processed_time,json=lastProcessedTime,proto3" json:"last_processed_time,omitempty"`
	// A map keyed by the request ID, mapping to the workflow ID started as part
	// of that request. Used to map received Nexus callbacks back to workflows.
	// Invoker adds to this mapwhen buffered starts are enqueued, and removed
	// when Invoker processes a completion.
	RequestIdToWorkflowId map[string]string `protobuf:"bytes,6,rep,name=request_id_to_workflow_id,json=requestIdToWorkflowId,proto3" json:"request_id_to_workflow_id,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *InvokerState) Reset() {
	*x = InvokerState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvokerState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvokerState) ProtoMessage() {}

func (x *InvokerState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InvokerState.ProtoReflect.Descriptor instead.
func (*InvokerState) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{2}
}

func (x *InvokerState) GetBufferedStarts() []*v11.BufferedStart {
	if x != nil {
		return x.BufferedStarts
	}
	return nil
}

func (x *InvokerState) GetCancelWorkflows() []*v12.WorkflowExecution {
	if x != nil {
		return x.CancelWorkflows
	}
	return nil
}

func (x *InvokerState) GetTerminateWorkflows() []*v12.WorkflowExecution {
	if x != nil {
		return x.TerminateWorkflows
	}
	return nil
}

func (x *InvokerState) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastProcessedTime
	}
	return nil
}

func (x *InvokerState) GetRequestIdToWorkflowId() map[string]string {
	if x != nil {
		return x.RequestIdToWorkflowId
	}
	return nil
}

// CHASM scheduler's Backfiller internal state. Backfill requests are 1:1
// with Backfiller nodes. Backfiller nodes also handle immediate trigger requests.
type BackfillerState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Request:
	//
	//	*BackfillerState_BackfillRequest
	//	*BackfillerState_TriggerRequest
	Request isBackfillerState_Request `protobuf_oneof:"request"`
	// Every Backfiller should be assigned a unique ID upon creation, used
	// for deduplication.
	BackfillId string `protobuf:"bytes,6,opt,name=backfill_id,json=backfillId,proto3" json:"backfill_id,omitempty"`
	// High water mark.
	LastProcessedTime *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=last_processed_time,json=lastProcessedTime,proto3" json:"last_processed_time,omitempty"`
	// Attempt count, incremented when the buffer is full and the Backfiller
	// needs to back off before retrying to fill.
	Attempt       int64 `protobuf:"varint,8,opt,name=attempt,proto3" json:"attempt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BackfillerState) Reset() {
	*x = BackfillerState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackfillerState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackfillerState) ProtoMessage() {}

func (x *BackfillerState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackfillerState.ProtoReflect.Descriptor instead.
func (*BackfillerState) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{3}
}

func (x *BackfillerState) GetRequest() isBackfillerState_Request {
	if x != nil {
		return x.Request
	}
	return nil
}

func (x *BackfillerState) GetBackfillRequest() *v1.BackfillRequest {
	if x != nil {
		if x, ok := x.Request.(*BackfillerState_BackfillRequest); ok {
			return x.BackfillRequest
		}
	}
	return nil
}

func (x *BackfillerState) GetTriggerRequest() *v1.TriggerImmediatelyRequest {
	if x != nil {
		if x, ok := x.Request.(*BackfillerState_TriggerRequest); ok {
			return x.TriggerRequest
		}
	}
	return nil
}

func (x *BackfillerState) GetBackfillId() string {
	if x != nil {
		return x.BackfillId
	}
	return ""
}

func (x *BackfillerState) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastProcessedTime
	}
	return nil
}

func (x *BackfillerState) GetAttempt() int64 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

type isBackfillerState_Request interface {
	isBackfillerState_Request()
}

type BackfillerState_BackfillRequest struct {
	BackfillRequest *v1.BackfillRequest `protobuf:"bytes,1,opt,name=backfill_request,json=backfillRequest,proto3,oneof"`
}

type BackfillerState_TriggerRequest struct {
	// When set, immediately buffer a single manual action.
	TriggerRequest *v1.TriggerImmediatelyRequest `protobuf:"bytes,2,opt,name=trigger_request,json=triggerRequest,proto3,oneof"`
}

func (*BackfillerState_BackfillRequest) isBackfillerState_Request() {}

func (*BackfillerState_TriggerRequest) isBackfillerState_Request() {}

// CHASM scheduler retains the payload data for the last completed workflow. Both
// last success and failure are stored simultaneously.
type LastCompletionResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       *v12.Payload           `protobuf:"bytes,1,opt,name=success,proto3" json:"success,omitempty"`
	Failure       *v13.Failure           `protobuf:"bytes,2,opt,name=failure,proto3" json:"failure,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LastCompletionResult) Reset() {
	*x = LastCompletionResult{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LastCompletionResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LastCompletionResult) ProtoMessage() {}

func (x *LastCompletionResult) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LastCompletionResult.ProtoReflect.Descriptor instead.
func (*LastCompletionResult) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{4}
}

func (x *LastCompletionResult) GetSuccess() *v12.Payload {
	if x != nil {
		return x.Success
	}
	return nil
}

func (x *LastCompletionResult) GetFailure() *v13.Failure {
	if x != nil {
		return x.Failure
	}
	return nil
}

var File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto protoreflect.FileDescriptor

const file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc = "" +
	"\n" +
	":temporal/server/chasm/lib/scheduler/proto/v1/message.proto\x12,temporal.server.chasm.lib.scheduler.proto.v1\x1a$temporal/api/common/v1/message.proto\x1a%temporal/api/failure/v1/message.proto\x1a&temporal/api/schedule/v1/message.proto\x1a-temporal/server/api/schedule/v1/message.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xad\x02\n" +
	"\x0eSchedulerState\x12>\n" +
	"\bschedule\x18\x02 \x01(\v2\".temporal.api.schedule.v1.ScheduleR\bschedule\x12:\n" +
	"\x04info\x18\x03 \x01(\v2&.temporal.api.schedule.v1.ScheduleInfoR\x04info\x12\x1c\n" +
	"\tnamespace\x18\x05 \x01(\tR\tnamespace\x12!\n" +
	"\fnamespace_id\x18\x06 \x01(\tR\vnamespaceId\x12\x1f\n" +
	"\vschedule_id\x18\a \x01(\tR\n" +
	"scheduleId\x12%\n" +
	"\x0econflict_token\x18\b \x01(\x03R\rconflictToken\x12\x16\n" +
	"\x06closed\x18\t \x01(\bR\x06closed\"\xa8\x01\n" +
	"\x0eGeneratorState\x12J\n" +
	"\x13last_processed_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTime\x12J\n" +
	"\x13future_action_times\x18\x04 \x03(\v2\x1a.google.protobuf.TimestampR\x11futureActionTimes\"\xc1\x04\n" +
	"\fInvokerState\x12W\n" +
	"\x0fbuffered_starts\x18\x02 \x03(\v2..temporal.server.api.schedule.v1.BufferedStartR\x0ebufferedStarts\x12T\n" +
	"\x10cancel_workflows\x18\x03 \x03(\v2).temporal.api.common.v1.WorkflowExecutionR\x0fcancelWorkflows\x12Z\n" +
	"\x13terminate_workflows\x18\x04 \x03(\v2).temporal.api.common.v1.WorkflowExecutionR\x12terminateWorkflows\x12J\n" +
	"\x13last_processed_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTime\x12\x8f\x01\n" +
	"\x19request_id_to_workflow_id\x18\x06 \x03(\v2U.temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.RequestIdToWorkflowIdEntryR\x15requestIdToWorkflowId\x1aH\n" +
	"\x1aRequestIdToWorkflowIdEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xdb\x02\n" +
	"\x0fBackfillerState\x12V\n" +
	"\x10backfill_request\x18\x01 \x01(\v2).temporal.api.schedule.v1.BackfillRequestH\x00R\x0fbackfillRequest\x12^\n" +
	"\x0ftrigger_request\x18\x02 \x01(\v23.temporal.api.schedule.v1.TriggerImmediatelyRequestH\x00R\x0etriggerRequest\x12\x1f\n" +
	"\vbackfill_id\x18\x06 \x01(\tR\n" +
	"backfillId\x12J\n" +
	"\x13last_processed_time\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTime\x12\x18\n" +
	"\aattempt\x18\b \x01(\x03R\aattemptB\t\n" +
	"\arequest\"\x8d\x01\n" +
	"\x14LastCompletionResult\x129\n" +
	"\asuccess\x18\x01 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\asuccess\x12:\n" +
	"\afailure\x18\x02 \x01(\v2 .temporal.api.failure.v1.FailureR\afailureBGZEgo.temporal.io/server/chasm/lib/scheduler/gen/schedulerpb;schedulerpbb\x06proto3"

var (
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescOnce sync.Once
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescData []byte
)

func file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP() []byte {
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescOnce.Do(func() {
		file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc), len(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc)))
	})
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescData
}

var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes = []any{
	(*SchedulerState)(nil),               // 0: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerState
	(*GeneratorState)(nil),               // 1: temporal.server.chasm.lib.scheduler.proto.v1.GeneratorState
	(*InvokerState)(nil),                 // 2: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState
	(*BackfillerState)(nil),              // 3: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState
	(*LastCompletionResult)(nil),         // 4: temporal.server.chasm.lib.scheduler.proto.v1.LastCompletionResult
	nil,                                  // 5: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.RequestIdToWorkflowIdEntry
	(*v1.Schedule)(nil),                  // 6: temporal.api.schedule.v1.Schedule
	(*v1.ScheduleInfo)(nil),              // 7: temporal.api.schedule.v1.ScheduleInfo
	(*timestamppb.Timestamp)(nil),        // 8: google.protobuf.Timestamp
	(*v11.BufferedStart)(nil),            // 9: temporal.server.api.schedule.v1.BufferedStart
	(*v12.WorkflowExecution)(nil),        // 10: temporal.api.common.v1.WorkflowExecution
	(*v1.BackfillRequest)(nil),           // 11: temporal.api.schedule.v1.BackfillRequest
	(*v1.TriggerImmediatelyRequest)(nil), // 12: temporal.api.schedule.v1.TriggerImmediatelyRequest
	(*v12.Payload)(nil),                  // 13: temporal.api.common.v1.Payload
	(*v13.Failure)(nil),                  // 14: temporal.api.failure.v1.Failure
}
var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs = []int32{
	6,  // 0: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerState.schedule:type_name -> temporal.api.schedule.v1.Schedule
	7,  // 1: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerState.info:type_name -> temporal.api.schedule.v1.ScheduleInfo
	8,  // 2: temporal.server.chasm.lib.scheduler.proto.v1.GeneratorState.last_processed_time:type_name -> google.protobuf.Timestamp
	8,  // 3: temporal.server.chasm.lib.scheduler.proto.v1.GeneratorState.future_action_times:type_name -> google.protobuf.Timestamp
	9,  // 4: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.buffered_starts:type_name -> temporal.server.api.schedule.v1.BufferedStart
	10, // 5: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.cancel_workflows:type_name -> temporal.api.common.v1.WorkflowExecution
	10, // 6: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.terminate_workflows:type_name -> temporal.api.common.v1.WorkflowExecution
	8,  // 7: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.last_processed_time:type_name -> google.protobuf.Timestamp
	5,  // 8: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.request_id_to_workflow_id:type_name -> temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.RequestIdToWorkflowIdEntry
	11, // 9: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState.backfill_request:type_name -> temporal.api.schedule.v1.BackfillRequest
	12, // 10: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState.trigger_request:type_name -> temporal.api.schedule.v1.TriggerImmediatelyRequest
	8,  // 11: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState.last_processed_time:type_name -> google.protobuf.Timestamp
	13, // 12: temporal.server.chasm.lib.scheduler.proto.v1.LastCompletionResult.success:type_name -> temporal.api.common.v1.Payload
	14, // 13: temporal.server.chasm.lib.scheduler.proto.v1.LastCompletionResult.failure:type_name -> temporal.api.failure.v1.Failure
	14, // [14:14] is the sub-list for method output_type
	14, // [14:14] is the sub-list for method input_type
	14, // [14:14] is the sub-list for extension type_name
	14, // [14:14] is the sub-list for extension extendee
	0,  // [0:14] is the sub-list for field type_name
}

func init() { file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_init() }
func file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_init() {
	if File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto != nil {
		return
	}
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3].OneofWrappers = []any{
		(*BackfillerState_BackfillRequest)(nil),
		(*BackfillerState_TriggerRequest)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc), len(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes,
		DependencyIndexes: file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs,
		MessageInfos:      file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes,
	}.Build()
	File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto = out.File
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes = nil
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs = nil
}
