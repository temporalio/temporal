// Code generated by protoc-gen-go. DO NOT EDIT.
// plugins:
// 	protoc-gen-go
// 	protoc
// source: temporal/server/chasm/lib/scheduler/proto/v1/message.proto

package schedulerpb

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	v12 "go.temporal.io/api/common/v1"
	v1 "go.temporal.io/api/schedule/v1"
	v11 "go.temporal.io/server/api/schedule/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// CHASM scheduler top-level state.
type SchedulerState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Scheduler request parameters and metadata.
	Schedule     *v1.Schedule      `protobuf:"bytes,2,opt,name=schedule,proto3" json:"schedule,omitempty"`
	Info         *v1.ScheduleInfo  `protobuf:"bytes,3,opt,name=info,proto3" json:"info,omitempty"`
	InitialPatch *v1.SchedulePatch `protobuf:"bytes,4,opt,name=initial_patch,json=initialPatch,proto3" json:"initial_patch,omitempty"`
	// State common to all generators is stored in the top-level machine.
	Namespace   string `protobuf:"bytes,5,opt,name=namespace,proto3" json:"namespace,omitempty"`
	NamespaceId string `protobuf:"bytes,6,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	ScheduleId  string `protobuf:"bytes,7,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`
	// Implemented as a sequence number. Used for optimistic locking against
	// update requests.
	ConflictToken int64 `protobuf:"varint,8,opt,name=conflict_token,json=conflictToken,proto3" json:"conflict_token,omitempty"`
	// The closed flag is set true after a schedule completes, and the idle timer
	// expires.
	Closed        bool `protobuf:"varint,9,opt,name=closed,proto3" json:"closed,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchedulerState) Reset() {
	*x = SchedulerState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchedulerState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchedulerState) ProtoMessage() {}

func (x *SchedulerState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchedulerState.ProtoReflect.Descriptor instead.
func (*SchedulerState) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{0}
}

func (x *SchedulerState) GetSchedule() *v1.Schedule {
	if x != nil {
		return x.Schedule
	}
	return nil
}

func (x *SchedulerState) GetInfo() *v1.ScheduleInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

func (x *SchedulerState) GetInitialPatch() *v1.SchedulePatch {
	if x != nil {
		return x.InitialPatch
	}
	return nil
}

func (x *SchedulerState) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *SchedulerState) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *SchedulerState) GetScheduleId() string {
	if x != nil {
		return x.ScheduleId
	}
	return ""
}

func (x *SchedulerState) GetConflictToken() int64 {
	if x != nil {
		return x.ConflictToken
	}
	return 0
}

func (x *SchedulerState) GetClosed() bool {
	if x != nil {
		return x.Closed
	}
	return false
}

// CHASM scheduler's Generator internal state.
type GeneratorState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// High water mark.
	LastProcessedTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=last_processed_time,json=lastProcessedTime,proto3" json:"last_processed_time,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GeneratorState) Reset() {
	*x = GeneratorState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeneratorState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeneratorState) ProtoMessage() {}

func (x *GeneratorState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeneratorState.ProtoReflect.Descriptor instead.
func (*GeneratorState) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{1}
}

func (x *GeneratorState) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastProcessedTime
	}
	return nil
}

// CHASM scheduler's Invoker internal state.
type InvokerState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Buffered starts that will be started by the Invoker.
	BufferedStarts []*v11.BufferedStart `protobuf:"bytes,2,rep,name=buffered_starts,json=bufferedStarts,proto3" json:"buffered_starts,omitempty"`
	// Workflow executions that will be cancelled due to overlap policy.
	CancelWorkflows []*v12.WorkflowExecution `protobuf:"bytes,3,rep,name=cancel_workflows,json=cancelWorkflows,proto3" json:"cancel_workflows,omitempty"`
	// Workflow executions that will be terminated due to overlap policy.
	TerminateWorkflows []*v12.WorkflowExecution `protobuf:"bytes,4,rep,name=terminate_workflows,json=terminateWorkflows,proto3" json:"terminate_workflows,omitempty"`
	// High water mark, used for evaluating when to fire tasks that are backing
	// off from a retry. LastProcessedTime is stored as state so that task
	// generation will be consistent, regardless of when generation occurs, such
	// as after applying a replicated state (as opposed to evaluating based on
	// present time).
	LastProcessedTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=last_processed_time,json=lastProcessedTime,proto3" json:"last_processed_time,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *InvokerState) Reset() {
	*x = InvokerState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvokerState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvokerState) ProtoMessage() {}

func (x *InvokerState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InvokerState.ProtoReflect.Descriptor instead.
func (*InvokerState) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{2}
}

func (x *InvokerState) GetBufferedStarts() []*v11.BufferedStart {
	if x != nil {
		return x.BufferedStarts
	}
	return nil
}

func (x *InvokerState) GetCancelWorkflows() []*v12.WorkflowExecution {
	if x != nil {
		return x.CancelWorkflows
	}
	return nil
}

func (x *InvokerState) GetTerminateWorkflows() []*v12.WorkflowExecution {
	if x != nil {
		return x.TerminateWorkflows
	}
	return nil
}

func (x *InvokerState) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastProcessedTime
	}
	return nil
}

// CHASM scheduler's Backfiller internal state. Backfill requests are 1:1
// with Backfiller nodes. Backfiller nodes also handle immediate trigger requests.
type BackfillerState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Request:
	//
	//	*BackfillerState_BackfillRequest
	//	*BackfillerState_TriggerRequest
	Request isBackfillerState_Request `protobuf_oneof:"request"`
	// Every Backfiller should be assigned a unique ID upon creation, used
	// for deduplication.
	BackfillId string `protobuf:"bytes,6,opt,name=backfill_id,json=backfillId,proto3" json:"backfill_id,omitempty"`
	// High water mark.
	LastProcessedTime *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=last_processed_time,json=lastProcessedTime,proto3" json:"last_processed_time,omitempty"`
	// Attempt count, incremented when the buffer is full and the Backfiller
	// needs to back off before retrying to fill.
	Attempt       int64 `protobuf:"varint,8,opt,name=attempt,proto3" json:"attempt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BackfillerState) Reset() {
	*x = BackfillerState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackfillerState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackfillerState) ProtoMessage() {}

func (x *BackfillerState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackfillerState.ProtoReflect.Descriptor instead.
func (*BackfillerState) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{3}
}

func (x *BackfillerState) GetRequest() isBackfillerState_Request {
	if x != nil {
		return x.Request
	}
	return nil
}

func (x *BackfillerState) GetBackfillRequest() *v1.BackfillRequest {
	if x != nil {
		if x, ok := x.Request.(*BackfillerState_BackfillRequest); ok {
			return x.BackfillRequest
		}
	}
	return nil
}

func (x *BackfillerState) GetTriggerRequest() *v1.TriggerImmediatelyRequest {
	if x != nil {
		if x, ok := x.Request.(*BackfillerState_TriggerRequest); ok {
			return x.TriggerRequest
		}
	}
	return nil
}

func (x *BackfillerState) GetBackfillId() string {
	if x != nil {
		return x.BackfillId
	}
	return ""
}

func (x *BackfillerState) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastProcessedTime
	}
	return nil
}

func (x *BackfillerState) GetAttempt() int64 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

type isBackfillerState_Request interface {
	isBackfillerState_Request()
}

type BackfillerState_BackfillRequest struct {
	BackfillRequest *v1.BackfillRequest `protobuf:"bytes,1,opt,name=backfill_request,json=backfillRequest,proto3,oneof"`
}

type BackfillerState_TriggerRequest struct {
	// When set, immediately buffer a single manual action.
	TriggerRequest *v1.TriggerImmediatelyRequest `protobuf:"bytes,2,opt,name=trigger_request,json=triggerRequest,proto3,oneof"`
}

func (*BackfillerState_BackfillRequest) isBackfillerState_Request() {}

func (*BackfillerState_TriggerRequest) isBackfillerState_Request() {}

var File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto protoreflect.FileDescriptor

const file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc = "" +
	"\n" +
	":temporal/server/chasm/lib/scheduler/proto/v1/message.proto\x12,temporal.server.chasm.lib.scheduler.proto.v1\x1a$temporal/api/common/v1/message.proto\x1a&temporal/api/schedule/v1/message.proto\x1a-temporal/server/api/schedule/v1/message.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xfb\x02\n" +
	"\x0eSchedulerState\x12>\n" +
	"\bschedule\x18\x02 \x01(\v2\".temporal.api.schedule.v1.ScheduleR\bschedule\x12:\n" +
	"\x04info\x18\x03 \x01(\v2&.temporal.api.schedule.v1.ScheduleInfoR\x04info\x12L\n" +
	"\rinitial_patch\x18\x04 \x01(\v2'.temporal.api.schedule.v1.SchedulePatchR\finitialPatch\x12\x1c\n" +
	"\tnamespace\x18\x05 \x01(\tR\tnamespace\x12!\n" +
	"\fnamespace_id\x18\x06 \x01(\tR\vnamespaceId\x12\x1f\n" +
	"\vschedule_id\x18\a \x01(\tR\n" +
	"scheduleId\x12%\n" +
	"\x0econflict_token\x18\b \x01(\x03R\rconflictToken\x12\x16\n" +
	"\x06closed\x18\t \x01(\bR\x06closed\"\\\n" +
	"\x0eGeneratorState\x12J\n" +
	"\x13last_processed_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTime\"\xe5\x02\n" +
	"\fInvokerState\x12W\n" +
	"\x0fbuffered_starts\x18\x02 \x03(\v2..temporal.server.api.schedule.v1.BufferedStartR\x0ebufferedStarts\x12T\n" +
	"\x10cancel_workflows\x18\x03 \x03(\v2).temporal.api.common.v1.WorkflowExecutionR\x0fcancelWorkflows\x12Z\n" +
	"\x13terminate_workflows\x18\x04 \x03(\v2).temporal.api.common.v1.WorkflowExecutionR\x12terminateWorkflows\x12J\n" +
	"\x13last_processed_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTime\"\xdb\x02\n" +
	"\x0fBackfillerState\x12V\n" +
	"\x10backfill_request\x18\x01 \x01(\v2).temporal.api.schedule.v1.BackfillRequestH\x00R\x0fbackfillRequest\x12^\n" +
	"\x0ftrigger_request\x18\x02 \x01(\v23.temporal.api.schedule.v1.TriggerImmediatelyRequestH\x00R\x0etriggerRequest\x12\x1f\n" +
	"\vbackfill_id\x18\x06 \x01(\tR\n" +
	"backfillId\x12J\n" +
	"\x13last_processed_time\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTime\x12\x18\n" +
	"\aattempt\x18\b \x01(\x03R\aattemptB\t\n" +
	"\arequestBGZEgo.temporal.io/server/chasm/lib/scheduler/gen/schedulerpb;schedulerpbb\x06proto3"

var (
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescOnce sync.Once
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescData []byte
)

func file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP() []byte {
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescOnce.Do(func() {
		file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc), len(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc)))
	})
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescData
}

var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes = []any{
	(*SchedulerState)(nil),               // 0: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerState
	(*GeneratorState)(nil),               // 1: temporal.server.chasm.lib.scheduler.proto.v1.GeneratorState
	(*InvokerState)(nil),                 // 2: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState
	(*BackfillerState)(nil),              // 3: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState
	(*v1.Schedule)(nil),                  // 4: temporal.api.schedule.v1.Schedule
	(*v1.ScheduleInfo)(nil),              // 5: temporal.api.schedule.v1.ScheduleInfo
	(*v1.SchedulePatch)(nil),             // 6: temporal.api.schedule.v1.SchedulePatch
	(*timestamppb.Timestamp)(nil),        // 7: google.protobuf.Timestamp
	(*v11.BufferedStart)(nil),            // 8: temporal.server.api.schedule.v1.BufferedStart
	(*v12.WorkflowExecution)(nil),        // 9: temporal.api.common.v1.WorkflowExecution
	(*v1.BackfillRequest)(nil),           // 10: temporal.api.schedule.v1.BackfillRequest
	(*v1.TriggerImmediatelyRequest)(nil), // 11: temporal.api.schedule.v1.TriggerImmediatelyRequest
}
var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs = []int32{
	4,  // 0: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerState.schedule:type_name -> temporal.api.schedule.v1.Schedule
	5,  // 1: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerState.info:type_name -> temporal.api.schedule.v1.ScheduleInfo
	6,  // 2: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerState.initial_patch:type_name -> temporal.api.schedule.v1.SchedulePatch
	7,  // 3: temporal.server.chasm.lib.scheduler.proto.v1.GeneratorState.last_processed_time:type_name -> google.protobuf.Timestamp
	8,  // 4: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.buffered_starts:type_name -> temporal.server.api.schedule.v1.BufferedStart
	9,  // 5: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.cancel_workflows:type_name -> temporal.api.common.v1.WorkflowExecution
	9,  // 6: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.terminate_workflows:type_name -> temporal.api.common.v1.WorkflowExecution
	7,  // 7: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.last_processed_time:type_name -> google.protobuf.Timestamp
	10, // 8: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState.backfill_request:type_name -> temporal.api.schedule.v1.BackfillRequest
	11, // 9: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState.trigger_request:type_name -> temporal.api.schedule.v1.TriggerImmediatelyRequest
	7,  // 10: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState.last_processed_time:type_name -> google.protobuf.Timestamp
	11, // [11:11] is the sub-list for method output_type
	11, // [11:11] is the sub-list for method input_type
	11, // [11:11] is the sub-list for extension type_name
	11, // [11:11] is the sub-list for extension extendee
	0,  // [0:11] is the sub-list for field type_name
}

func init() { file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_init() }
func file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_init() {
	if File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto != nil {
		return
	}
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3].OneofWrappers = []any{
		(*BackfillerState_BackfillRequest)(nil),
		(*BackfillerState_TriggerRequest)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc), len(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes,
		DependencyIndexes: file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs,
		MessageInfos:      file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes,
	}.Build()
	File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto = out.File
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes = nil
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs = nil
}
