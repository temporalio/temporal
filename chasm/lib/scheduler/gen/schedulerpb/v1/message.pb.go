// Code generated by protoc-gen-go. DO NOT EDIT.
// plugins:
// 	protoc-gen-go
// 	protoc
// source: temporal/server/chasm/lib/scheduler/proto/v1/message.proto

package schedulerpb

import (
	reflect "reflect"
	"strconv"
	unsafe "unsafe"

	v12 "go.temporal.io/api/common/v1"
	v13 "go.temporal.io/api/failure/v1"
	v1 "go.temporal.io/api/schedule/v1"
	v11 "go.temporal.io/server/api/schedule/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// CHASM scheduler top-level state.
type SchedulerState struct {
	state                    protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Schedule      *v1.Schedule           `protobuf:"bytes,2,opt,name=schedule,proto3"`
	xxx_hidden_Info          *v1.ScheduleInfo       `protobuf:"bytes,3,opt,name=info,proto3"`
	xxx_hidden_Namespace     string                 `protobuf:"bytes,5,opt,name=namespace,proto3"`
	xxx_hidden_NamespaceId   string                 `protobuf:"bytes,6,opt,name=namespace_id,json=namespaceId,proto3"`
	xxx_hidden_ScheduleId    string                 `protobuf:"bytes,7,opt,name=schedule_id,json=scheduleId,proto3"`
	xxx_hidden_ConflictToken int64                  `protobuf:"varint,8,opt,name=conflict_token,json=conflictToken,proto3"`
	xxx_hidden_Closed        bool                   `protobuf:"varint,9,opt,name=closed,proto3"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *SchedulerState) Reset() {
	*x = SchedulerState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchedulerState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchedulerState) ProtoMessage() {}

func (x *SchedulerState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *SchedulerState) GetSchedule() *v1.Schedule {
	if x != nil {
		return x.xxx_hidden_Schedule
	}
	return nil
}

func (x *SchedulerState) GetInfo() *v1.ScheduleInfo {
	if x != nil {
		return x.xxx_hidden_Info
	}
	return nil
}

func (x *SchedulerState) GetNamespace() string {
	if x != nil {
		return x.xxx_hidden_Namespace
	}
	return ""
}

func (x *SchedulerState) GetNamespaceId() string {
	if x != nil {
		return x.xxx_hidden_NamespaceId
	}
	return ""
}

func (x *SchedulerState) GetScheduleId() string {
	if x != nil {
		return x.xxx_hidden_ScheduleId
	}
	return ""
}

func (x *SchedulerState) GetConflictToken() int64 {
	if x != nil {
		return x.xxx_hidden_ConflictToken
	}
	return 0
}

func (x *SchedulerState) GetClosed() bool {
	if x != nil {
		return x.xxx_hidden_Closed
	}
	return false
}

func (x *SchedulerState) SetSchedule(v *v1.Schedule) {
	x.xxx_hidden_Schedule = v
}

func (x *SchedulerState) SetInfo(v *v1.ScheduleInfo) {
	x.xxx_hidden_Info = v
}

func (x *SchedulerState) SetNamespace(v string) {
	x.xxx_hidden_Namespace = v
}

func (x *SchedulerState) SetNamespaceId(v string) {
	x.xxx_hidden_NamespaceId = v
}

func (x *SchedulerState) SetScheduleId(v string) {
	x.xxx_hidden_ScheduleId = v
}

func (x *SchedulerState) SetConflictToken(v int64) {
	x.xxx_hidden_ConflictToken = v
}

func (x *SchedulerState) SetClosed(v bool) {
	x.xxx_hidden_Closed = v
}

func (x *SchedulerState) HasSchedule() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Schedule != nil
}

func (x *SchedulerState) HasInfo() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Info != nil
}

func (x *SchedulerState) ClearSchedule() {
	x.xxx_hidden_Schedule = nil
}

func (x *SchedulerState) ClearInfo() {
	x.xxx_hidden_Info = nil
}

type SchedulerState_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Scheduler request parameters and metadata.
	Schedule *v1.Schedule
	Info     *v1.ScheduleInfo
	// State common to all generators is stored in the top-level machine.
	Namespace   string
	NamespaceId string
	ScheduleId  string
	// Implemented as a sequence number. Used for optimistic locking against
	// update requests.
	ConflictToken int64
	// The closed flag is set true after a schedule completes, and the idle timer
	// expires.
	Closed bool
}

func (b0 SchedulerState_builder) Build() *SchedulerState {
	m0 := &SchedulerState{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_Schedule = b.Schedule
	x.xxx_hidden_Info = b.Info
	x.xxx_hidden_Namespace = b.Namespace
	x.xxx_hidden_NamespaceId = b.NamespaceId
	x.xxx_hidden_ScheduleId = b.ScheduleId
	x.xxx_hidden_ConflictToken = b.ConflictToken
	x.xxx_hidden_Closed = b.Closed
	return m0
}

// CHASM scheduler's Generator internal state.
type GeneratorState struct {
	state                        protoimpl.MessageState    `protogen:"opaque.v1"`
	xxx_hidden_LastProcessedTime *timestamppb.Timestamp    `protobuf:"bytes,3,opt,name=last_processed_time,json=lastProcessedTime,proto3"`
	xxx_hidden_FutureActionTimes *[]*timestamppb.Timestamp `protobuf:"bytes,4,rep,name=future_action_times,json=futureActionTimes,proto3"`
	unknownFields                protoimpl.UnknownFields
	sizeCache                    protoimpl.SizeCache
}

func (x *GeneratorState) Reset() {
	*x = GeneratorState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeneratorState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeneratorState) ProtoMessage() {}

func (x *GeneratorState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *GeneratorState) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_LastProcessedTime
	}
	return nil
}

func (x *GeneratorState) GetFutureActionTimes() []*timestamppb.Timestamp {
	if x != nil {
		if x.xxx_hidden_FutureActionTimes != nil {
			return *x.xxx_hidden_FutureActionTimes
		}
	}
	return nil
}

func (x *GeneratorState) SetLastProcessedTime(v *timestamppb.Timestamp) {
	x.xxx_hidden_LastProcessedTime = v
}

func (x *GeneratorState) SetFutureActionTimes(v []*timestamppb.Timestamp) {
	x.xxx_hidden_FutureActionTimes = &v
}

func (x *GeneratorState) HasLastProcessedTime() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_LastProcessedTime != nil
}

func (x *GeneratorState) ClearLastProcessedTime() {
	x.xxx_hidden_LastProcessedTime = nil
}

type GeneratorState_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// High water mark.
	LastProcessedTime *timestamppb.Timestamp
	// A list of upcoming times an action will be triggered.
	FutureActionTimes []*timestamppb.Timestamp
}

func (b0 GeneratorState_builder) Build() *GeneratorState {
	m0 := &GeneratorState{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_LastProcessedTime = b.LastProcessedTime
	x.xxx_hidden_FutureActionTimes = &b.FutureActionTimes
	return m0
}

// CHASM scheduler's Invoker internal state.
type InvokerState struct {
	state                         protoimpl.MessageState    `protogen:"opaque.v1"`
	xxx_hidden_BufferedStarts     *[]*v11.BufferedStart     `protobuf:"bytes,2,rep,name=buffered_starts,json=bufferedStarts,proto3"`
	xxx_hidden_CancelWorkflows    *[]*v12.WorkflowExecution `protobuf:"bytes,3,rep,name=cancel_workflows,json=cancelWorkflows,proto3"`
	xxx_hidden_TerminateWorkflows *[]*v12.WorkflowExecution `protobuf:"bytes,4,rep,name=terminate_workflows,json=terminateWorkflows,proto3"`
	xxx_hidden_LastProcessedTime  *timestamppb.Timestamp    `protobuf:"bytes,5,opt,name=last_processed_time,json=lastProcessedTime,proto3"`
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *InvokerState) Reset() {
	*x = InvokerState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvokerState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvokerState) ProtoMessage() {}

func (x *InvokerState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *InvokerState) GetBufferedStarts() []*v11.BufferedStart {
	if x != nil {
		if x.xxx_hidden_BufferedStarts != nil {
			return *x.xxx_hidden_BufferedStarts
		}
	}
	return nil
}

func (x *InvokerState) GetCancelWorkflows() []*v12.WorkflowExecution {
	if x != nil {
		if x.xxx_hidden_CancelWorkflows != nil {
			return *x.xxx_hidden_CancelWorkflows
		}
	}
	return nil
}

func (x *InvokerState) GetTerminateWorkflows() []*v12.WorkflowExecution {
	if x != nil {
		if x.xxx_hidden_TerminateWorkflows != nil {
			return *x.xxx_hidden_TerminateWorkflows
		}
	}
	return nil
}

func (x *InvokerState) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_LastProcessedTime
	}
	return nil
}

func (x *InvokerState) SetBufferedStarts(v []*v11.BufferedStart) {
	x.xxx_hidden_BufferedStarts = &v
}

func (x *InvokerState) SetCancelWorkflows(v []*v12.WorkflowExecution) {
	x.xxx_hidden_CancelWorkflows = &v
}

func (x *InvokerState) SetTerminateWorkflows(v []*v12.WorkflowExecution) {
	x.xxx_hidden_TerminateWorkflows = &v
}

func (x *InvokerState) SetLastProcessedTime(v *timestamppb.Timestamp) {
	x.xxx_hidden_LastProcessedTime = v
}

func (x *InvokerState) HasLastProcessedTime() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_LastProcessedTime != nil
}

func (x *InvokerState) ClearLastProcessedTime() {
	x.xxx_hidden_LastProcessedTime = nil
}

type InvokerState_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Buffered starts that will be started by the Invoker.
	BufferedStarts []*v11.BufferedStart
	// Workflow executions that will be cancelled due to overlap policy.
	CancelWorkflows []*v12.WorkflowExecution
	// Workflow executions that will be terminated due to overlap policy.
	TerminateWorkflows []*v12.WorkflowExecution
	// High water mark, used for evaluating when to fire tasks that are backing
	// off from a retry. LastProcessedTime is stored as state so that task
	// generation will be consistent, regardless of when generation occurs, such
	// as after applying a replicated state (as opposed to evaluating based on
	// present time).
	LastProcessedTime *timestamppb.Timestamp
}

func (b0 InvokerState_builder) Build() *InvokerState {
	m0 := &InvokerState{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_BufferedStarts = &b.BufferedStarts
	x.xxx_hidden_CancelWorkflows = &b.CancelWorkflows
	x.xxx_hidden_TerminateWorkflows = &b.TerminateWorkflows
	x.xxx_hidden_LastProcessedTime = b.LastProcessedTime
	return m0
}

// CHASM scheduler's Backfiller internal state. Backfill requests are 1:1
// with Backfiller nodes. Backfiller nodes also handle immediate trigger requests.
type BackfillerState struct {
	state                        protoimpl.MessageState    `protogen:"opaque.v1"`
	xxx_hidden_Request           isBackfillerState_Request `protobuf_oneof:"request"`
	xxx_hidden_BackfillId        string                    `protobuf:"bytes,6,opt,name=backfill_id,json=backfillId,proto3"`
	xxx_hidden_LastProcessedTime *timestamppb.Timestamp    `protobuf:"bytes,7,opt,name=last_processed_time,json=lastProcessedTime,proto3"`
	xxx_hidden_Attempt           int64                     `protobuf:"varint,8,opt,name=attempt,proto3"`
	unknownFields                protoimpl.UnknownFields
	sizeCache                    protoimpl.SizeCache
}

func (x *BackfillerState) Reset() {
	*x = BackfillerState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackfillerState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackfillerState) ProtoMessage() {}

func (x *BackfillerState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *BackfillerState) GetBackfillRequest() *v1.BackfillRequest {
	if x != nil {
		if x, ok := x.xxx_hidden_Request.(*backfillerState_BackfillRequest); ok {
			return x.BackfillRequest
		}
	}
	return nil
}

func (x *BackfillerState) GetTriggerRequest() *v1.TriggerImmediatelyRequest {
	if x != nil {
		if x, ok := x.xxx_hidden_Request.(*backfillerState_TriggerRequest); ok {
			return x.TriggerRequest
		}
	}
	return nil
}

func (x *BackfillerState) GetBackfillId() string {
	if x != nil {
		return x.xxx_hidden_BackfillId
	}
	return ""
}

func (x *BackfillerState) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_LastProcessedTime
	}
	return nil
}

func (x *BackfillerState) GetAttempt() int64 {
	if x != nil {
		return x.xxx_hidden_Attempt
	}
	return 0
}

func (x *BackfillerState) SetBackfillRequest(v *v1.BackfillRequest) {
	if v == nil {
		x.xxx_hidden_Request = nil
		return
	}
	x.xxx_hidden_Request = &backfillerState_BackfillRequest{v}
}

func (x *BackfillerState) SetTriggerRequest(v *v1.TriggerImmediatelyRequest) {
	if v == nil {
		x.xxx_hidden_Request = nil
		return
	}
	x.xxx_hidden_Request = &backfillerState_TriggerRequest{v}
}

func (x *BackfillerState) SetBackfillId(v string) {
	x.xxx_hidden_BackfillId = v
}

func (x *BackfillerState) SetLastProcessedTime(v *timestamppb.Timestamp) {
	x.xxx_hidden_LastProcessedTime = v
}

func (x *BackfillerState) SetAttempt(v int64) {
	x.xxx_hidden_Attempt = v
}

func (x *BackfillerState) HasRequest() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Request != nil
}

func (x *BackfillerState) HasBackfillRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.xxx_hidden_Request.(*backfillerState_BackfillRequest)
	return ok
}

func (x *BackfillerState) HasTriggerRequest() bool {
	if x == nil {
		return false
	}
	_, ok := x.xxx_hidden_Request.(*backfillerState_TriggerRequest)
	return ok
}

func (x *BackfillerState) HasLastProcessedTime() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_LastProcessedTime != nil
}

func (x *BackfillerState) ClearRequest() {
	x.xxx_hidden_Request = nil
}

func (x *BackfillerState) ClearBackfillRequest() {
	if _, ok := x.xxx_hidden_Request.(*backfillerState_BackfillRequest); ok {
		x.xxx_hidden_Request = nil
	}
}

func (x *BackfillerState) ClearTriggerRequest() {
	if _, ok := x.xxx_hidden_Request.(*backfillerState_TriggerRequest); ok {
		x.xxx_hidden_Request = nil
	}
}

func (x *BackfillerState) ClearLastProcessedTime() {
	x.xxx_hidden_LastProcessedTime = nil
}

const BackfillerState_Request_not_set_case case_BackfillerState_Request = 0
const BackfillerState_BackfillRequest_case case_BackfillerState_Request = 1
const BackfillerState_TriggerRequest_case case_BackfillerState_Request = 2

func (x *BackfillerState) WhichRequest() case_BackfillerState_Request {
	if x == nil {
		return BackfillerState_Request_not_set_case
	}
	switch x.xxx_hidden_Request.(type) {
	case *backfillerState_BackfillRequest:
		return BackfillerState_BackfillRequest_case
	case *backfillerState_TriggerRequest:
		return BackfillerState_TriggerRequest_case
	default:
		return BackfillerState_Request_not_set_case
	}
}

type BackfillerState_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Fields of oneof xxx_hidden_Request:
	BackfillRequest *v1.BackfillRequest
	// When set, immediately buffer a single manual action.
	TriggerRequest *v1.TriggerImmediatelyRequest
	// -- end of xxx_hidden_Request
	// Every Backfiller should be assigned a unique ID upon creation, used
	// for deduplication.
	BackfillId string
	// High water mark.
	LastProcessedTime *timestamppb.Timestamp
	// Attempt count, incremented when the buffer is full and the Backfiller
	// needs to back off before retrying to fill.
	Attempt int64
}

func (b0 BackfillerState_builder) Build() *BackfillerState {
	m0 := &BackfillerState{}
	b, x := &b0, m0
	_, _ = b, x
	if b.BackfillRequest != nil {
		x.xxx_hidden_Request = &backfillerState_BackfillRequest{b.BackfillRequest}
	}
	if b.TriggerRequest != nil {
		x.xxx_hidden_Request = &backfillerState_TriggerRequest{b.TriggerRequest}
	}
	x.xxx_hidden_BackfillId = b.BackfillId
	x.xxx_hidden_LastProcessedTime = b.LastProcessedTime
	x.xxx_hidden_Attempt = b.Attempt
	return m0
}

type case_BackfillerState_Request protoreflect.FieldNumber

func (x case_BackfillerState_Request) String() string {
	switch x {
	case BackfillerState_Request_not_set_case:
		return "BackfillerStateRequestNotSetCase"
	case BackfillerState_BackfillRequest_case:
		return "BackfillerStateBackfillRequestCase"
	case BackfillerState_TriggerRequest_case:
		return "BackfillerStateTriggerRequestCase"
	default:
		return strconv.Itoa(int(x))
	}

}

type isBackfillerState_Request interface {
	isBackfillerState_Request()
}

type backfillerState_BackfillRequest struct {
	BackfillRequest *v1.BackfillRequest `protobuf:"bytes,1,opt,name=backfill_request,json=backfillRequest,proto3,oneof"`
}

type backfillerState_TriggerRequest struct {
	// When set, immediately buffer a single manual action.
	TriggerRequest *v1.TriggerImmediatelyRequest `protobuf:"bytes,2,opt,name=trigger_request,json=triggerRequest,proto3,oneof"`
}

func (*backfillerState_BackfillRequest) isBackfillerState_Request() {}

func (*backfillerState_TriggerRequest) isBackfillerState_Request() {}

// CHASM scheduler retains the payload data for the last completed workflow. Both
// last success and failure are stored simultaneously.
type LastCompletionResult struct {
	state              protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Success *v12.Payload           `protobuf:"bytes,1,opt,name=success,proto3"`
	xxx_hidden_Failure *v13.Failure           `protobuf:"bytes,2,opt,name=failure,proto3"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *LastCompletionResult) Reset() {
	*x = LastCompletionResult{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LastCompletionResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LastCompletionResult) ProtoMessage() {}

func (x *LastCompletionResult) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *LastCompletionResult) GetSuccess() *v12.Payload {
	if x != nil {
		return x.xxx_hidden_Success
	}
	return nil
}

func (x *LastCompletionResult) GetFailure() *v13.Failure {
	if x != nil {
		return x.xxx_hidden_Failure
	}
	return nil
}

func (x *LastCompletionResult) SetSuccess(v *v12.Payload) {
	x.xxx_hidden_Success = v
}

func (x *LastCompletionResult) SetFailure(v *v13.Failure) {
	x.xxx_hidden_Failure = v
}

func (x *LastCompletionResult) HasSuccess() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Success != nil
}

func (x *LastCompletionResult) HasFailure() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Failure != nil
}

func (x *LastCompletionResult) ClearSuccess() {
	x.xxx_hidden_Success = nil
}

func (x *LastCompletionResult) ClearFailure() {
	x.xxx_hidden_Failure = nil
}

type LastCompletionResult_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Success *v12.Payload
	Failure *v13.Failure
}

func (b0 LastCompletionResult_builder) Build() *LastCompletionResult {
	m0 := &LastCompletionResult{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_Success = b.Success
	x.xxx_hidden_Failure = b.Failure
	return m0
}

var File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto protoreflect.FileDescriptor

const file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc = "" +
	"\n" +
	":temporal/server/chasm/lib/scheduler/proto/v1/message.proto\x12,temporal.server.chasm.lib.scheduler.proto.v1\x1a$temporal/api/common/v1/message.proto\x1a%temporal/api/failure/v1/message.proto\x1a&temporal/api/schedule/v1/message.proto\x1a-temporal/server/api/schedule/v1/message.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xad\x02\n" +
	"\x0eSchedulerState\x12>\n" +
	"\bschedule\x18\x02 \x01(\v2\".temporal.api.schedule.v1.ScheduleR\bschedule\x12:\n" +
	"\x04info\x18\x03 \x01(\v2&.temporal.api.schedule.v1.ScheduleInfoR\x04info\x12\x1c\n" +
	"\tnamespace\x18\x05 \x01(\tR\tnamespace\x12!\n" +
	"\fnamespace_id\x18\x06 \x01(\tR\vnamespaceId\x12\x1f\n" +
	"\vschedule_id\x18\a \x01(\tR\n" +
	"scheduleId\x12%\n" +
	"\x0econflict_token\x18\b \x01(\x03R\rconflictToken\x12\x16\n" +
	"\x06closed\x18\t \x01(\bR\x06closed\"\xa8\x01\n" +
	"\x0eGeneratorState\x12J\n" +
	"\x13last_processed_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTime\x12J\n" +
	"\x13future_action_times\x18\x04 \x03(\v2\x1a.google.protobuf.TimestampR\x11futureActionTimes\"\xeb\x02\n" +
	"\fInvokerState\x12W\n" +
	"\x0fbuffered_starts\x18\x02 \x03(\v2..temporal.server.api.schedule.v1.BufferedStartR\x0ebufferedStarts\x12T\n" +
	"\x10cancel_workflows\x18\x03 \x03(\v2).temporal.api.common.v1.WorkflowExecutionR\x0fcancelWorkflows\x12Z\n" +
	"\x13terminate_workflows\x18\x04 \x03(\v2).temporal.api.common.v1.WorkflowExecutionR\x12terminateWorkflows\x12J\n" +
	"\x13last_processed_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTimeJ\x04\b\x06\x10\a\"\xdb\x02\n" +
	"\x0fBackfillerState\x12V\n" +
	"\x10backfill_request\x18\x01 \x01(\v2).temporal.api.schedule.v1.BackfillRequestH\x00R\x0fbackfillRequest\x12^\n" +
	"\x0ftrigger_request\x18\x02 \x01(\v23.temporal.api.schedule.v1.TriggerImmediatelyRequestH\x00R\x0etriggerRequest\x12\x1f\n" +
	"\vbackfill_id\x18\x06 \x01(\tR\n" +
	"backfillId\x12J\n" +
	"\x13last_processed_time\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTime\x12\x18\n" +
	"\aattempt\x18\b \x01(\x03R\aattemptB\t\n" +
	"\arequest\"\x8d\x01\n" +
	"\x14LastCompletionResult\x129\n" +
	"\asuccess\x18\x01 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\asuccess\x12:\n" +
	"\afailure\x18\x02 \x01(\v2 .temporal.api.failure.v1.FailureR\afailureBGZEgo.temporal.io/server/chasm/lib/scheduler/gen/schedulerpb;schedulerpbb\x06proto3"

var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes = []any{
	(*SchedulerState)(nil),               // 0: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerState
	(*GeneratorState)(nil),               // 1: temporal.server.chasm.lib.scheduler.proto.v1.GeneratorState
	(*InvokerState)(nil),                 // 2: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState
	(*BackfillerState)(nil),              // 3: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState
	(*LastCompletionResult)(nil),         // 4: temporal.server.chasm.lib.scheduler.proto.v1.LastCompletionResult
	(*v1.Schedule)(nil),                  // 5: temporal.api.schedule.v1.Schedule
	(*v1.ScheduleInfo)(nil),              // 6: temporal.api.schedule.v1.ScheduleInfo
	(*timestamppb.Timestamp)(nil),        // 7: google.protobuf.Timestamp
	(*v11.BufferedStart)(nil),            // 8: temporal.server.api.schedule.v1.BufferedStart
	(*v12.WorkflowExecution)(nil),        // 9: temporal.api.common.v1.WorkflowExecution
	(*v1.BackfillRequest)(nil),           // 10: temporal.api.schedule.v1.BackfillRequest
	(*v1.TriggerImmediatelyRequest)(nil), // 11: temporal.api.schedule.v1.TriggerImmediatelyRequest
	(*v12.Payload)(nil),                  // 12: temporal.api.common.v1.Payload
	(*v13.Failure)(nil),                  // 13: temporal.api.failure.v1.Failure
}
var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs = []int32{
	5,  // 0: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerState.schedule:type_name -> temporal.api.schedule.v1.Schedule
	6,  // 1: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerState.info:type_name -> temporal.api.schedule.v1.ScheduleInfo
	7,  // 2: temporal.server.chasm.lib.scheduler.proto.v1.GeneratorState.last_processed_time:type_name -> google.protobuf.Timestamp
	7,  // 3: temporal.server.chasm.lib.scheduler.proto.v1.GeneratorState.future_action_times:type_name -> google.protobuf.Timestamp
	8,  // 4: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.buffered_starts:type_name -> temporal.server.api.schedule.v1.BufferedStart
	9,  // 5: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.cancel_workflows:type_name -> temporal.api.common.v1.WorkflowExecution
	9,  // 6: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.terminate_workflows:type_name -> temporal.api.common.v1.WorkflowExecution
	7,  // 7: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.last_processed_time:type_name -> google.protobuf.Timestamp
	10, // 8: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState.backfill_request:type_name -> temporal.api.schedule.v1.BackfillRequest
	11, // 9: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState.trigger_request:type_name -> temporal.api.schedule.v1.TriggerImmediatelyRequest
	7,  // 10: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState.last_processed_time:type_name -> google.protobuf.Timestamp
	12, // 11: temporal.server.chasm.lib.scheduler.proto.v1.LastCompletionResult.success:type_name -> temporal.api.common.v1.Payload
	13, // 12: temporal.server.chasm.lib.scheduler.proto.v1.LastCompletionResult.failure:type_name -> temporal.api.failure.v1.Failure
	13, // [13:13] is the sub-list for method output_type
	13, // [13:13] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_init() }
func file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_init() {
	if File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto != nil {
		return
	}
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3].OneofWrappers = []any{
		(*backfillerState_BackfillRequest)(nil),
		(*backfillerState_TriggerRequest)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc), len(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes,
		DependencyIndexes: file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs,
		MessageInfos:      file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes,
	}.Build()
	File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto = out.File
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes = nil
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs = nil
}
