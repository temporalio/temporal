// Code generated by protoc-gen-go. DO NOT EDIT.
// plugins:
// 	protoc-gen-go
// 	protoc
// source: temporal/server/chasm/lib/scheduler/proto/v1/message.proto

package schedulerpb

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	v12 "go.temporal.io/api/common/v1"
	v13 "go.temporal.io/api/failure/v1"
	v1 "go.temporal.io/api/schedule/v1"
	v11 "go.temporal.io/server/api/schedule/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// CHASM scheduler top-level state.
type SchedulerState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Scheduler request parameters and metadata.
	Schedule *v1.Schedule     `protobuf:"bytes,2,opt,name=schedule,proto3" json:"schedule,omitempty"`
	Info     *v1.ScheduleInfo `protobuf:"bytes,3,opt,name=info,proto3" json:"info,omitempty"`
	// State common to all generators is stored in the top-level machine.
	Namespace   string `protobuf:"bytes,5,opt,name=namespace,proto3" json:"namespace,omitempty"`
	NamespaceId string `protobuf:"bytes,6,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	ScheduleId  string `protobuf:"bytes,7,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`
	// Implemented as a sequence number. Used for optimistic locking against
	// update requests.
	ConflictToken int64 `protobuf:"varint,8,opt,name=conflict_token,json=conflictToken,proto3" json:"conflict_token,omitempty"`
	// The closed flag is set true after a schedule completes, and the idle timer
	// expires.
	Closed bool `protobuf:"varint,9,opt,name=closed,proto3" json:"closed,omitempty"`
	// When true, this scheduler is a sentinel that exists only to reserve the
	// schedule ID. All API operations return NotFound.
	Sentinel      bool `protobuf:"varint,10,opt,name=sentinel,proto3" json:"sentinel,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchedulerState) Reset() {
	*x = SchedulerState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchedulerState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchedulerState) ProtoMessage() {}

func (x *SchedulerState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchedulerState.ProtoReflect.Descriptor instead.
func (*SchedulerState) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{0}
}

func (x *SchedulerState) GetSchedule() *v1.Schedule {
	if x != nil {
		return x.Schedule
	}
	return nil
}

func (x *SchedulerState) GetInfo() *v1.ScheduleInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

func (x *SchedulerState) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *SchedulerState) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *SchedulerState) GetScheduleId() string {
	if x != nil {
		return x.ScheduleId
	}
	return ""
}

func (x *SchedulerState) GetConflictToken() int64 {
	if x != nil {
		return x.ConflictToken
	}
	return 0
}

func (x *SchedulerState) GetClosed() bool {
	if x != nil {
		return x.Closed
	}
	return false
}

func (x *SchedulerState) GetSentinel() bool {
	if x != nil {
		return x.Sentinel
	}
	return false
}

// CHASM scheduler's Generator internal state.
type GeneratorState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// High water mark.
	LastProcessedTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=last_processed_time,json=lastProcessedTime,proto3" json:"last_processed_time,omitempty"`
	// A list of upcoming times an action will be triggered.
	FutureActionTimes []*timestamppb.Timestamp `protobuf:"bytes,4,rep,name=future_action_times,json=futureActionTimes,proto3" json:"future_action_times,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GeneratorState) Reset() {
	*x = GeneratorState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeneratorState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeneratorState) ProtoMessage() {}

func (x *GeneratorState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeneratorState.ProtoReflect.Descriptor instead.
func (*GeneratorState) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{1}
}

func (x *GeneratorState) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastProcessedTime
	}
	return nil
}

func (x *GeneratorState) GetFutureActionTimes() []*timestamppb.Timestamp {
	if x != nil {
		return x.FutureActionTimes
	}
	return nil
}

// CHASM scheduler's Invoker internal state.
type InvokerState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Buffered starts that will be started by the Invoker.
	BufferedStarts []*v11.BufferedStart `protobuf:"bytes,2,rep,name=buffered_starts,json=bufferedStarts,proto3" json:"buffered_starts,omitempty"`
	// Workflow executions that will be cancelled due to overlap policy.
	CancelWorkflows []*v12.WorkflowExecution `protobuf:"bytes,3,rep,name=cancel_workflows,json=cancelWorkflows,proto3" json:"cancel_workflows,omitempty"`
	// Workflow executions that will be terminated due to overlap policy.
	TerminateWorkflows []*v12.WorkflowExecution `protobuf:"bytes,4,rep,name=terminate_workflows,json=terminateWorkflows,proto3" json:"terminate_workflows,omitempty"`
	// High water mark, used for evaluating when to fire tasks that are backing
	// off from a retry. LastProcessedTime is stored as state so that task
	// generation will be consistent, regardless of when generation occurs, such
	// as after applying a replicated state (as opposed to evaluating based on
	// present time).
	LastProcessedTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=last_processed_time,json=lastProcessedTime,proto3" json:"last_processed_time,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *InvokerState) Reset() {
	*x = InvokerState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvokerState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvokerState) ProtoMessage() {}

func (x *InvokerState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InvokerState.ProtoReflect.Descriptor instead.
func (*InvokerState) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{2}
}

func (x *InvokerState) GetBufferedStarts() []*v11.BufferedStart {
	if x != nil {
		return x.BufferedStarts
	}
	return nil
}

func (x *InvokerState) GetCancelWorkflows() []*v12.WorkflowExecution {
	if x != nil {
		return x.CancelWorkflows
	}
	return nil
}

func (x *InvokerState) GetTerminateWorkflows() []*v12.WorkflowExecution {
	if x != nil {
		return x.TerminateWorkflows
	}
	return nil
}

func (x *InvokerState) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastProcessedTime
	}
	return nil
}

// CHASM scheduler's Backfiller internal state. Backfill requests are 1:1
// with Backfiller nodes. Backfiller nodes also handle immediate trigger requests.
type BackfillerState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Request:
	//
	//	*BackfillerState_BackfillRequest
	//	*BackfillerState_TriggerRequest
	Request isBackfillerState_Request `protobuf_oneof:"request"`
	// Every Backfiller should be assigned a unique ID upon creation, used
	// for deduplication.
	BackfillId string `protobuf:"bytes,6,opt,name=backfill_id,json=backfillId,proto3" json:"backfill_id,omitempty"`
	// High water mark.
	LastProcessedTime *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=last_processed_time,json=lastProcessedTime,proto3" json:"last_processed_time,omitempty"`
	// Attempt count, incremented when the buffer is full and the Backfiller
	// needs to back off before retrying to fill.
	Attempt       int64 `protobuf:"varint,8,opt,name=attempt,proto3" json:"attempt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BackfillerState) Reset() {
	*x = BackfillerState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackfillerState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackfillerState) ProtoMessage() {}

func (x *BackfillerState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackfillerState.ProtoReflect.Descriptor instead.
func (*BackfillerState) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{3}
}

func (x *BackfillerState) GetRequest() isBackfillerState_Request {
	if x != nil {
		return x.Request
	}
	return nil
}

func (x *BackfillerState) GetBackfillRequest() *v1.BackfillRequest {
	if x != nil {
		if x, ok := x.Request.(*BackfillerState_BackfillRequest); ok {
			return x.BackfillRequest
		}
	}
	return nil
}

func (x *BackfillerState) GetTriggerRequest() *v1.TriggerImmediatelyRequest {
	if x != nil {
		if x, ok := x.Request.(*BackfillerState_TriggerRequest); ok {
			return x.TriggerRequest
		}
	}
	return nil
}

func (x *BackfillerState) GetBackfillId() string {
	if x != nil {
		return x.BackfillId
	}
	return ""
}

func (x *BackfillerState) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastProcessedTime
	}
	return nil
}

func (x *BackfillerState) GetAttempt() int64 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

type isBackfillerState_Request interface {
	isBackfillerState_Request()
}

type BackfillerState_BackfillRequest struct {
	BackfillRequest *v1.BackfillRequest `protobuf:"bytes,1,opt,name=backfill_request,json=backfillRequest,proto3,oneof"`
}

type BackfillerState_TriggerRequest struct {
	// When set, immediately buffer a single manual action.
	TriggerRequest *v1.TriggerImmediatelyRequest `protobuf:"bytes,2,opt,name=trigger_request,json=triggerRequest,proto3,oneof"`
}

func (*BackfillerState_BackfillRequest) isBackfillerState_Request() {}

func (*BackfillerState_TriggerRequest) isBackfillerState_Request() {}

// CHASM scheduler retains the payload data for the last completed workflow. Both
// last success and failure are stored simultaneously.
type LastCompletionResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       *v12.Payload           `protobuf:"bytes,1,opt,name=success,proto3" json:"success,omitempty"`
	Failure       *v13.Failure           `protobuf:"bytes,2,opt,name=failure,proto3" json:"failure,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LastCompletionResult) Reset() {
	*x = LastCompletionResult{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LastCompletionResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LastCompletionResult) ProtoMessage() {}

func (x *LastCompletionResult) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LastCompletionResult.ProtoReflect.Descriptor instead.
func (*LastCompletionResult) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{4}
}

func (x *LastCompletionResult) GetSuccess() *v12.Payload {
	if x != nil {
		return x.Success
	}
	return nil
}

func (x *LastCompletionResult) GetFailure() *v13.Failure {
	if x != nil {
		return x.Failure
	}
	return nil
}

// SchedulerMigrationState is a stack-agnostic interchange format for migrating
// scheduler state between V1 (workflow-backed) and V2 (CHASM) implementations.
type SchedulerMigrationState struct {
	state                protoimpl.MessageState      `protogen:"open.v1"`
	SchedulerState       *SchedulerState             `protobuf:"bytes,1,opt,name=scheduler_state,json=schedulerState,proto3" json:"scheduler_state,omitempty"`
	GeneratorState       *GeneratorState             `protobuf:"bytes,2,opt,name=generator_state,json=generatorState,proto3" json:"generator_state,omitempty"`
	InvokerState         *InvokerState               `protobuf:"bytes,3,opt,name=invoker_state,json=invokerState,proto3" json:"invoker_state,omitempty"`
	Backfillers          map[string]*BackfillerState `protobuf:"bytes,4,rep,name=backfillers,proto3" json:"backfillers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	LastCompletionResult *LastCompletionResult       `protobuf:"bytes,5,opt,name=last_completion_result,json=lastCompletionResult,proto3" json:"last_completion_result,omitempty"`
	// Visibility data.
	SearchAttributes map[string]*v12.Payload `protobuf:"bytes,6,rep,name=search_attributes,json=searchAttributes,proto3" json:"search_attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Memo             map[string]*v12.Payload `protobuf:"bytes,7,rep,name=memo,proto3" json:"memo,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *SchedulerMigrationState) Reset() {
	*x = SchedulerMigrationState{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchedulerMigrationState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchedulerMigrationState) ProtoMessage() {}

func (x *SchedulerMigrationState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchedulerMigrationState.ProtoReflect.Descriptor instead.
func (*SchedulerMigrationState) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{5}
}

func (x *SchedulerMigrationState) GetSchedulerState() *SchedulerState {
	if x != nil {
		return x.SchedulerState
	}
	return nil
}

func (x *SchedulerMigrationState) GetGeneratorState() *GeneratorState {
	if x != nil {
		return x.GeneratorState
	}
	return nil
}

func (x *SchedulerMigrationState) GetInvokerState() *InvokerState {
	if x != nil {
		return x.InvokerState
	}
	return nil
}

func (x *SchedulerMigrationState) GetBackfillers() map[string]*BackfillerState {
	if x != nil {
		return x.Backfillers
	}
	return nil
}

func (x *SchedulerMigrationState) GetLastCompletionResult() *LastCompletionResult {
	if x != nil {
		return x.LastCompletionResult
	}
	return nil
}

func (x *SchedulerMigrationState) GetSearchAttributes() map[string]*v12.Payload {
	if x != nil {
		return x.SearchAttributes
	}
	return nil
}

func (x *SchedulerMigrationState) GetMemo() map[string]*v12.Payload {
	if x != nil {
		return x.Memo
	}
	return nil
}

var File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto protoreflect.FileDescriptor

const file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc = "" +
	"\n" +
	":temporal/server/chasm/lib/scheduler/proto/v1/message.proto\x12,temporal.server.chasm.lib.scheduler.proto.v1\x1a$temporal/api/common/v1/message.proto\x1a%temporal/api/failure/v1/message.proto\x1a&temporal/api/schedule/v1/message.proto\x1a-temporal/server/api/schedule/v1/message.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xc9\x02\n" +
	"\x0eSchedulerState\x12>\n" +
	"\bschedule\x18\x02 \x01(\v2\".temporal.api.schedule.v1.ScheduleR\bschedule\x12:\n" +
	"\x04info\x18\x03 \x01(\v2&.temporal.api.schedule.v1.ScheduleInfoR\x04info\x12\x1c\n" +
	"\tnamespace\x18\x05 \x01(\tR\tnamespace\x12!\n" +
	"\fnamespace_id\x18\x06 \x01(\tR\vnamespaceId\x12\x1f\n" +
	"\vschedule_id\x18\a \x01(\tR\n" +
	"scheduleId\x12%\n" +
	"\x0econflict_token\x18\b \x01(\x03R\rconflictToken\x12\x16\n" +
	"\x06closed\x18\t \x01(\bR\x06closed\x12\x1a\n" +
	"\bsentinel\x18\n" +
	" \x01(\bR\bsentinel\"\xa8\x01\n" +
	"\x0eGeneratorState\x12J\n" +
	"\x13last_processed_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTime\x12J\n" +
	"\x13future_action_times\x18\x04 \x03(\v2\x1a.google.protobuf.TimestampR\x11futureActionTimes\"\xeb\x02\n" +
	"\fInvokerState\x12W\n" +
	"\x0fbuffered_starts\x18\x02 \x03(\v2..temporal.server.api.schedule.v1.BufferedStartR\x0ebufferedStarts\x12T\n" +
	"\x10cancel_workflows\x18\x03 \x03(\v2).temporal.api.common.v1.WorkflowExecutionR\x0fcancelWorkflows\x12Z\n" +
	"\x13terminate_workflows\x18\x04 \x03(\v2).temporal.api.common.v1.WorkflowExecutionR\x12terminateWorkflows\x12J\n" +
	"\x13last_processed_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTimeJ\x04\b\x06\x10\a\"\xdb\x02\n" +
	"\x0fBackfillerState\x12V\n" +
	"\x10backfill_request\x18\x01 \x01(\v2).temporal.api.schedule.v1.BackfillRequestH\x00R\x0fbackfillRequest\x12^\n" +
	"\x0ftrigger_request\x18\x02 \x01(\v23.temporal.api.schedule.v1.TriggerImmediatelyRequestH\x00R\x0etriggerRequest\x12\x1f\n" +
	"\vbackfill_id\x18\x06 \x01(\tR\n" +
	"backfillId\x12J\n" +
	"\x13last_processed_time\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTime\x12\x18\n" +
	"\aattempt\x18\b \x01(\x03R\aattemptB\t\n" +
	"\arequest\"\x8d\x01\n" +
	"\x14LastCompletionResult\x129\n" +
	"\asuccess\x18\x01 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\asuccess\x12:\n" +
	"\afailure\x18\x02 \x01(\v2 .temporal.api.failure.v1.FailureR\afailure\"\xeb\b\n" +
	"\x17SchedulerMigrationState\x12e\n" +
	"\x0fscheduler_state\x18\x01 \x01(\v2<.temporal.server.chasm.lib.scheduler.proto.v1.SchedulerStateR\x0eschedulerState\x12e\n" +
	"\x0fgenerator_state\x18\x02 \x01(\v2<.temporal.server.chasm.lib.scheduler.proto.v1.GeneratorStateR\x0egeneratorState\x12_\n" +
	"\rinvoker_state\x18\x03 \x01(\v2:.temporal.server.chasm.lib.scheduler.proto.v1.InvokerStateR\finvokerState\x12x\n" +
	"\vbackfillers\x18\x04 \x03(\v2V.temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.BackfillersEntryR\vbackfillers\x12x\n" +
	"\x16last_completion_result\x18\x05 \x01(\v2B.temporal.server.chasm.lib.scheduler.proto.v1.LastCompletionResultR\x14lastCompletionResult\x12\x88\x01\n" +
	"\x11search_attributes\x18\x06 \x03(\v2[.temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.SearchAttributesEntryR\x10searchAttributes\x12c\n" +
	"\x04memo\x18\a \x03(\v2O.temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.MemoEntryR\x04memo\x1a}\n" +
	"\x10BackfillersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12S\n" +
	"\x05value\x18\x02 \x01(\v2=.temporal.server.chasm.lib.scheduler.proto.v1.BackfillerStateR\x05value:\x028\x01\x1ad\n" +
	"\x15SearchAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x05value:\x028\x01\x1aX\n" +
	"\tMemoEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x05value:\x028\x01BGZEgo.temporal.io/server/chasm/lib/scheduler/gen/schedulerpb;schedulerpbb\x06proto3"

var (
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescOnce sync.Once
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescData []byte
)

func file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP() []byte {
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescOnce.Do(func() {
		file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc), len(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc)))
	})
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescData
}

var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes = []any{
	(*SchedulerState)(nil),               // 0: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerState
	(*GeneratorState)(nil),               // 1: temporal.server.chasm.lib.scheduler.proto.v1.GeneratorState
	(*InvokerState)(nil),                 // 2: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState
	(*BackfillerState)(nil),              // 3: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState
	(*LastCompletionResult)(nil),         // 4: temporal.server.chasm.lib.scheduler.proto.v1.LastCompletionResult
	(*SchedulerMigrationState)(nil),      // 5: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState
	nil,                                  // 6: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.BackfillersEntry
	nil,                                  // 7: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.SearchAttributesEntry
	nil,                                  // 8: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.MemoEntry
	(*v1.Schedule)(nil),                  // 9: temporal.api.schedule.v1.Schedule
	(*v1.ScheduleInfo)(nil),              // 10: temporal.api.schedule.v1.ScheduleInfo
	(*timestamppb.Timestamp)(nil),        // 11: google.protobuf.Timestamp
	(*v11.BufferedStart)(nil),            // 12: temporal.server.api.schedule.v1.BufferedStart
	(*v12.WorkflowExecution)(nil),        // 13: temporal.api.common.v1.WorkflowExecution
	(*v1.BackfillRequest)(nil),           // 14: temporal.api.schedule.v1.BackfillRequest
	(*v1.TriggerImmediatelyRequest)(nil), // 15: temporal.api.schedule.v1.TriggerImmediatelyRequest
	(*v12.Payload)(nil),                  // 16: temporal.api.common.v1.Payload
	(*v13.Failure)(nil),                  // 17: temporal.api.failure.v1.Failure
}
var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs = []int32{
	9,  // 0: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerState.schedule:type_name -> temporal.api.schedule.v1.Schedule
	10, // 1: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerState.info:type_name -> temporal.api.schedule.v1.ScheduleInfo
	11, // 2: temporal.server.chasm.lib.scheduler.proto.v1.GeneratorState.last_processed_time:type_name -> google.protobuf.Timestamp
	11, // 3: temporal.server.chasm.lib.scheduler.proto.v1.GeneratorState.future_action_times:type_name -> google.protobuf.Timestamp
	12, // 4: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.buffered_starts:type_name -> temporal.server.api.schedule.v1.BufferedStart
	13, // 5: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.cancel_workflows:type_name -> temporal.api.common.v1.WorkflowExecution
	13, // 6: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.terminate_workflows:type_name -> temporal.api.common.v1.WorkflowExecution
	11, // 7: temporal.server.chasm.lib.scheduler.proto.v1.InvokerState.last_processed_time:type_name -> google.protobuf.Timestamp
	14, // 8: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState.backfill_request:type_name -> temporal.api.schedule.v1.BackfillRequest
	15, // 9: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState.trigger_request:type_name -> temporal.api.schedule.v1.TriggerImmediatelyRequest
	11, // 10: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState.last_processed_time:type_name -> google.protobuf.Timestamp
	16, // 11: temporal.server.chasm.lib.scheduler.proto.v1.LastCompletionResult.success:type_name -> temporal.api.common.v1.Payload
	17, // 12: temporal.server.chasm.lib.scheduler.proto.v1.LastCompletionResult.failure:type_name -> temporal.api.failure.v1.Failure
	0,  // 13: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.scheduler_state:type_name -> temporal.server.chasm.lib.scheduler.proto.v1.SchedulerState
	1,  // 14: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.generator_state:type_name -> temporal.server.chasm.lib.scheduler.proto.v1.GeneratorState
	2,  // 15: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.invoker_state:type_name -> temporal.server.chasm.lib.scheduler.proto.v1.InvokerState
	6,  // 16: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.backfillers:type_name -> temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.BackfillersEntry
	4,  // 17: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.last_completion_result:type_name -> temporal.server.chasm.lib.scheduler.proto.v1.LastCompletionResult
	7,  // 18: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.search_attributes:type_name -> temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.SearchAttributesEntry
	8,  // 19: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.memo:type_name -> temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.MemoEntry
	3,  // 20: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.BackfillersEntry.value:type_name -> temporal.server.chasm.lib.scheduler.proto.v1.BackfillerState
	16, // 21: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.SearchAttributesEntry.value:type_name -> temporal.api.common.v1.Payload
	16, // 22: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerMigrationState.MemoEntry.value:type_name -> temporal.api.common.v1.Payload
	23, // [23:23] is the sub-list for method output_type
	23, // [23:23] is the sub-list for method input_type
	23, // [23:23] is the sub-list for extension type_name
	23, // [23:23] is the sub-list for extension extendee
	0,  // [0:23] is the sub-list for field type_name
}

func init() { file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_init() }
func file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_init() {
	if File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto != nil {
		return
	}
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3].OneofWrappers = []any{
		(*BackfillerState_BackfillRequest)(nil),
		(*BackfillerState_TriggerRequest)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc), len(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes,
		DependencyIndexes: file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs,
		MessageInfos:      file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes,
	}.Build()
	File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto = out.File
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes = nil
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs = nil
}
