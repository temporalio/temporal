// Code generated by protoc-gen-go. DO NOT EDIT.
// plugins:
// 	protoc-gen-go
// 	protoc
// source: temporal/server/chasm/lib/scheduler/proto/v1/message.proto

package schedulerpb

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	v12 "go.temporal.io/api/common/v1"
	v1 "go.temporal.io/api/schedule/v1"
	v11 "go.temporal.io/server/api/schedule/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// CHASM scheduler top-level state.
type SchedulerInternal struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Scheduler request parameters and metadata.
	Schedule     *v1.Schedule      `protobuf:"bytes,2,opt,name=schedule,proto3" json:"schedule,omitempty"`
	Info         *v1.ScheduleInfo  `protobuf:"bytes,3,opt,name=info,proto3" json:"info,omitempty"`
	InitialPatch *v1.SchedulePatch `protobuf:"bytes,4,opt,name=initial_patch,json=initialPatch,proto3" json:"initial_patch,omitempty"`
	// State common to all generators is stored in the top-level machine.
	Namespace   string `protobuf:"bytes,5,opt,name=namespace,proto3" json:"namespace,omitempty"`
	NamespaceId string `protobuf:"bytes,6,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	ScheduleId  string `protobuf:"bytes,7,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`
	// Implemented as a sequence number. Used for optimistic locking against
	// update requests.
	ConflictToken int64 `protobuf:"varint,8,opt,name=conflict_token,json=conflictToken,proto3" json:"conflict_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchedulerInternal) Reset() {
	*x = SchedulerInternal{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchedulerInternal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchedulerInternal) ProtoMessage() {}

func (x *SchedulerInternal) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchedulerInternal.ProtoReflect.Descriptor instead.
func (*SchedulerInternal) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{0}
}

func (x *SchedulerInternal) GetSchedule() *v1.Schedule {
	if x != nil {
		return x.Schedule
	}
	return nil
}

func (x *SchedulerInternal) GetInfo() *v1.ScheduleInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

func (x *SchedulerInternal) GetInitialPatch() *v1.SchedulePatch {
	if x != nil {
		return x.InitialPatch
	}
	return nil
}

func (x *SchedulerInternal) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *SchedulerInternal) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *SchedulerInternal) GetScheduleId() string {
	if x != nil {
		return x.ScheduleId
	}
	return ""
}

func (x *SchedulerInternal) GetConflictToken() int64 {
	if x != nil {
		return x.ConflictToken
	}
	return 0
}

// CHASM scheduler's Generator internal state.
type GeneratorInternal struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// High water mark.
	LastProcessedTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=last_processed_time,json=lastProcessedTime,proto3" json:"last_processed_time,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GeneratorInternal) Reset() {
	*x = GeneratorInternal{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeneratorInternal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeneratorInternal) ProtoMessage() {}

func (x *GeneratorInternal) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeneratorInternal.ProtoReflect.Descriptor instead.
func (*GeneratorInternal) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{1}
}

func (x *GeneratorInternal) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastProcessedTime
	}
	return nil
}

// CHASM scheduler's Invoker internal state.
type InvokerInternal struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Buffered starts that will be started by the Invoker.
	BufferedStarts []*v11.BufferedStart `protobuf:"bytes,2,rep,name=buffered_starts,json=bufferedStarts,proto3" json:"buffered_starts,omitempty"`
	// Workflow executions that will be cancelled due to overlap policy.
	CancelWorkflows []*v12.WorkflowExecution `protobuf:"bytes,3,rep,name=cancel_workflows,json=cancelWorkflows,proto3" json:"cancel_workflows,omitempty"`
	// Workflow executions that will be terminated due to overlap policy.
	TerminateWorkflows []*v12.WorkflowExecution `protobuf:"bytes,4,rep,name=terminate_workflows,json=terminateWorkflows,proto3" json:"terminate_workflows,omitempty"`
	// High water mark, used for evaluating when to fire tasks that are backing
	// off from a retry. LastProcessedTime is stored as state so that task
	// generation will be consistent, regardless of when generation occurs, such
	// as after applying a replicated state (as opposed to evaluating based on
	// present time).
	LastProcessedTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=last_processed_time,json=lastProcessedTime,proto3" json:"last_processed_time,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *InvokerInternal) Reset() {
	*x = InvokerInternal{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvokerInternal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvokerInternal) ProtoMessage() {}

func (x *InvokerInternal) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InvokerInternal.ProtoReflect.Descriptor instead.
func (*InvokerInternal) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{2}
}

func (x *InvokerInternal) GetBufferedStarts() []*v11.BufferedStart {
	if x != nil {
		return x.BufferedStarts
	}
	return nil
}

func (x *InvokerInternal) GetCancelWorkflows() []*v12.WorkflowExecution {
	if x != nil {
		return x.CancelWorkflows
	}
	return nil
}

func (x *InvokerInternal) GetTerminateWorkflows() []*v12.WorkflowExecution {
	if x != nil {
		return x.TerminateWorkflows
	}
	return nil
}

func (x *InvokerInternal) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastProcessedTime
	}
	return nil
}

// CHASM scheduler's Backfiller internal state. Backfill requests are 1:1
// with Backfiller nodes. Backfiller nodes also handle immediate trigger requests.
type BackfillerInternal struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Request:
	//
	//	*BackfillerInternal_BackfillRequest
	//	*BackfillerInternal_TriggerRequest
	Request isBackfillerInternal_Request `protobuf_oneof:"request"`
	// Every Backfiller should be assigned a unique ID upon creation, used
	// for deduplication.
	BackfillId string `protobuf:"bytes,6,opt,name=backfill_id,json=backfillId,proto3" json:"backfill_id,omitempty"`
	// High water mark.
	LastProcessedTime *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=last_processed_time,json=lastProcessedTime,proto3" json:"last_processed_time,omitempty"`
	// Attempt count, incremented when the buffer is full and the Backfiller
	// needs to back off before retrying to fill.
	Attempt       int64 `protobuf:"varint,8,opt,name=attempt,proto3" json:"attempt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BackfillerInternal) Reset() {
	*x = BackfillerInternal{}
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackfillerInternal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackfillerInternal) ProtoMessage() {}

func (x *BackfillerInternal) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackfillerInternal.ProtoReflect.Descriptor instead.
func (*BackfillerInternal) Descriptor() ([]byte, []int) {
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP(), []int{3}
}

func (x *BackfillerInternal) GetRequest() isBackfillerInternal_Request {
	if x != nil {
		return x.Request
	}
	return nil
}

func (x *BackfillerInternal) GetBackfillRequest() *v1.BackfillRequest {
	if x != nil {
		if x, ok := x.Request.(*BackfillerInternal_BackfillRequest); ok {
			return x.BackfillRequest
		}
	}
	return nil
}

func (x *BackfillerInternal) GetTriggerRequest() *v1.TriggerImmediatelyRequest {
	if x != nil {
		if x, ok := x.Request.(*BackfillerInternal_TriggerRequest); ok {
			return x.TriggerRequest
		}
	}
	return nil
}

func (x *BackfillerInternal) GetBackfillId() string {
	if x != nil {
		return x.BackfillId
	}
	return ""
}

func (x *BackfillerInternal) GetLastProcessedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastProcessedTime
	}
	return nil
}

func (x *BackfillerInternal) GetAttempt() int64 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

type isBackfillerInternal_Request interface {
	isBackfillerInternal_Request()
}

type BackfillerInternal_BackfillRequest struct {
	BackfillRequest *v1.BackfillRequest `protobuf:"bytes,1,opt,name=backfill_request,json=backfillRequest,proto3,oneof"`
}

type BackfillerInternal_TriggerRequest struct {
	// When set, immediately buffer a single manual action.
	TriggerRequest *v1.TriggerImmediatelyRequest `protobuf:"bytes,2,opt,name=trigger_request,json=triggerRequest,proto3,oneof"`
}

func (*BackfillerInternal_BackfillRequest) isBackfillerInternal_Request() {}

func (*BackfillerInternal_TriggerRequest) isBackfillerInternal_Request() {}

var File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto protoreflect.FileDescriptor

const file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc = "" +
	"\n" +
	":temporal/server/chasm/lib/scheduler/proto/v1/message.proto\x12,temporal.server.chasm.lib.scheduler.proto.v1\x1a$temporal/api/common/v1/message.proto\x1a&temporal/api/schedule/v1/message.proto\x1a-temporal/server/api/schedule/v1/message.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xe6\x02\n" +
	"\x11SchedulerInternal\x12>\n" +
	"\bschedule\x18\x02 \x01(\v2\".temporal.api.schedule.v1.ScheduleR\bschedule\x12:\n" +
	"\x04info\x18\x03 \x01(\v2&.temporal.api.schedule.v1.ScheduleInfoR\x04info\x12L\n" +
	"\rinitial_patch\x18\x04 \x01(\v2'.temporal.api.schedule.v1.SchedulePatchR\finitialPatch\x12\x1c\n" +
	"\tnamespace\x18\x05 \x01(\tR\tnamespace\x12!\n" +
	"\fnamespace_id\x18\x06 \x01(\tR\vnamespaceId\x12\x1f\n" +
	"\vschedule_id\x18\a \x01(\tR\n" +
	"scheduleId\x12%\n" +
	"\x0econflict_token\x18\b \x01(\x03R\rconflictToken\"_\n" +
	"\x11GeneratorInternal\x12J\n" +
	"\x13last_processed_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTime\"\xe8\x02\n" +
	"\x0fInvokerInternal\x12W\n" +
	"\x0fbuffered_starts\x18\x02 \x03(\v2..temporal.server.api.schedule.v1.BufferedStartR\x0ebufferedStarts\x12T\n" +
	"\x10cancel_workflows\x18\x03 \x03(\v2).temporal.api.common.v1.WorkflowExecutionR\x0fcancelWorkflows\x12Z\n" +
	"\x13terminate_workflows\x18\x04 \x03(\v2).temporal.api.common.v1.WorkflowExecutionR\x12terminateWorkflows\x12J\n" +
	"\x13last_processed_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTime\"\xde\x02\n" +
	"\x12BackfillerInternal\x12V\n" +
	"\x10backfill_request\x18\x01 \x01(\v2).temporal.api.schedule.v1.BackfillRequestH\x00R\x0fbackfillRequest\x12^\n" +
	"\x0ftrigger_request\x18\x02 \x01(\v23.temporal.api.schedule.v1.TriggerImmediatelyRequestH\x00R\x0etriggerRequest\x12\x1f\n" +
	"\vbackfill_id\x18\x06 \x01(\tR\n" +
	"backfillId\x12J\n" +
	"\x13last_processed_time\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\x11lastProcessedTime\x12\x18\n" +
	"\aattempt\x18\b \x01(\x03R\aattemptB\t\n" +
	"\arequestBGZEgo.temporal.io/server/chasm/lib/scheduler/gen/schedulerpb;schedulerpbb\x06proto3"

var (
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescOnce sync.Once
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescData []byte
)

func file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescGZIP() []byte {
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescOnce.Do(func() {
		file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc), len(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc)))
	})
	return file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDescData
}

var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes = []any{
	(*SchedulerInternal)(nil),            // 0: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerInternal
	(*GeneratorInternal)(nil),            // 1: temporal.server.chasm.lib.scheduler.proto.v1.GeneratorInternal
	(*InvokerInternal)(nil),              // 2: temporal.server.chasm.lib.scheduler.proto.v1.InvokerInternal
	(*BackfillerInternal)(nil),           // 3: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerInternal
	(*v1.Schedule)(nil),                  // 4: temporal.api.schedule.v1.Schedule
	(*v1.ScheduleInfo)(nil),              // 5: temporal.api.schedule.v1.ScheduleInfo
	(*v1.SchedulePatch)(nil),             // 6: temporal.api.schedule.v1.SchedulePatch
	(*timestamppb.Timestamp)(nil),        // 7: google.protobuf.Timestamp
	(*v11.BufferedStart)(nil),            // 8: temporal.server.api.schedule.v1.BufferedStart
	(*v12.WorkflowExecution)(nil),        // 9: temporal.api.common.v1.WorkflowExecution
	(*v1.BackfillRequest)(nil),           // 10: temporal.api.schedule.v1.BackfillRequest
	(*v1.TriggerImmediatelyRequest)(nil), // 11: temporal.api.schedule.v1.TriggerImmediatelyRequest
}
var file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs = []int32{
	4,  // 0: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerInternal.schedule:type_name -> temporal.api.schedule.v1.Schedule
	5,  // 1: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerInternal.info:type_name -> temporal.api.schedule.v1.ScheduleInfo
	6,  // 2: temporal.server.chasm.lib.scheduler.proto.v1.SchedulerInternal.initial_patch:type_name -> temporal.api.schedule.v1.SchedulePatch
	7,  // 3: temporal.server.chasm.lib.scheduler.proto.v1.GeneratorInternal.last_processed_time:type_name -> google.protobuf.Timestamp
	8,  // 4: temporal.server.chasm.lib.scheduler.proto.v1.InvokerInternal.buffered_starts:type_name -> temporal.server.api.schedule.v1.BufferedStart
	9,  // 5: temporal.server.chasm.lib.scheduler.proto.v1.InvokerInternal.cancel_workflows:type_name -> temporal.api.common.v1.WorkflowExecution
	9,  // 6: temporal.server.chasm.lib.scheduler.proto.v1.InvokerInternal.terminate_workflows:type_name -> temporal.api.common.v1.WorkflowExecution
	7,  // 7: temporal.server.chasm.lib.scheduler.proto.v1.InvokerInternal.last_processed_time:type_name -> google.protobuf.Timestamp
	10, // 8: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerInternal.backfill_request:type_name -> temporal.api.schedule.v1.BackfillRequest
	11, // 9: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerInternal.trigger_request:type_name -> temporal.api.schedule.v1.TriggerImmediatelyRequest
	7,  // 10: temporal.server.chasm.lib.scheduler.proto.v1.BackfillerInternal.last_processed_time:type_name -> google.protobuf.Timestamp
	11, // [11:11] is the sub-list for method output_type
	11, // [11:11] is the sub-list for method input_type
	11, // [11:11] is the sub-list for extension type_name
	11, // [11:11] is the sub-list for extension extendee
	0,  // [0:11] is the sub-list for field type_name
}

func init() { file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_init() }
func file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_init() {
	if File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto != nil {
		return
	}
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes[3].OneofWrappers = []any{
		(*BackfillerInternal_BackfillRequest)(nil),
		(*BackfillerInternal_TriggerRequest)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc), len(file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes,
		DependencyIndexes: file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs,
		MessageInfos:      file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_msgTypes,
	}.Build()
	File_temporal_server_chasm_lib_scheduler_proto_v1_message_proto = out.File
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_goTypes = nil
	file_temporal_server_chasm_lib_scheduler_proto_v1_message_proto_depIdxs = nil
}
