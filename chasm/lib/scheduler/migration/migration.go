package migration

import (
	"time"

	commonpb "go.temporal.io/api/common/v1"
	failurepb "go.temporal.io/api/failure/v1"
	schedulepb "go.temporal.io/api/schedule/v1"
	schedulespb "go.temporal.io/server/api/schedule/v1"
	schedulerpb "go.temporal.io/server/chasm/lib/scheduler/gen/schedulerpb/v1"
	"go.temporal.io/server/common"
	schedulescommon "go.temporal.io/server/common/schedules"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// LegacyState represents the complete state extracted from the legacy (workflow-powered) scheduler.
// This includes state from StartScheduleArgs and the workflow execution.
type LegacyState struct {
	// From StartScheduleArgs
	Schedule     *schedulepb.Schedule
	Info         *schedulepb.ScheduleInfo
	InitialPatch *schedulepb.SchedulePatch

	// From InternalState
	State *schedulespb.InternalState

	// From workflow execution (search attributes and memo)
	SearchAttributes map[string]*commonpb.Payload
	Memo             map[string]*commonpb.Payload
}

// CHASMState represents the complete state for the CHASM scheduler.
type CHASMState struct {
	// Scheduler root component state
	Scheduler *schedulerpb.SchedulerState

	// Generator component state
	Generator *schedulerpb.GeneratorState

	// Invoker component state
	Invoker *schedulerpb.InvokerState

	// Backfiller states (map from backfill ID)
	Backfillers map[string]*schedulerpb.BackfillerState

	// Last completion/failure data
	LastCompletionResult *schedulerpb.LastCompletionResult

	// From CHASM entity (search attributes and memo)
	SearchAttributes map[string]*commonpb.Payload
	Memo             map[string]*commonpb.Payload
}

// LegacyToCHASM converts legacy scheduler state to CHASM scheduler state.
//
// The migrationTime is used for initializing timestamps that don't have a direct mapping.
//
// State preserved during migration includes:
//   - Schedule spec and policies
//   - ScheduleInfo metadata (action counts, but not RunningWorkflows/RecentActions)
//   - Buffered starts (with V2-specific fields populated)
//   - Running workflows (converted to BufferedStarts with RunId/StartTime set)
//   - Recent actions (converted to BufferedStarts with Completed field set)
//   - Ongoing backfills (converted to Backfiller components)
//   - Last completion result/failure
//   - High water mark (Generator.LastProcessedTime)
//   - Search attributes and memo
//
// In V2, RunningWorkflows and RecentActions are computed on-demand from BufferedStarts
// by the Invoker component, rather than being stored separately.
//
// After conversion, the following tasks must be scheduled by the caller:
//   - GeneratorTask: Populates FutureActionTimes based on the schedule spec
//   - BackfillerTask: For each backfiller in the Backfillers map
//   - InvokerProcessBufferTask: Processes any buffered starts
//
// TODO(migration): Nexus callbacks should be attached to workflows in RunningWorkflows
// to enable V2's completion tracking mechanism.
func LegacyToCHASM(legacy *LegacyState, migrationTime time.Time) (*CHASMState, error) {
	state := legacy.State

	// Build SchedulerState (root component)
	// Note: Info.RunningWorkflows and Info.RecentActions are not copied because
	// V2 computes these on-demand from BufferedStarts
	info := common.CloneProto(legacy.Info)
	info.RunningWorkflows = nil
	info.RecentActions = nil

	schedulerState := &schedulerpb.SchedulerState{
		Schedule:      common.CloneProto(legacy.Schedule),
		Info:          info,
		Namespace:     state.Namespace,
		NamespaceId:   state.NamespaceId,
		ScheduleId:    state.ScheduleId,
		ConflictToken: state.ConflictToken,
		Closed:        false,
	}

	// Build GeneratorState
	// CHASM's Generator.LastProcessedTime maps to legacy's InternalState.LastProcessedTime
	generatorState := &schedulerpb.GeneratorState{
		LastProcessedTime: common.CloneProto(state.LastProcessedTime),
		// FutureActionTimes will be regenerated by the Generator task
		FutureActionTimes: nil,
	}

	// Build InvokerState
	// Convert buffered starts: populate CHASM-specific fields
	chasmBufferedStarts := convertBufferedStartsLegacyToCHASM(
		state.BufferedStarts,
		state.NamespaceId,
		state.ScheduleId,
		state.ConflictToken,
		getWorkflowID(legacy.Schedule),
	)

	// Convert RunningWorkflows to BufferedStarts with RunId/StartTime set
	runningBufferedStarts := convertRunningWorkflowsToBufferedStarts(
		legacy.Info.RunningWorkflows,
		state.NamespaceId,
		state.ScheduleId,
		state.ConflictToken,
		migrationTime,
	)

	// Convert RecentActions (completed workflows) to BufferedStarts with Completed field set
	recentActionsBufferedStarts := convertRecentActionsToBufferedStarts(
		legacy.Info.RecentActions,
		state.NamespaceId,
		state.ScheduleId,
		state.ConflictToken,
	)

	// Combine all BufferedStarts: pending starts, running workflows, and completed actions
	allBufferedStarts := append(chasmBufferedStarts, runningBufferedStarts...)
	allBufferedStarts = append(allBufferedStarts, recentActionsBufferedStarts...)

	invokerState := &schedulerpb.InvokerState{
		BufferedStarts:    allBufferedStarts,
		LastProcessedTime: timestamppb.New(migrationTime),
		// CancelWorkflows and TerminateWorkflows are left empty
		// They will be re-computed by ProcessBuffer task
	}

	// Convert ongoing backfills to Backfiller states
	backfillers := convertBackfillsLegacyToCHASM(state.OngoingBackfills, state.NamespaceId, state.ScheduleId)

	// Convert last completion result
	lastCompletion := convertLastCompletionLegacyToCHASM(state.LastCompletionResult, state.ContinuedFailure)

	return &CHASMState{
		Scheduler:            schedulerState,
		Generator:            generatorState,
		Invoker:              invokerState,
		Backfillers:          backfillers,
		LastCompletionResult: lastCompletion,
		SearchAttributes:     legacy.SearchAttributes,
		Memo:                 legacy.Memo,
	}, nil
}

// CHASMToLegacy converts CHASM scheduler state back to legacy scheduler state.
//
// The migrationTime is used for initializing timestamps that don't have a direct mapping.
//
// State preserved during migration includes:
//   - Schedule spec and policies
//   - ScheduleInfo metadata (action counts)
//   - RunningWorkflows (extracted from BufferedStarts with RunId but no Completed)
//   - RecentActions (extracted from BufferedStarts with Completed field set)
//   - Buffered starts (pending workflows only, with V2-specific fields removed)
//   - Backfiller components (converted to ongoing backfills)
//   - Last completion result/failure
//   - Search attributes and memo
//
// After conversion, NeedRefresh is set to true to trigger V1's watcher activities,
// which will monitor workflows in RunningWorkflows and process buffered starts.
func CHASMToLegacy(chasm *CHASMState, migrationTime time.Time) (*LegacyState, error) {
	bufferedStarts := chasm.Invoker.GetBufferedStarts()

	// Separate BufferedStarts into: pending, running, and completed
	var pendingStarts []*schedulespb.BufferedStart
	var runningWorkflows []*commonpb.WorkflowExecution
	var recentActions []*schedulepb.ScheduleActionResult

	for _, start := range bufferedStarts {
		if start.GetRunId() == "" {
			// Not started yet - keep as buffered start
			pendingStarts = append(pendingStarts, start)
		} else if start.GetCompleted() == nil {
			// Started but not completed - add to RunningWorkflows
			runningWorkflows = append(runningWorkflows, &commonpb.WorkflowExecution{
				WorkflowId: start.GetWorkflowId(),
				RunId:      start.GetRunId(),
			})
		} else {
			// Completed - add to RecentActions
			recentActions = append(recentActions, &schedulepb.ScheduleActionResult{
				ScheduleTime: start.GetNominalTime(),
				ActualTime:   start.GetStartTime(),
				StartWorkflowResult: &commonpb.WorkflowExecution{
					WorkflowId: start.GetWorkflowId(),
					RunId:      start.GetRunId(),
				},
				StartWorkflowStatus: start.GetCompleted().GetStatus(),
			})
		}
	}

	// Convert pending buffered starts: drop CHASM-specific fields
	legacyBufferedStarts := convertBufferedStartsCHASMToLegacy(pendingStarts)

	// Convert backfillers to ongoing backfills
	legacyBackfills := convertBackfillersCHASMToLegacy(chasm.Backfillers)

	// Convert last completion result
	lastResult, continuedFailure := convertLastCompletionCHASMToLegacy(chasm.LastCompletionResult)

	// Build InternalState
	internalState := &schedulespb.InternalState{
		Namespace:            chasm.Scheduler.Namespace,
		NamespaceId:          chasm.Scheduler.NamespaceId,
		ScheduleId:           chasm.Scheduler.ScheduleId,
		LastProcessedTime:    common.CloneProto(chasm.Generator.LastProcessedTime),
		BufferedStarts:       legacyBufferedStarts,
		OngoingBackfills:     legacyBackfills,
		LastCompletionResult: lastResult,
		ContinuedFailure:     continuedFailure,
		ConflictToken:        chasm.Scheduler.ConflictToken,
		NeedRefresh:          true, // Triggers V1 to re-arm watcher activities
	}

	// Build Info with extracted RunningWorkflows and RecentActions
	info := common.CloneProto(chasm.Scheduler.Info)
	info.RunningWorkflows = runningWorkflows
	info.RecentActions = recentActions

	return &LegacyState{
		Schedule:         common.CloneProto(chasm.Scheduler.Schedule),
		Info:             info,
		InitialPatch:     nil,
		State:            internalState,
		SearchAttributes: chasm.SearchAttributes,
		Memo:             chasm.Memo,
	}, nil
}

// convertBufferedStartsLegacyToCHASM transforms V1 buffered starts to V2 format.
// V2 requires request_id, workflow_id, attempt, and backoff_time fields.
func convertBufferedStartsLegacyToCHASM(
	v1Starts []*schedulespb.BufferedStart,
	namespaceID, scheduleID string,
	conflictToken int64,
	baseWorkflowID string,
) []*schedulespb.BufferedStart {
	if len(v1Starts) == 0 {
		return nil
	}

	v2Starts := make([]*schedulespb.BufferedStart, len(v1Starts))
	for i, v1Start := range v1Starts {
		v2Start := common.CloneProto(v1Start)

		// Generate request_id if not present (V1 doesn't populate this)
		if v2Start.RequestId == "" {
			v2Start.RequestId = schedulescommon.GenerateRequestID(
				namespaceID,
				scheduleID,
				conflictToken,
				"migrated",
				v1Start.GetNominalTime().AsTime(),
				v1Start.GetActualTime().AsTime(),
			)
		}

		// Generate workflow_id if not present
		if v2Start.WorkflowId == "" {
			v2Start.WorkflowId = schedulescommon.GenerateWorkflowID(
				baseWorkflowID,
				v1Start.GetNominalTime().AsTime(),
			)
		}

		// Set attempt = 0 (pending initial processing in V2)
		v2Start.Attempt = 0

		// Clear backoff_time (not applicable for initial migration)
		v2Start.BackoffTime = nil

		v2Starts[i] = v2Start
	}

	return v2Starts
}

// convertRunningWorkflowsToBufferedStarts converts V1's RunningWorkflows list to V2's
// BufferedStarts format. In V2, running workflows are represented as BufferedStarts with
// RunId and StartTime populated, and Completed field empty.
func convertRunningWorkflowsToBufferedStarts(
	runningWorkflows []*commonpb.WorkflowExecution,
	namespaceID, scheduleID string,
	conflictToken int64,
	migrationTime time.Time,
) []*schedulespb.BufferedStart {
	if len(runningWorkflows) == 0 {
		return nil
	}

	bufferedStarts := make([]*schedulespb.BufferedStart, len(runningWorkflows))
	for i, wf := range runningWorkflows {
		// We don't have the original nominal/actual times for running workflows,
		// so we use migrationTime as a placeholder
		bufferedStarts[i] = &schedulespb.BufferedStart{
			NominalTime: timestamppb.New(migrationTime),
			ActualTime:  timestamppb.New(migrationTime),
			StartTime:   timestamppb.New(migrationTime),
			WorkflowId:  wf.WorkflowId,
			RunId:       wf.RunId,
			RequestId: schedulescommon.GenerateRequestID(
				namespaceID,
				scheduleID,
				conflictToken,
				"migrated-running",
				migrationTime,
				migrationTime,
			),
			Attempt:   1,   // Already started, so attempt >= 1
			Completed: nil, // Still running
		}
	}

	return bufferedStarts
}

// convertRecentActionsToBufferedStarts converts V1's RecentActions list to V2's
// BufferedStarts format. In V2, completed actions are represented as BufferedStarts with
// RunId, StartTime, and Completed fields all populated.
func convertRecentActionsToBufferedStarts(
	recentActions []*schedulepb.ScheduleActionResult,
	namespaceID, scheduleID string,
	conflictToken int64,
) []*schedulespb.BufferedStart {
	if len(recentActions) == 0 {
		return nil
	}

	bufferedStarts := make([]*schedulespb.BufferedStart, 0, len(recentActions))
	for _, action := range recentActions {
		// Only include actions that actually started a workflow
		if action.StartWorkflowResult == nil {
			continue
		}

		bufferedStarts = append(bufferedStarts, &schedulespb.BufferedStart{
			NominalTime: action.ScheduleTime,
			ActualTime:  action.ActualTime,
			StartTime:   action.ActualTime,
			WorkflowId:  action.StartWorkflowResult.WorkflowId,
			RunId:       action.StartWorkflowResult.RunId,
			RequestId: schedulescommon.GenerateRequestID(
				namespaceID,
				scheduleID,
				conflictToken,
				"migrated-completed",
				action.ScheduleTime.AsTime(),
				action.ActualTime.AsTime(),
			),
			Attempt: 1,
			Completed: &schedulespb.CompletedResult{
				Status:    action.StartWorkflowStatus,
				CloseTime: action.ActualTime, // Use actual time as approximation
			},
		})
	}

	return bufferedStarts
}

// convertBufferedStartsCHASMToLegacy transforms V2 pending buffered starts to V1 format.
// This should only be called on BufferedStarts that have not been started yet (no RunId).
// V1 doesn't use request_id, workflow_id, attempt, backoff_time, run_id, start_time, or completed fields.
func convertBufferedStartsCHASMToLegacy(v2Starts []*schedulespb.BufferedStart) []*schedulespb.BufferedStart {
	if len(v2Starts) == 0 {
		return nil
	}

	v1Starts := make([]*schedulespb.BufferedStart, len(v2Starts))
	for i, v2Start := range v2Starts {
		v1Start := common.CloneProto(v2Start)

		// Drop all V2-specific fields
		v1Start.RequestId = ""
		v1Start.WorkflowId = ""
		v1Start.Attempt = 0
		v1Start.BackoffTime = nil
		v1Start.RunId = ""
		v1Start.StartTime = nil
		v1Start.Completed = nil

		v1Starts[i] = v1Start
	}

	return v1Starts
}

// convertBackfillsLegacyToCHASM transforms V1 ongoing backfills to V2 Backfiller states.
// V1 backfills track progress by advancing the BackfillRequest.StartTime, while V2 uses
// a separate LastProcessedTime field. When converting to V2, LastProcessedTime is left
// uninitialized, allowing the Backfiller to start from the request's original StartTime.
func convertBackfillsLegacyToCHASM(
	legacyBackfills []*schedulepb.BackfillRequest,
	namespaceID, scheduleID string,
) map[string]*schedulerpb.BackfillerState {
	if len(legacyBackfills) == 0 {
		return nil
	}

	backfillers := make(map[string]*schedulerpb.BackfillerState, len(legacyBackfills))
	for _, v1Backfill := range legacyBackfills {
		// Generate a unique backfill ID using the centralized ID generator
		backfillID := schedulescommon.GenerateBackfillerID()

		backfillers[backfillID] = &schedulerpb.BackfillerState{
			Request: &schedulerpb.BackfillerState_BackfillRequest{
				BackfillRequest: common.CloneProto(v1Backfill),
			},
			BackfillId: backfillID,
			// LastProcessedTime is left uninitialized, allowing V2 to start from
			// the BackfillRequest's StartTime
			LastProcessedTime: nil,
			Attempt:           0,
		}
	}

	return backfillers
}

// convertBackfillersCHASMToLegacy transforms V2 Backfiller states to V1 ongoing backfills.
// V2 tracks backfill progress in a separate LastProcessedTime field, while V1 advances
// the BackfillRequest.StartTime directly. This conversion updates StartTime to reflect
// the current progress, allowing V1 to continue from where V2 left off.
func convertBackfillersCHASMToLegacy(v2Backfillers map[string]*schedulerpb.BackfillerState) []*schedulepb.BackfillRequest {
	if len(v2Backfillers) == 0 {
		return nil
	}

	legacyBackfills := make([]*schedulepb.BackfillRequest, 0, len(v2Backfillers))
	for _, backfiller := range v2Backfillers {
		switch req := backfiller.Request.(type) {
		case *schedulerpb.BackfillerState_BackfillRequest:
			v1Backfill := common.CloneProto(req.BackfillRequest)

			// Update StartTime to reflect V2's processing progress, preserving
			// the backfill's current position
			if backfiller.LastProcessedTime != nil {
				v1Backfill.StartTime = common.CloneProto(backfiller.LastProcessedTime)
			}

			legacyBackfills = append(legacyBackfills, v1Backfill)

		case *schedulerpb.BackfillerState_TriggerRequest:
			// TriggerImmediately requests are handled as buffered starts in V1, not backfills.
			// If still pending, they are already present in BufferedStarts.
			continue
		}
	}

	return legacyBackfills
}

// convertLastCompletionLegacyToCHASM transforms V1 completion result to V2 format.
// V1 uses Payloads (plural), V2 uses single Payload.
func convertLastCompletionLegacyToCHASM(
	result *commonpb.Payloads,
	failure *failurepb.Failure,
) *schedulerpb.LastCompletionResult {
	if result == nil && failure == nil {
		return nil
	}

	lcr := &schedulerpb.LastCompletionResult{}

	// V1 stores Payloads (plural), V2 stores single Payload
	// Take the first payload if present
	if result != nil && len(result.Payloads) > 0 {
		lcr.Success = common.CloneProto(result.Payloads[0])
	}

	if failure != nil {
		lcr.Failure = common.CloneProto(failure)
	}

	return lcr
}

// convertLastCompletionCHASMToLegacy transforms V2 completion result to V1 format.
// V2 uses single Payload, V1 uses Payloads (plural).
func convertLastCompletionCHASMToLegacy(result *schedulerpb.LastCompletionResult) (*commonpb.Payloads, *failurepb.Failure) {
	if result == nil {
		return nil, nil
	}

	var lastResult *commonpb.Payloads
	if result.Success != nil {
		lastResult = &commonpb.Payloads{
			Payloads: []*commonpb.Payload{common.CloneProto(result.Success)},
		}
	}

	var continuedFailure *failurepb.Failure
	if result.Failure != nil {
		continuedFailure = common.CloneProto(result.Failure)
	}

	return lastResult, continuedFailure
}

// getWorkflowID extracts the workflow ID from the schedule's action.
// This is the workflow ID specified in the schedule spec. During workflow start
// generation, nominal time is suffixed to this ID.
func getWorkflowID(schedule *schedulepb.Schedule) string {
	if schedule == nil {
		return ""
	}
	return schedule.GetAction().GetStartWorkflow().GetWorkflowId()
}
