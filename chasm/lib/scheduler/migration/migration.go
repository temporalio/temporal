package migration

import (
	"time"

	commonpb "go.temporal.io/api/common/v1"
	failurepb "go.temporal.io/api/failure/v1"
	schedulepb "go.temporal.io/api/schedule/v1"
	schedulespb "go.temporal.io/server/api/schedule/v1"
	schedulerpb "go.temporal.io/server/chasm/lib/scheduler/gen/schedulerpb/v1"
	"go.temporal.io/server/common"
	schedulescommon "go.temporal.io/server/common/schedules"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// LegacyState represents the complete state extracted from the legacy (workflow-powered) scheduler.
// This includes state from StartScheduleArgs and the workflow execution.
type LegacyState struct {
	// From StartScheduleArgs
	Schedule     *schedulepb.Schedule
	Info         *schedulepb.ScheduleInfo
	InitialPatch *schedulepb.SchedulePatch

	// From InternalState
	State *schedulespb.InternalState

	// From workflow execution (search attributes and memo)
	SearchAttributes map[string]*commonpb.Payload
	Memo             map[string]*commonpb.Payload
}

// CHASMState represents the complete state for the CHASM scheduler.
type CHASMState struct {
	// Scheduler root component state
	Scheduler *schedulerpb.SchedulerState

	// Generator component state
	Generator *schedulerpb.GeneratorState

	// Invoker component state
	Invoker *schedulerpb.InvokerState

	// Backfiller states (map from backfill ID)
	Backfillers map[string]*schedulerpb.BackfillerState

	// Last completion/failure data
	LastCompletionResult *schedulerpb.LastCompletionResult

	// From CHASM entity (search attributes and memo)
	SearchAttributes map[string]*commonpb.Payload
	Memo             map[string]*commonpb.Payload
}

// LegacyToCHASM converts legacy scheduler state to CHASM scheduler state.
//
// The migrationTime is used for initializing timestamps that don't have a direct mapping.
//
// State preserved during migration includes:
//   - Schedule spec and policies
//   - ScheduleInfo (including RecentActions and RunningWorkflows)
//   - Buffered starts (with V2-specific fields populated)
//   - Ongoing backfills (converted to Backfiller components)
//   - Last completion result/failure
//   - High water mark (Generator.LastProcessedTime)
//   - Search attributes and memo
//
// After conversion, the following tasks must be scheduled by the caller:
//   - GeneratorTask: Populates FutureActionTimes based on the schedule spec
//   - BackfillerTask: For each backfiller in the Backfillers map
//   - InvokerProcessBufferTask: Processes any buffered starts
//
// TODO(migration): Nexus callbacks should be attached to workflows in RunningWorkflows
// to enable V2's completion tracking mechanism.
func LegacyToCHASM(legacy *LegacyState, migrationTime time.Time) (*CHASMState, error) {
	state := legacy.State

	// Build SchedulerState (root component)
	schedulerState := &schedulerpb.SchedulerState{
		Schedule:      common.CloneProto(legacy.Schedule),
		Info:          common.CloneProto(legacy.Info),
		Namespace:     state.Namespace,
		NamespaceId:   state.NamespaceId,
		ScheduleId:    state.ScheduleId,
		ConflictToken: state.ConflictToken,
		Closed:        false,
	}

	// Build GeneratorState
	// CHASM's Generator.LastProcessedTime maps to legacy's InternalState.LastProcessedTime
	generatorState := &schedulerpb.GeneratorState{
		LastProcessedTime: common.CloneProto(state.LastProcessedTime),
		// FutureActionTimes will be regenerated by the Generator task
		FutureActionTimes: nil,
	}

	// Build InvokerState
	// Convert buffered starts: populate CHASM-specific fields
	chasmBufferedStarts := convertBufferedStartsLegacyToCHASM(
		state.BufferedStarts,
		state.NamespaceId,
		state.ScheduleId,
		state.ConflictToken,
		getWorkflowID(legacy.Schedule),
	)

	invokerState := &schedulerpb.InvokerState{
		BufferedStarts:    chasmBufferedStarts,
		LastProcessedTime: timestamppb.New(migrationTime),
		// CancelWorkflows and TerminateWorkflows are left empty
		// They will be re-computed by ProcessBuffer task
	}

	// Convert ongoing backfills to Backfiller states
	backfillers := convertBackfillsLegacyToCHASM(state.OngoingBackfills, state.NamespaceId, state.ScheduleId)

	// Convert last completion result
	lastCompletion := convertLastCompletionLegacyToCHASM(state.LastCompletionResult, state.ContinuedFailure)

	return &CHASMState{
		Scheduler:            schedulerState,
		Generator:            generatorState,
		Invoker:              invokerState,
		Backfillers:          backfillers,
		LastCompletionResult: lastCompletion,
		SearchAttributes:     legacy.SearchAttributes,
		Memo:                 legacy.Memo,
	}, nil
}

// CHASMToLegacy converts CHASM scheduler state back to legacy scheduler state.
//
// The migrationTime is used for initializing timestamps that don't have a direct mapping.
//
// State preserved during migration includes:
//   - Schedule spec and policies
//   - ScheduleInfo (including RecentActions and RunningWorkflows)
//   - Buffered starts (with V2-specific fields removed)
//   - Backfiller components (converted to ongoing backfills)
//   - Last completion result/failure
//   - Search attributes and memo
//
// After conversion, NeedRefresh is set to true to trigger V1's watcher activities,
// which will monitor workflows in RunningWorkflows and process buffered starts.
func CHASMToLegacy(chasm *CHASMState, migrationTime time.Time) (*LegacyState, error) {
	// Convert buffered starts: drop CHASM-specific fields
	legacyBufferedStarts := convertBufferedStartsCHASMToLegacy(chasm.Invoker.GetBufferedStarts())

	// Convert backfillers to ongoing backfills
	legacyBackfills := convertBackfillersCHASMToLegacy(chasm.Backfillers)

	// Convert last completion result
	lastResult, continuedFailure := convertLastCompletionCHASMToLegacy(chasm.LastCompletionResult)

	// Build InternalState
	internalState := &schedulespb.InternalState{
		Namespace:            chasm.Scheduler.Namespace,
		NamespaceId:          chasm.Scheduler.NamespaceId,
		ScheduleId:           chasm.Scheduler.ScheduleId,
		LastProcessedTime:    common.CloneProto(chasm.Generator.LastProcessedTime),
		BufferedStarts:       legacyBufferedStarts,
		OngoingBackfills:     legacyBackfills,
		LastCompletionResult: lastResult,
		ContinuedFailure:     continuedFailure,
		ConflictToken:        chasm.Scheduler.ConflictToken,
		NeedRefresh:          true, // Triggers V1 to re-arm watcher activities
	}

	return &LegacyState{
		Schedule:         common.CloneProto(chasm.Scheduler.Schedule),
		Info:             common.CloneProto(chasm.Scheduler.Info),
		InitialPatch:     nil,
		State:            internalState,
		SearchAttributes: chasm.SearchAttributes,
		Memo:             chasm.Memo,
	}, nil
}

// convertBufferedStartsLegacyToCHASM transforms V1 buffered starts to V2 format.
// V2 requires request_id, workflow_id, attempt, and backoff_time fields.
func convertBufferedStartsLegacyToCHASM(
	v1Starts []*schedulespb.BufferedStart,
	namespaceID, scheduleID string,
	conflictToken int64,
	baseWorkflowID string,
) []*schedulespb.BufferedStart {
	if len(v1Starts) == 0 {
		return nil
	}

	v2Starts := make([]*schedulespb.BufferedStart, len(v1Starts))
	for i, v1Start := range v1Starts {
		v2Start := common.CloneProto(v1Start)

		// Generate request_id if not present (V1 doesn't populate this)
		if v2Start.RequestId == "" {
			v2Start.RequestId = schedulescommon.GenerateRequestID(
				namespaceID,
				scheduleID,
				conflictToken,
				"migrated",
				v1Start.GetNominalTime().AsTime(),
				v1Start.GetActualTime().AsTime(),
			)
		}

		// Generate workflow_id if not present
		if v2Start.WorkflowId == "" {
			v2Start.WorkflowId = schedulescommon.GenerateWorkflowID(
				baseWorkflowID,
				v1Start.GetNominalTime().AsTime(),
			)
		}

		// Set attempt = 0 (pending initial processing in V2)
		v2Start.Attempt = 0

		// Clear backoff_time (not applicable for initial migration)
		v2Start.BackoffTime = nil

		v2Starts[i] = v2Start
	}

	return v2Starts
}

// convertBufferedStartsCHASMToLegacy transforms V2 buffered starts to V1 format.
// V1 doesn't use request_id, workflow_id, attempt, or backoff_time fields.
func convertBufferedStartsCHASMToLegacy(v2Starts []*schedulespb.BufferedStart) []*schedulespb.BufferedStart {
	if len(v2Starts) == 0 {
		return nil
	}

	v1Starts := make([]*schedulespb.BufferedStart, len(v2Starts))
	for i, v2Start := range v2Starts {
		v1Start := common.CloneProto(v2Start)

		// Drop V2-specific fields
		v1Start.RequestId = ""
		v1Start.WorkflowId = ""
		v1Start.Attempt = 0
		v1Start.BackoffTime = nil

		v1Starts[i] = v1Start
	}

	return v1Starts
}

// convertBackfillsLegacyToCHASM transforms V1 ongoing backfills to V2 Backfiller states.
// V1 backfills track progress by advancing the BackfillRequest.StartTime, while V2 uses
// a separate LastProcessedTime field. When converting to V2, LastProcessedTime is left
// uninitialized, allowing the Backfiller to start from the request's original StartTime.
func convertBackfillsLegacyToCHASM(
	legacyBackfills []*schedulepb.BackfillRequest,
	namespaceID, scheduleID string,
) map[string]*schedulerpb.BackfillerState {
	if len(legacyBackfills) == 0 {
		return nil
	}

	backfillers := make(map[string]*schedulerpb.BackfillerState, len(legacyBackfills))
	for _, v1Backfill := range legacyBackfills {
		// Generate a unique backfill ID using the centralized ID generator
		backfillID := schedulescommon.GenerateBackfillerID()

		backfillers[backfillID] = &schedulerpb.BackfillerState{
			Request: &schedulerpb.BackfillerState_BackfillRequest{
				BackfillRequest: common.CloneProto(v1Backfill),
			},
			BackfillId: backfillID,
			// LastProcessedTime is left uninitialized, allowing V2 to start from
			// the BackfillRequest's StartTime
			LastProcessedTime: nil,
			Attempt:           0,
		}
	}

	return backfillers
}

// convertBackfillersCHASMToLegacy transforms V2 Backfiller states to V1 ongoing backfills.
// V2 tracks backfill progress in a separate LastProcessedTime field, while V1 advances
// the BackfillRequest.StartTime directly. This conversion updates StartTime to reflect
// the current progress, allowing V1 to continue from where V2 left off.
func convertBackfillersCHASMToLegacy(v2Backfillers map[string]*schedulerpb.BackfillerState) []*schedulepb.BackfillRequest {
	if len(v2Backfillers) == 0 {
		return nil
	}

	legacyBackfills := make([]*schedulepb.BackfillRequest, 0, len(v2Backfillers))
	for _, backfiller := range v2Backfillers {
		switch req := backfiller.Request.(type) {
		case *schedulerpb.BackfillerState_BackfillRequest:
			v1Backfill := common.CloneProto(req.BackfillRequest)

			// Update StartTime to reflect V2's processing progress, preserving
			// the backfill's current position
			if backfiller.LastProcessedTime != nil {
				v1Backfill.StartTime = common.CloneProto(backfiller.LastProcessedTime)
			}

			legacyBackfills = append(legacyBackfills, v1Backfill)

		case *schedulerpb.BackfillerState_TriggerRequest:
			// TriggerImmediately requests are handled as buffered starts in V1, not backfills.
			// If still pending, they are already present in BufferedStarts.
			continue
		}
	}

	return legacyBackfills
}

// convertLastCompletionLegacyToCHASM transforms V1 completion result to V2 format.
// V1 uses Payloads (plural), V2 uses single Payload.
func convertLastCompletionLegacyToCHASM(
	result *commonpb.Payloads,
	failure *failurepb.Failure,
) *schedulerpb.LastCompletionResult {
	if result == nil && failure == nil {
		return nil
	}

	lcr := &schedulerpb.LastCompletionResult{}

	// V1 stores Payloads (plural), V2 stores single Payload
	// Take the first payload if present
	if result != nil && len(result.Payloads) > 0 {
		lcr.Success = common.CloneProto(result.Payloads[0])
	}

	if failure != nil {
		lcr.Failure = common.CloneProto(failure)
	}

	return lcr
}

// convertLastCompletionCHASMToLegacy transforms V2 completion result to V1 format.
// V2 uses single Payload, V1 uses Payloads (plural).
func convertLastCompletionCHASMToLegacy(result *schedulerpb.LastCompletionResult) (*commonpb.Payloads, *failurepb.Failure) {
	if result == nil {
		return nil, nil
	}

	var lastResult *commonpb.Payloads
	if result.Success != nil {
		lastResult = &commonpb.Payloads{
			Payloads: []*commonpb.Payload{common.CloneProto(result.Success)},
		}
	}

	var continuedFailure *failurepb.Failure
	if result.Failure != nil {
		continuedFailure = common.CloneProto(result.Failure)
	}

	return lastResult, continuedFailure
}

// buildRequestIdToWorkflowIdMap creates the mapping used by V2 Invoker for Nexus callbacks.
func buildRequestIdToWorkflowIdMap(starts []*schedulespb.BufferedStart) map[string]string {
	if len(starts) == 0 {
		return make(map[string]string)
	}

	m := make(map[string]string, len(starts))
	for _, start := range starts {
		if start.RequestId != "" && start.WorkflowId != "" {
			m[start.RequestId] = start.WorkflowId
		}
	}
	return m
}

// getWorkflowID extracts the workflow ID from the schedule's action.
// This is the workflow ID specified in the schedule spec. During workflow start
// generation, nominal time is suffixed to this ID.
func getWorkflowID(schedule *schedulepb.Schedule) string {
	if schedule == nil {
		return ""
	}
	return schedule.GetAction().GetStartWorkflow().GetWorkflowId()
}
