// Code generated by protoc-gen-go-chasm. DO NOT EDIT.
package activitypb

import (
	"context"
	"time"

	"go.temporal.io/server/client/history"
	"go.temporal.io/server/common"
	"go.temporal.io/server/common/backoff"
	"go.temporal.io/server/common/config"
	"go.temporal.io/server/common/dynamicconfig"
	"go.temporal.io/server/common/headers"
	"go.temporal.io/server/common/log"
	"go.temporal.io/server/common/membership"
	"go.temporal.io/server/common/metrics"
	"go.temporal.io/server/common/primitives"
	"google.golang.org/grpc"
)

// ActivityServiceLayeredClient is a client for ActivityService.
type ActivityServiceLayeredClient struct {
	metricsHandler metrics.Handler
	numShards      int32
	redirector     history.Redirector[ActivityServiceClient]
	retryPolicy    backoff.RetryPolicy
}

// NewActivityServiceLayeredClient initializes a new ActivityServiceLayeredClient.
func NewActivityServiceLayeredClient(
	dc *dynamicconfig.Collection,
	rpcFactory common.RPCFactory,
	monitor membership.Monitor,
	config *config.Persistence,
	logger log.Logger,
	metricsHandler metrics.Handler,
) (ActivityServiceClient, error) {
	resolver, err := monitor.GetResolver(primitives.HistoryService)
	if err != nil {
		return nil, err
	}
	connections := history.NewConnectionPool(resolver, rpcFactory, NewActivityServiceClient)
	var redirector history.Redirector[ActivityServiceClient]
	if dynamicconfig.HistoryClientOwnershipCachingEnabled.Get(dc)() {
		redirector = history.NewCachingRedirector(
			connections,
			resolver,
			logger,
			dynamicconfig.HistoryClientOwnershipCachingStaleTTL.Get(dc),
		)
	} else {
		redirector = history.NewBasicRedirector(connections, resolver)
	}
	return &ActivityServiceLayeredClient{
		metricsHandler: metricsHandler,
		redirector:     redirector,
		numShards:      config.NumHistoryShards,
		retryPolicy:    common.CreateHistoryClientRetryPolicy(),
	}, nil
}
func (c *ActivityServiceLayeredClient) callStartActivityExecutionNoRetry(
	ctx context.Context,
	request *StartActivityExecutionRequest,
	opts ...grpc.CallOption,
) (*StartActivityExecutionResponse, error) {
	var response *StartActivityExecutionResponse
	var err error
	startTime := time.Now().UTC()
	// the caller is a namespace, hence the tag below.
	caller := headers.GetCallerInfo(ctx).CallerName
	metricsHandler := c.metricsHandler.WithTags(
		metrics.OperationTag("ActivityService.StartActivityExecution"),
		metrics.NamespaceTag(caller),
		metrics.ServiceRoleTag(metrics.HistoryRoleTagValue),
	)
	metrics.ClientRequests.With(metricsHandler).Record(1)
	defer func() {
		if err != nil {
			metrics.ClientFailures.With(metricsHandler).Record(1, metrics.ServiceErrorTypeTag(err))
		}
		metrics.ClientLatency.With(metricsHandler).Record(time.Since(startTime))
	}()
	shardID := common.WorkflowIDToHistoryShard(request.GetNamespaceId(), request.GetFrontendRequest().GetActivityId(), c.numShards)
	op := func(ctx context.Context, client ActivityServiceClient) error {
		var err error
		ctx, cancel := context.WithTimeout(ctx, history.DefaultTimeout)
		defer cancel()
		response, err = client.StartActivityExecution(ctx, request, opts...)
		return err
	}
	err = c.redirector.Execute(ctx, shardID, op)
	return response, err
}
func (c *ActivityServiceLayeredClient) StartActivityExecution(
	ctx context.Context,
	request *StartActivityExecutionRequest,
	opts ...grpc.CallOption,
) (*StartActivityExecutionResponse, error) {
	call := func(ctx context.Context) (*StartActivityExecutionResponse, error) {
		return c.callStartActivityExecutionNoRetry(ctx, request, opts...)
	}
	return backoff.ThrottleRetryContextWithReturn(ctx, call, c.retryPolicy, common.IsServiceClientTransientError)
}
func (c *ActivityServiceLayeredClient) callDescribeActivityExecutionNoRetry(
	ctx context.Context,
	request *DescribeActivityExecutionRequest,
	opts ...grpc.CallOption,
) (*DescribeActivityExecutionResponse, error) {
	var response *DescribeActivityExecutionResponse
	var err error
	startTime := time.Now().UTC()
	// the caller is a namespace, hence the tag below.
	caller := headers.GetCallerInfo(ctx).CallerName
	metricsHandler := c.metricsHandler.WithTags(
		metrics.OperationTag("ActivityService.DescribeActivityExecution"),
		metrics.NamespaceTag(caller),
		metrics.ServiceRoleTag(metrics.HistoryRoleTagValue),
	)
	metrics.ClientRequests.With(metricsHandler).Record(1)
	defer func() {
		if err != nil {
			metrics.ClientFailures.With(metricsHandler).Record(1, metrics.ServiceErrorTypeTag(err))
		}
		metrics.ClientLatency.With(metricsHandler).Record(time.Since(startTime))
	}()
	shardID := common.WorkflowIDToHistoryShard(request.GetNamespaceId(), request.GetFrontendRequest().GetActivityId(), c.numShards)
	op := func(ctx context.Context, client ActivityServiceClient) error {
		var err error
		ctx, cancel := context.WithTimeout(ctx, history.DefaultTimeout)
		defer cancel()
		response, err = client.DescribeActivityExecution(ctx, request, opts...)
		return err
	}
	err = c.redirector.Execute(ctx, shardID, op)
	return response, err
}
func (c *ActivityServiceLayeredClient) DescribeActivityExecution(
	ctx context.Context,
	request *DescribeActivityExecutionRequest,
	opts ...grpc.CallOption,
) (*DescribeActivityExecutionResponse, error) {
	call := func(ctx context.Context) (*DescribeActivityExecutionResponse, error) {
		return c.callDescribeActivityExecutionNoRetry(ctx, request, opts...)
	}
	return backoff.ThrottleRetryContextWithReturn(ctx, call, c.retryPolicy, common.IsServiceClientTransientError)
}
func (c *ActivityServiceLayeredClient) callPollActivityExecutionNoRetry(
	ctx context.Context,
	request *PollActivityExecutionRequest,
	opts ...grpc.CallOption,
) (*PollActivityExecutionResponse, error) {
	var response *PollActivityExecutionResponse
	var err error
	startTime := time.Now().UTC()
	// the caller is a namespace, hence the tag below.
	caller := headers.GetCallerInfo(ctx).CallerName
	metricsHandler := c.metricsHandler.WithTags(
		metrics.OperationTag("ActivityService.PollActivityExecution"),
		metrics.NamespaceTag(caller),
		metrics.ServiceRoleTag(metrics.HistoryRoleTagValue),
	)
	metrics.ClientRequests.With(metricsHandler).Record(1)
	defer func() {
		if err != nil {
			metrics.ClientFailures.With(metricsHandler).Record(1, metrics.ServiceErrorTypeTag(err))
		}
		metrics.ClientLatency.With(metricsHandler).Record(time.Since(startTime))
	}()
	shardID := common.WorkflowIDToHistoryShard(request.GetNamespaceId(), request.GetFrontendRequest().GetActivityId(), c.numShards)
	op := func(ctx context.Context, client ActivityServiceClient) error {
		var err error
		ctx, cancel := context.WithTimeout(ctx, history.DefaultTimeout)
		defer cancel()
		response, err = client.PollActivityExecution(ctx, request, opts...)
		return err
	}
	err = c.redirector.Execute(ctx, shardID, op)
	return response, err
}
func (c *ActivityServiceLayeredClient) PollActivityExecution(
	ctx context.Context,
	request *PollActivityExecutionRequest,
	opts ...grpc.CallOption,
) (*PollActivityExecutionResponse, error) {
	call := func(ctx context.Context) (*PollActivityExecutionResponse, error) {
		return c.callPollActivityExecutionNoRetry(ctx, request, opts...)
	}
	return backoff.ThrottleRetryContextWithReturn(ctx, call, c.retryPolicy, common.IsServiceClientTransientError)
}
func (c *ActivityServiceLayeredClient) callTerminateActivityExecutionNoRetry(
	ctx context.Context,
	request *TerminateActivityExecutionRequest,
	opts ...grpc.CallOption,
) (*TerminateActivityExecutionResponse, error) {
	var response *TerminateActivityExecutionResponse
	var err error
	startTime := time.Now().UTC()
	// the caller is a namespace, hence the tag below.
	caller := headers.GetCallerInfo(ctx).CallerName
	metricsHandler := c.metricsHandler.WithTags(
		metrics.OperationTag("ActivityService.TerminateActivityExecution"),
		metrics.NamespaceTag(caller),
		metrics.ServiceRoleTag(metrics.HistoryRoleTagValue),
	)
	metrics.ClientRequests.With(metricsHandler).Record(1)
	defer func() {
		if err != nil {
			metrics.ClientFailures.With(metricsHandler).Record(1, metrics.ServiceErrorTypeTag(err))
		}
		metrics.ClientLatency.With(metricsHandler).Record(time.Since(startTime))
	}()
	shardID := common.WorkflowIDToHistoryShard(request.GetNamespaceId(), request.GetFrontendRequest().GetActivityId(), c.numShards)
	op := func(ctx context.Context, client ActivityServiceClient) error {
		var err error
		ctx, cancel := context.WithTimeout(ctx, history.DefaultTimeout)
		defer cancel()
		response, err = client.TerminateActivityExecution(ctx, request, opts...)
		return err
	}
	err = c.redirector.Execute(ctx, shardID, op)
	return response, err
}
func (c *ActivityServiceLayeredClient) TerminateActivityExecution(
	ctx context.Context,
	request *TerminateActivityExecutionRequest,
	opts ...grpc.CallOption,
) (*TerminateActivityExecutionResponse, error) {
	call := func(ctx context.Context) (*TerminateActivityExecutionResponse, error) {
		return c.callTerminateActivityExecutionNoRetry(ctx, request, opts...)
	}
	return backoff.ThrottleRetryContextWithReturn(ctx, call, c.retryPolicy, common.IsServiceClientTransientError)
}
func (c *ActivityServiceLayeredClient) callRequestCancelActivityExecutionNoRetry(
	ctx context.Context,
	request *RequestCancelActivityExecutionRequest,
	opts ...grpc.CallOption,
) (*RequestCancelActivityExecutionResponse, error) {
	var response *RequestCancelActivityExecutionResponse
	var err error
	startTime := time.Now().UTC()
	// the caller is a namespace, hence the tag below.
	caller := headers.GetCallerInfo(ctx).CallerName
	metricsHandler := c.metricsHandler.WithTags(
		metrics.OperationTag("ActivityService.RequestCancelActivityExecution"),
		metrics.NamespaceTag(caller),
		metrics.ServiceRoleTag(metrics.HistoryRoleTagValue),
	)
	metrics.ClientRequests.With(metricsHandler).Record(1)
	defer func() {
		if err != nil {
			metrics.ClientFailures.With(metricsHandler).Record(1, metrics.ServiceErrorTypeTag(err))
		}
		metrics.ClientLatency.With(metricsHandler).Record(time.Since(startTime))
	}()
	shardID := common.WorkflowIDToHistoryShard(request.GetNamespaceId(), request.GetFrontendRequest().GetActivityId(), c.numShards)
	op := func(ctx context.Context, client ActivityServiceClient) error {
		var err error
		ctx, cancel := context.WithTimeout(ctx, history.DefaultTimeout)
		defer cancel()
		response, err = client.RequestCancelActivityExecution(ctx, request, opts...)
		return err
	}
	err = c.redirector.Execute(ctx, shardID, op)
	return response, err
}
func (c *ActivityServiceLayeredClient) RequestCancelActivityExecution(
	ctx context.Context,
	request *RequestCancelActivityExecutionRequest,
	opts ...grpc.CallOption,
) (*RequestCancelActivityExecutionResponse, error) {
	call := func(ctx context.Context) (*RequestCancelActivityExecutionResponse, error) {
		return c.callRequestCancelActivityExecutionNoRetry(ctx, request, opts...)
	}
	return backoff.ThrottleRetryContextWithReturn(ctx, call, c.retryPolicy, common.IsServiceClientTransientError)
}
