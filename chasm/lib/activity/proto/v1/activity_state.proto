syntax = "proto3";

package temporal.server.chasm.lib.activity.proto.v1;

option go_package = "go.temporal.io/server/chasm/lib/activity/gen/activitypb;activitypb";

import "google/protobuf/timestamp.proto";
import "temporal/api/activity/v1/message.proto";
import "temporal/api/common/v1/message.proto";
import "temporal/api/failure/v1/message.proto";
import "temporal/api/sdk/v1/user_metadata.proto";


enum ActivityExecutionStatus {
    ACTIVITY_EXECUTION_STATUS_UNSPECIFIED = 0;
    ACTIVITY_EXECUTION_STATUS_SCHEDULED = 1;
    ACTIVITY_EXECUTION_STATUS_STARTED = 2;
    ACTIVITY_EXECUTION_STATUS_CANCEL_REQUESTED = 3;
    // Left as placeholders for when we add pause.
    // // PAUSED means activity is paused on the server, and is not running in the worker
    // ACTIVITY_EXECUTION_STATUS_PAUSED = 4;
    // // PAUSE_REQUESTED means activity is currently running on the worker, but paused on the server
    // ACTIVITY_EXECUTION_STATUS_PAUSE_REQUESTED = 5;
    // The activity completed successfully.
    ACTIVITY_EXECUTION_STATUS_COMPLETED = 4;
    // The activity completed with failure.
    ACTIVITY_EXECUTION_STATUS_FAILED = 5;
    // The activity completed as canceled.
    // Requesting to cancel an activity does not automatically transition the activity to canceled status. If the
    // activity has a currently running attempt, the activity will only transition to canceled status if the current
    // attempt is unsuccessful.
    // TODO: Clarify what happens if there are no more allowed retries after the current attempt.
    ACTIVITY_EXECUTION_STATUS_CANCELED = 6;
    // The activity was terminated. Termination does not reach the worker and the activity code cannot react to it.
    // A terminated activity may have a running attempt and will be requested to be canceled by the server when it
    // heartbeats.
    ACTIVITY_EXECUTION_STATUS_TERMINATED = 7;
    // The activity has timed out by reaching the specified shedule-to-start or schedule-to-close timeouts.
    // TODO: Clarify if there are other conditions where the activity can end up in timed out status.
    ACTIVITY_EXECUTION_STATUS_TIMED_OUT = 8;
}

message ActivityState {
    // The type of the activity, a string that maps to a registered activity on a worker.
    temporal.api.common.v1.ActivityType activity_type = 1;

    // Current activity options. May be different from the one used to start the activity.
    temporal.api.activity.v1.ActivityOptions activity_options = 2;

    // All of the possible activity statuses (covers both the public ActivityExecutionStatus and PendingActivityState).
    // TODO: consider moving this into ActivityAttemptState and renaming that message. This could save mutating two
    // components on each attempt transition.
    ActivityExecutionStatus status = 3;

    // Time the activity was originally scheduled via a StartActivityExecution request.
    google.protobuf.Timestamp scheduled_time = 4;

    // Priority metadata. (TODO: why isn't this part of ActivityOptions?)
    temporal.api.common.v1.Priority priority = 5;

    ActivityRequestData request_data = 6;

    oneof outcome {
        // The result if the activity completed successfully.
        temporal.api.common.v1.Payloads result = 7;
        // The failure if the activity completed unsuccessfully.
        temporal.api.failure.v1.Failure failure = 8;
    }
}

message ActivityRequestData {
    // Serialized activity input, passed as arguments to the activity function.
    temporal.api.common.v1.Payloads input = 1;
    temporal.api.common.v1.Header header = 2;

    // Metadata for use by user interfaces to display the fixed as-of-start summary and details of the activity.
    temporal.api.sdk.v1.UserMetadata user_metadata = 3;
}
