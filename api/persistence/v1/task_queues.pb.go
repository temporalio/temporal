// Code generated by protoc-gen-go. DO NOT EDIT.
// plugins:
// 	protoc-gen-go
// 	protoc
// source: temporal/server/api/persistence/v1/task_queues.proto

package persistence

import (
	reflect "reflect"
	"strconv"
	sync "sync"
	unsafe "unsafe"

	v13 "go.temporal.io/api/deployment/v1"
	v11 "go.temporal.io/api/taskqueue/v1"
	v1 "go.temporal.io/server/api/clock/v1"
	v12 "go.temporal.io/server/api/deployment/v1"
	v14 "go.temporal.io/server/api/enums/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type BuildId_State int32

const (
	STATE_UNSPECIFIED BuildId_State = 0
	STATE_ACTIVE      BuildId_State = 1
	STATE_DELETED     BuildId_State = 2
)

// Enum value maps for BuildId_State.
var (
	BuildId_State_name = map[int32]string{
		0: "STATE_UNSPECIFIED",
		1: "STATE_ACTIVE",
		2: "STATE_DELETED",
	}
	BuildId_State_value = map[string]int32{
		"STATE_UNSPECIFIED": 0,
		"STATE_ACTIVE":      1,
		"STATE_DELETED":     2,
	}
)

func (x BuildId_State) Enum() *BuildId_State {
	p := new(BuildId_State)
	*p = x
	return p
}

func (x BuildId_State) String() string {
	switch x {
	case STATE_UNSPECIFIED:
		return "StateUnspecified"
	case STATE_ACTIVE:
		return "StateActive"
	case STATE_DELETED:
		return "StateDeleted"
	default:
		return strconv.Itoa(int(x))
	}

}

func (BuildId_State) Descriptor() protoreflect.EnumDescriptor {
	return file_temporal_server_api_persistence_v1_task_queues_proto_enumTypes[0].Descriptor()
}

func (BuildId_State) Type() protoreflect.EnumType {
	return &file_temporal_server_api_persistence_v1_task_queues_proto_enumTypes[0]
}

func (x BuildId_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BuildId_State.Descriptor instead.
func (BuildId_State) EnumDescriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_task_queues_proto_rawDescGZIP(), []int{0, 0}
}

// BuildId is an identifier with a timestamped status used to identify workers for task queue versioning purposes.
type BuildId struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Id    string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	State BuildId_State          `protobuf:"varint,2,opt,name=state,proto3,enum=temporal.server.api.persistence.v1.BuildId_State" json:"state,omitempty"`
	// HLC timestamp representing when the state was updated or the when build ID was originally inserted.
	// (-- api-linter: core::0142::time-field-type=disabled
	//
	//	aip.dev/not-precedent: Using HLC instead of wall clock. --)
	StateUpdateTimestamp *v1.HybridLogicalClock `protobuf:"bytes,3,opt,name=state_update_timestamp,json=stateUpdateTimestamp,proto3" json:"state_update_timestamp,omitempty"`
	// HLC timestamp representing when this build ID was last made default in its version set.
	// (-- api-linter: core::0142::time-field-type=disabled
	//
	//	aip.dev/not-precedent: Using HLC instead of wall clock. --)
	BecameDefaultTimestamp *v1.HybridLogicalClock `protobuf:"bytes,4,opt,name=became_default_timestamp,json=becameDefaultTimestamp,proto3" json:"became_default_timestamp,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *BuildId) Reset() {
	*x = BuildId{}
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildId) ProtoMessage() {}

func (x *BuildId) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildId.ProtoReflect.Descriptor instead.
func (*BuildId) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_task_queues_proto_rawDescGZIP(), []int{0}
}

func (x *BuildId) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *BuildId) GetState() BuildId_State {
	if x != nil {
		return x.State
	}
	return STATE_UNSPECIFIED
}

func (x *BuildId) GetStateUpdateTimestamp() *v1.HybridLogicalClock {
	if x != nil {
		return x.StateUpdateTimestamp
	}
	return nil
}

func (x *BuildId) GetBecameDefaultTimestamp() *v1.HybridLogicalClock {
	if x != nil {
		return x.BecameDefaultTimestamp
	}
	return nil
}

// An internal representation of temporal.api.taskqueue.v1.CompatibleVersionSet
type CompatibleVersionSet struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Set IDs are used internally by matching.
	// A set typically has one set ID and extra care is taken to enforce this.
	// In some situations, including:
	//   - Replication race between task queue user data and history events
	//   - Replication split-brain + later merge
	//   - Delayed user data propagation between partitions
	//   - Cross-task-queue activities/child workflows/CAN where the user has not set up parallel
	//     versioning data
	//
	// we have to guess the set id for a build ID. If that happens, and then the build ID is
	// discovered to be in a different set, then the sets will be merged and both (or more)
	// build ids will be preserved, so that we don't lose tasks.
	// The first set id is considered the "primary", and the others are "demoted". Once a build
	// id is demoted, it cannot be made the primary again.
	SetIds []string `protobuf:"bytes,1,rep,name=set_ids,json=setIds,proto3" json:"set_ids,omitempty"`
	// All the compatible versions, unordered except for the last element, which is considered the set "default".
	BuildIds []*BuildId `protobuf:"bytes,2,rep,name=build_ids,json=buildIds,proto3" json:"build_ids,omitempty"`
	// HLC timestamp representing when this set was last made the default for the queue.
	// (-- api-linter: core::0142::time-field-type=disabled
	//
	//	aip.dev/not-precedent: Using HLC instead of wall clock. --)
	BecameDefaultTimestamp *v1.HybridLogicalClock `protobuf:"bytes,4,opt,name=became_default_timestamp,json=becameDefaultTimestamp,proto3" json:"became_default_timestamp,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *CompatibleVersionSet) Reset() {
	*x = CompatibleVersionSet{}
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompatibleVersionSet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompatibleVersionSet) ProtoMessage() {}

func (x *CompatibleVersionSet) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompatibleVersionSet.ProtoReflect.Descriptor instead.
func (*CompatibleVersionSet) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_task_queues_proto_rawDescGZIP(), []int{1}
}

func (x *CompatibleVersionSet) GetSetIds() []string {
	if x != nil {
		return x.SetIds
	}
	return nil
}

func (x *CompatibleVersionSet) GetBuildIds() []*BuildId {
	if x != nil {
		return x.BuildIds
	}
	return nil
}

func (x *CompatibleVersionSet) GetBecameDefaultTimestamp() *v1.HybridLogicalClock {
	if x != nil {
		return x.BecameDefaultTimestamp
	}
	return nil
}

type AssignmentRule struct {
	state protoimpl.MessageState     `protogen:"open.v1"`
	Rule  *v11.BuildIdAssignmentRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
	// (-- api-linter: core::0142::time-field-type=disabled
	//
	//	aip.dev/not-precedent: Using HLC instead of wall clock. --)
	CreateTimestamp *v1.HybridLogicalClock `protobuf:"bytes,2,opt,name=create_timestamp,json=createTimestamp,proto3" json:"create_timestamp,omitempty"`
	//	when delete_timestamp is present the rule should be treated as deleted
	//
	// (-- api-linter: core::0142::time-field-type=disabled
	//
	//	aip.dev/not-precedent: Using HLC instead of wall clock. --)
	DeleteTimestamp *v1.HybridLogicalClock `protobuf:"bytes,3,opt,name=delete_timestamp,json=deleteTimestamp,proto3" json:"delete_timestamp,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *AssignmentRule) Reset() {
	*x = AssignmentRule{}
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AssignmentRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AssignmentRule) ProtoMessage() {}

func (x *AssignmentRule) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AssignmentRule.ProtoReflect.Descriptor instead.
func (*AssignmentRule) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_task_queues_proto_rawDescGZIP(), []int{2}
}

func (x *AssignmentRule) GetRule() *v11.BuildIdAssignmentRule {
	if x != nil {
		return x.Rule
	}
	return nil
}

func (x *AssignmentRule) GetCreateTimestamp() *v1.HybridLogicalClock {
	if x != nil {
		return x.CreateTimestamp
	}
	return nil
}

func (x *AssignmentRule) GetDeleteTimestamp() *v1.HybridLogicalClock {
	if x != nil {
		return x.DeleteTimestamp
	}
	return nil
}

type RedirectRule struct {
	state protoimpl.MessageState             `protogen:"open.v1"`
	Rule  *v11.CompatibleBuildIdRedirectRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
	// (-- api-linter: core::0142::time-field-type=disabled
	//
	//	aip.dev/not-precedent: Using HLC instead of wall clock. --)
	CreateTimestamp *v1.HybridLogicalClock `protobuf:"bytes,2,opt,name=create_timestamp,json=createTimestamp,proto3" json:"create_timestamp,omitempty"`
	//	when delete_timestamp is present the rule should be treated as deleted
	//
	// (-- api-linter: core::0142::time-field-type=disabled
	//
	//	aip.dev/not-precedent: Using HLC instead of wall clock. --)
	DeleteTimestamp *v1.HybridLogicalClock `protobuf:"bytes,3,opt,name=delete_timestamp,json=deleteTimestamp,proto3" json:"delete_timestamp,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *RedirectRule) Reset() {
	*x = RedirectRule{}
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedirectRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedirectRule) ProtoMessage() {}

func (x *RedirectRule) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedirectRule.ProtoReflect.Descriptor instead.
func (*RedirectRule) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_task_queues_proto_rawDescGZIP(), []int{3}
}

func (x *RedirectRule) GetRule() *v11.CompatibleBuildIdRedirectRule {
	if x != nil {
		return x.Rule
	}
	return nil
}

func (x *RedirectRule) GetCreateTimestamp() *v1.HybridLogicalClock {
	if x != nil {
		return x.CreateTimestamp
	}
	return nil
}

func (x *RedirectRule) GetDeleteTimestamp() *v1.HybridLogicalClock {
	if x != nil {
		return x.DeleteTimestamp
	}
	return nil
}

// Holds all the data related to worker versioning for a task queue.
// Backwards-incompatible changes cannot be made, as this would make existing stored data unreadable.
type VersioningData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// All the incompatible version sets, unordered except for the last element, which is considered the set "default".
	VersionSets []*CompatibleVersionSet `protobuf:"bytes,1,rep,name=version_sets,json=versionSets,proto3" json:"version_sets,omitempty"`
	// Ordered list of assignment rules. Also contains recently-deleted rules.
	AssignmentRules []*AssignmentRule `protobuf:"bytes,2,rep,name=assignment_rules,json=assignmentRules,proto3" json:"assignment_rules,omitempty"`
	// Unordered list of redirect rules. Also contains recently-deleted rules.
	RedirectRules []*RedirectRule `protobuf:"bytes,3,rep,name=redirect_rules,json=redirectRules,proto3" json:"redirect_rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VersioningData) Reset() {
	*x = VersioningData{}
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VersioningData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersioningData) ProtoMessage() {}

func (x *VersioningData) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersioningData.ProtoReflect.Descriptor instead.
func (*VersioningData) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_task_queues_proto_rawDescGZIP(), []int{4}
}

func (x *VersioningData) GetVersionSets() []*CompatibleVersionSet {
	if x != nil {
		return x.VersionSets
	}
	return nil
}

func (x *VersioningData) GetAssignmentRules() []*AssignmentRule {
	if x != nil {
		return x.AssignmentRules
	}
	return nil
}

func (x *VersioningData) GetRedirectRules() []*RedirectRule {
	if x != nil {
		return x.RedirectRules
	}
	return nil
}

type DeploymentData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Set of worker deployment versions that this task queue belongs to.
	// Current Version is defined implicitly as the version with `current_since_time!=nil` and the most
	// recent `routing_update_time`.
	// Ramping Version is defined implicitly as the version with `ramping_since_time!=nil` and the most
	// recent `routing_update_time`.
	// The Ramping Version receives a share of unversioned/unpinned tasks according to its
	// `ramp_percentage`. If there is no Ramping Version, all the unversioned/unpinned tasks are
	// routed to the Current Version. If there is no Current Version, any poller with UNVERSIONED
	// (or unspecified) WorkflowVersioningMode will receive the tasks.
	// Remove after `AsyncSetCurrentAndRamping` workflow version is irreversibly enabled.
	//
	// Deprecated: Marked as deprecated in temporal/server/api/persistence/v1/task_queues.proto.
	Versions []*v12.DeploymentVersionData `protobuf:"bytes,2,rep,name=versions,proto3" json:"versions,omitempty"`
	// Present if the task queue's ramping version is unversioned.
	// Remove after `AsyncSetCurrentAndRamping` workflow version is irreversibly enabled.
	//
	// Deprecated: Marked as deprecated in temporal/server/api/persistence/v1/task_queues.proto.
	UnversionedRampData *v12.DeploymentVersionData `protobuf:"bytes,3,opt,name=unversioned_ramp_data,json=unversionedRampData,proto3" json:"unversioned_ramp_data,omitempty"`
	// Routing and version membership data for all worker deployments that this task queue belongs to.
	// Key is the deployment name.
	DeploymentsData map[string]*WorkerDeploymentData `protobuf:"bytes,4,rep,name=deployments_data,json=deploymentsData,proto3" json:"deployments_data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DeploymentData) Reset() {
	*x = DeploymentData{}
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeploymentData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeploymentData) ProtoMessage() {}

func (x *DeploymentData) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeploymentData.ProtoReflect.Descriptor instead.
func (*DeploymentData) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_task_queues_proto_rawDescGZIP(), []int{5}
}

// Deprecated: Marked as deprecated in temporal/server/api/persistence/v1/task_queues.proto.
func (x *DeploymentData) GetVersions() []*v12.DeploymentVersionData {
	if x != nil {
		return x.Versions
	}
	return nil
}

// Deprecated: Marked as deprecated in temporal/server/api/persistence/v1/task_queues.proto.
func (x *DeploymentData) GetUnversionedRampData() *v12.DeploymentVersionData {
	if x != nil {
		return x.UnversionedRampData
	}
	return nil
}

func (x *DeploymentData) GetDeploymentsData() map[string]*WorkerDeploymentData {
	if x != nil {
		return x.DeploymentsData
	}
	return nil
}

// Routing config and version membership data for a given worker deployment that a TQ should know.
type WorkerDeploymentData struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RoutingConfig *v13.RoutingConfig     `protobuf:"bytes,1,opt,name=routing_config,json=routingConfig,proto3" json:"routing_config,omitempty"`
	// This map tracks the membership of the task queue in the deployment versions. A version is
	// present here iff the task queue has ever been polled from the version.
	// Key is the build id.
	Versions      map[string]*v12.WorkerDeploymentVersionData `protobuf:"bytes,2,rep,name=versions,proto3" json:"versions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkerDeploymentData) Reset() {
	*x = WorkerDeploymentData{}
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkerDeploymentData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkerDeploymentData) ProtoMessage() {}

func (x *WorkerDeploymentData) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkerDeploymentData.ProtoReflect.Descriptor instead.
func (*WorkerDeploymentData) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_task_queues_proto_rawDescGZIP(), []int{6}
}

func (x *WorkerDeploymentData) GetRoutingConfig() *v13.RoutingConfig {
	if x != nil {
		return x.RoutingConfig
	}
	return nil
}

func (x *WorkerDeploymentData) GetVersions() map[string]*v12.WorkerDeploymentVersionData {
	if x != nil {
		return x.Versions
	}
	return nil
}

// Container for all persistent user data that varies per task queue type within a family.
type TaskQueueTypeUserData struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	DeploymentData *DeploymentData        `protobuf:"bytes,1,opt,name=deployment_data,json=deploymentData,proto3" json:"deployment_data,omitempty"`
	Config         *v11.TaskQueueConfig   `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	FairnessState  v14.FairnessState      `protobuf:"varint,3,opt,name=fairness_state,json=fairnessState,proto3,enum=temporal.server.api.enums.v1.FairnessState" json:"fairness_state,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TaskQueueTypeUserData) Reset() {
	*x = TaskQueueTypeUserData{}
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskQueueTypeUserData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskQueueTypeUserData) ProtoMessage() {}

func (x *TaskQueueTypeUserData) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskQueueTypeUserData.ProtoReflect.Descriptor instead.
func (*TaskQueueTypeUserData) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_task_queues_proto_rawDescGZIP(), []int{7}
}

func (x *TaskQueueTypeUserData) GetDeploymentData() *DeploymentData {
	if x != nil {
		return x.DeploymentData
	}
	return nil
}

func (x *TaskQueueTypeUserData) GetConfig() *v11.TaskQueueConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *TaskQueueTypeUserData) GetFairnessState() v14.FairnessState {
	if x != nil {
		return x.FairnessState
	}
	return v14.FairnessState(0)
}

// Container for all persistent user provided data for a task queue family.
// "Task queue" as a named concept here is a task queue family, i.e. the set of task queues
// that share a name, at most one of each type (workflow, activity, etc.).
// This data must all fit in a single DB column and is kept cached in-memory, take extra care to ensure data added here
// has reasonable size limits imposed on it.
type TaskQueueUserData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The last recorded cluster-local Hybrid Logical Clock timestamp for _this_ task queue family.
	// Updated whenever user data is directly updated due to a user action but not when applying replication events.
	// The clock is referenced when new timestamps are generated to ensure it produces monotonically increasing
	// timestamps.
	Clock          *v1.HybridLogicalClock `protobuf:"bytes,1,opt,name=clock,proto3" json:"clock,omitempty"`
	VersioningData *VersioningData        `protobuf:"bytes,2,opt,name=versioning_data,json=versioningData,proto3" json:"versioning_data,omitempty"`
	// Map from task queue type (workflow, activity, nexus) to per-type data.
	PerType       map[int32]*TaskQueueTypeUserData `protobuf:"bytes,3,rep,name=per_type,json=perType,proto3" json:"per_type,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaskQueueUserData) Reset() {
	*x = TaskQueueUserData{}
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaskQueueUserData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskQueueUserData) ProtoMessage() {}

func (x *TaskQueueUserData) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskQueueUserData.ProtoReflect.Descriptor instead.
func (*TaskQueueUserData) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_task_queues_proto_rawDescGZIP(), []int{8}
}

func (x *TaskQueueUserData) GetClock() *v1.HybridLogicalClock {
	if x != nil {
		return x.Clock
	}
	return nil
}

func (x *TaskQueueUserData) GetVersioningData() *VersioningData {
	if x != nil {
		return x.VersioningData
	}
	return nil
}

func (x *TaskQueueUserData) GetPerType() map[int32]*TaskQueueTypeUserData {
	if x != nil {
		return x.PerType
	}
	return nil
}

// Simple wrapper that includes a TaskQueueUserData and its storage version.
type VersionedTaskQueueUserData struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Data          *TaskQueueUserData     `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Version       int64                  `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VersionedTaskQueueUserData) Reset() {
	*x = VersionedTaskQueueUserData{}
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VersionedTaskQueueUserData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersionedTaskQueueUserData) ProtoMessage() {}

func (x *VersionedTaskQueueUserData) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersionedTaskQueueUserData.ProtoReflect.Descriptor instead.
func (*VersionedTaskQueueUserData) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_task_queues_proto_rawDescGZIP(), []int{9}
}

func (x *VersionedTaskQueueUserData) GetData() *TaskQueueUserData {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *VersionedTaskQueueUserData) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

var File_temporal_server_api_persistence_v1_task_queues_proto protoreflect.FileDescriptor

const file_temporal_server_api_persistence_v1_task_queues_proto_rawDesc = "" +
	"\n" +
	"4temporal/server/api/persistence/v1/task_queues.proto\x12\"temporal.server.api.persistence.v1\x1a(temporal/api/deployment/v1/message.proto\x1a'temporal/api/taskqueue/v1/message.proto\x1a*temporal/server/api/clock/v1/message.proto\x1a/temporal/server/api/deployment/v1/message.proto\x1a1temporal/server/api/enums/v1/fairness_state.proto\"\xfb\x02\n" +
	"\aBuildId\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12G\n" +
	"\x05state\x18\x02 \x01(\x0e21.temporal.server.api.persistence.v1.BuildId.StateR\x05state\x12f\n" +
	"\x16state_update_timestamp\x18\x03 \x01(\v20.temporal.server.api.clock.v1.HybridLogicalClockR\x14stateUpdateTimestamp\x12j\n" +
	"\x18became_default_timestamp\x18\x04 \x01(\v20.temporal.server.api.clock.v1.HybridLogicalClockR\x16becameDefaultTimestamp\"C\n" +
	"\x05State\x12\x15\n" +
	"\x11STATE_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fSTATE_ACTIVE\x10\x01\x12\x11\n" +
	"\rSTATE_DELETED\x10\x02\"\xe5\x01\n" +
	"\x14CompatibleVersionSet\x12\x17\n" +
	"\aset_ids\x18\x01 \x03(\tR\x06setIds\x12H\n" +
	"\tbuild_ids\x18\x02 \x03(\v2+.temporal.server.api.persistence.v1.BuildIdR\bbuildIds\x12j\n" +
	"\x18became_default_timestamp\x18\x04 \x01(\v20.temporal.server.api.clock.v1.HybridLogicalClockR\x16becameDefaultTimestamp\"\x90\x02\n" +
	"\x0eAssignmentRule\x12D\n" +
	"\x04rule\x18\x01 \x01(\v20.temporal.api.taskqueue.v1.BuildIdAssignmentRuleR\x04rule\x12[\n" +
	"\x10create_timestamp\x18\x02 \x01(\v20.temporal.server.api.clock.v1.HybridLogicalClockR\x0fcreateTimestamp\x12[\n" +
	"\x10delete_timestamp\x18\x03 \x01(\v20.temporal.server.api.clock.v1.HybridLogicalClockR\x0fdeleteTimestamp\"\x96\x02\n" +
	"\fRedirectRule\x12L\n" +
	"\x04rule\x18\x01 \x01(\v28.temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRuleR\x04rule\x12[\n" +
	"\x10create_timestamp\x18\x02 \x01(\v20.temporal.server.api.clock.v1.HybridLogicalClockR\x0fcreateTimestamp\x12[\n" +
	"\x10delete_timestamp\x18\x03 \x01(\v20.temporal.server.api.clock.v1.HybridLogicalClockR\x0fdeleteTimestamp\"\xa5\x02\n" +
	"\x0eVersioningData\x12[\n" +
	"\fversion_sets\x18\x01 \x03(\v28.temporal.server.api.persistence.v1.CompatibleVersionSetR\vversionSets\x12]\n" +
	"\x10assignment_rules\x18\x02 \x03(\v22.temporal.server.api.persistence.v1.AssignmentRuleR\x0fassignmentRules\x12W\n" +
	"\x0eredirect_rules\x18\x03 \x03(\v20.temporal.server.api.persistence.v1.RedirectRuleR\rredirectRules\"\xd4\x03\n" +
	"\x0eDeploymentData\x12X\n" +
	"\bversions\x18\x02 \x03(\v28.temporal.server.api.deployment.v1.DeploymentVersionDataB\x02\x18\x01R\bversions\x12p\n" +
	"\x15unversioned_ramp_data\x18\x03 \x01(\v28.temporal.server.api.deployment.v1.DeploymentVersionDataB\x02\x18\x01R\x13unversionedRampData\x12r\n" +
	"\x10deployments_data\x18\x04 \x03(\v2G.temporal.server.api.persistence.v1.DeploymentData.DeploymentsDataEntryR\x0fdeploymentsData\x1a|\n" +
	"\x14DeploymentsDataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12N\n" +
	"\x05value\x18\x02 \x01(\v28.temporal.server.api.persistence.v1.WorkerDeploymentDataR\x05value:\x028\x01J\x04\b\x01\x10\x02\"\xc9\x02\n" +
	"\x14WorkerDeploymentData\x12P\n" +
	"\x0erouting_config\x18\x01 \x01(\v2).temporal.api.deployment.v1.RoutingConfigR\rroutingConfig\x12b\n" +
	"\bversions\x18\x02 \x03(\v2F.temporal.server.api.persistence.v1.WorkerDeploymentData.VersionsEntryR\bversions\x1a{\n" +
	"\rVersionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12T\n" +
	"\x05value\x18\x02 \x01(\v2>.temporal.server.api.deployment.v1.WorkerDeploymentVersionDataR\x05value:\x028\x01\"\x8c\x02\n" +
	"\x15TaskQueueTypeUserData\x12[\n" +
	"\x0fdeployment_data\x18\x01 \x01(\v22.temporal.server.api.persistence.v1.DeploymentDataR\x0edeploymentData\x12B\n" +
	"\x06config\x18\x02 \x01(\v2*.temporal.api.taskqueue.v1.TaskQueueConfigR\x06config\x12R\n" +
	"\x0efairness_state\x18\x03 \x01(\x0e2+.temporal.server.api.enums.v1.FairnessStateR\rfairnessState\"\x8e\x03\n" +
	"\x11TaskQueueUserData\x12F\n" +
	"\x05clock\x18\x01 \x01(\v20.temporal.server.api.clock.v1.HybridLogicalClockR\x05clock\x12[\n" +
	"\x0fversioning_data\x18\x02 \x01(\v22.temporal.server.api.persistence.v1.VersioningDataR\x0eversioningData\x12]\n" +
	"\bper_type\x18\x03 \x03(\v2B.temporal.server.api.persistence.v1.TaskQueueUserData.PerTypeEntryR\aperType\x1au\n" +
	"\fPerTypeEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x12O\n" +
	"\x05value\x18\x02 \x01(\v29.temporal.server.api.persistence.v1.TaskQueueTypeUserDataR\x05value:\x028\x01\"\x81\x01\n" +
	"\x1aVersionedTaskQueueUserData\x12I\n" +
	"\x04data\x18\x01 \x01(\v25.temporal.server.api.persistence.v1.TaskQueueUserDataR\x04data\x12\x18\n" +
	"\aversion\x18\x02 \x01(\x03R\aversionB6Z4go.temporal.io/server/api/persistence/v1;persistenceb\x06proto3"

var (
	file_temporal_server_api_persistence_v1_task_queues_proto_rawDescOnce sync.Once
	file_temporal_server_api_persistence_v1_task_queues_proto_rawDescData []byte
)

func file_temporal_server_api_persistence_v1_task_queues_proto_rawDescGZIP() []byte {
	file_temporal_server_api_persistence_v1_task_queues_proto_rawDescOnce.Do(func() {
		file_temporal_server_api_persistence_v1_task_queues_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_temporal_server_api_persistence_v1_task_queues_proto_rawDesc), len(file_temporal_server_api_persistence_v1_task_queues_proto_rawDesc)))
	})
	return file_temporal_server_api_persistence_v1_task_queues_proto_rawDescData
}

var file_temporal_server_api_persistence_v1_task_queues_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_temporal_server_api_persistence_v1_task_queues_proto_goTypes = []any{
	(BuildId_State)(0),                        // 0: temporal.server.api.persistence.v1.BuildId.State
	(*BuildId)(nil),                           // 1: temporal.server.api.persistence.v1.BuildId
	(*CompatibleVersionSet)(nil),              // 2: temporal.server.api.persistence.v1.CompatibleVersionSet
	(*AssignmentRule)(nil),                    // 3: temporal.server.api.persistence.v1.AssignmentRule
	(*RedirectRule)(nil),                      // 4: temporal.server.api.persistence.v1.RedirectRule
	(*VersioningData)(nil),                    // 5: temporal.server.api.persistence.v1.VersioningData
	(*DeploymentData)(nil),                    // 6: temporal.server.api.persistence.v1.DeploymentData
	(*WorkerDeploymentData)(nil),              // 7: temporal.server.api.persistence.v1.WorkerDeploymentData
	(*TaskQueueTypeUserData)(nil),             // 8: temporal.server.api.persistence.v1.TaskQueueTypeUserData
	(*TaskQueueUserData)(nil),                 // 9: temporal.server.api.persistence.v1.TaskQueueUserData
	(*VersionedTaskQueueUserData)(nil),        // 10: temporal.server.api.persistence.v1.VersionedTaskQueueUserData
	nil,                                       // 11: temporal.server.api.persistence.v1.DeploymentData.DeploymentsDataEntry
	nil,                                       // 12: temporal.server.api.persistence.v1.WorkerDeploymentData.VersionsEntry
	nil,                                       // 13: temporal.server.api.persistence.v1.TaskQueueUserData.PerTypeEntry
	(*v1.HybridLogicalClock)(nil),             // 14: temporal.server.api.clock.v1.HybridLogicalClock
	(*v11.BuildIdAssignmentRule)(nil),         // 15: temporal.api.taskqueue.v1.BuildIdAssignmentRule
	(*v11.CompatibleBuildIdRedirectRule)(nil), // 16: temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule
	(*v12.DeploymentVersionData)(nil),         // 17: temporal.server.api.deployment.v1.DeploymentVersionData
	(*v13.RoutingConfig)(nil),                 // 18: temporal.api.deployment.v1.RoutingConfig
	(*v11.TaskQueueConfig)(nil),               // 19: temporal.api.taskqueue.v1.TaskQueueConfig
	(v14.FairnessState)(0),                    // 20: temporal.server.api.enums.v1.FairnessState
	(*v12.WorkerDeploymentVersionData)(nil),   // 21: temporal.server.api.deployment.v1.WorkerDeploymentVersionData
}
var file_temporal_server_api_persistence_v1_task_queues_proto_depIdxs = []int32{
	0,  // 0: temporal.server.api.persistence.v1.BuildId.state:type_name -> temporal.server.api.persistence.v1.BuildId.State
	14, // 1: temporal.server.api.persistence.v1.BuildId.state_update_timestamp:type_name -> temporal.server.api.clock.v1.HybridLogicalClock
	14, // 2: temporal.server.api.persistence.v1.BuildId.became_default_timestamp:type_name -> temporal.server.api.clock.v1.HybridLogicalClock
	1,  // 3: temporal.server.api.persistence.v1.CompatibleVersionSet.build_ids:type_name -> temporal.server.api.persistence.v1.BuildId
	14, // 4: temporal.server.api.persistence.v1.CompatibleVersionSet.became_default_timestamp:type_name -> temporal.server.api.clock.v1.HybridLogicalClock
	15, // 5: temporal.server.api.persistence.v1.AssignmentRule.rule:type_name -> temporal.api.taskqueue.v1.BuildIdAssignmentRule
	14, // 6: temporal.server.api.persistence.v1.AssignmentRule.create_timestamp:type_name -> temporal.server.api.clock.v1.HybridLogicalClock
	14, // 7: temporal.server.api.persistence.v1.AssignmentRule.delete_timestamp:type_name -> temporal.server.api.clock.v1.HybridLogicalClock
	16, // 8: temporal.server.api.persistence.v1.RedirectRule.rule:type_name -> temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule
	14, // 9: temporal.server.api.persistence.v1.RedirectRule.create_timestamp:type_name -> temporal.server.api.clock.v1.HybridLogicalClock
	14, // 10: temporal.server.api.persistence.v1.RedirectRule.delete_timestamp:type_name -> temporal.server.api.clock.v1.HybridLogicalClock
	2,  // 11: temporal.server.api.persistence.v1.VersioningData.version_sets:type_name -> temporal.server.api.persistence.v1.CompatibleVersionSet
	3,  // 12: temporal.server.api.persistence.v1.VersioningData.assignment_rules:type_name -> temporal.server.api.persistence.v1.AssignmentRule
	4,  // 13: temporal.server.api.persistence.v1.VersioningData.redirect_rules:type_name -> temporal.server.api.persistence.v1.RedirectRule
	17, // 14: temporal.server.api.persistence.v1.DeploymentData.versions:type_name -> temporal.server.api.deployment.v1.DeploymentVersionData
	17, // 15: temporal.server.api.persistence.v1.DeploymentData.unversioned_ramp_data:type_name -> temporal.server.api.deployment.v1.DeploymentVersionData
	11, // 16: temporal.server.api.persistence.v1.DeploymentData.deployments_data:type_name -> temporal.server.api.persistence.v1.DeploymentData.DeploymentsDataEntry
	18, // 17: temporal.server.api.persistence.v1.WorkerDeploymentData.routing_config:type_name -> temporal.api.deployment.v1.RoutingConfig
	12, // 18: temporal.server.api.persistence.v1.WorkerDeploymentData.versions:type_name -> temporal.server.api.persistence.v1.WorkerDeploymentData.VersionsEntry
	6,  // 19: temporal.server.api.persistence.v1.TaskQueueTypeUserData.deployment_data:type_name -> temporal.server.api.persistence.v1.DeploymentData
	19, // 20: temporal.server.api.persistence.v1.TaskQueueTypeUserData.config:type_name -> temporal.api.taskqueue.v1.TaskQueueConfig
	20, // 21: temporal.server.api.persistence.v1.TaskQueueTypeUserData.fairness_state:type_name -> temporal.server.api.enums.v1.FairnessState
	14, // 22: temporal.server.api.persistence.v1.TaskQueueUserData.clock:type_name -> temporal.server.api.clock.v1.HybridLogicalClock
	5,  // 23: temporal.server.api.persistence.v1.TaskQueueUserData.versioning_data:type_name -> temporal.server.api.persistence.v1.VersioningData
	13, // 24: temporal.server.api.persistence.v1.TaskQueueUserData.per_type:type_name -> temporal.server.api.persistence.v1.TaskQueueUserData.PerTypeEntry
	9,  // 25: temporal.server.api.persistence.v1.VersionedTaskQueueUserData.data:type_name -> temporal.server.api.persistence.v1.TaskQueueUserData
	7,  // 26: temporal.server.api.persistence.v1.DeploymentData.DeploymentsDataEntry.value:type_name -> temporal.server.api.persistence.v1.WorkerDeploymentData
	21, // 27: temporal.server.api.persistence.v1.WorkerDeploymentData.VersionsEntry.value:type_name -> temporal.server.api.deployment.v1.WorkerDeploymentVersionData
	8,  // 28: temporal.server.api.persistence.v1.TaskQueueUserData.PerTypeEntry.value:type_name -> temporal.server.api.persistence.v1.TaskQueueTypeUserData
	29, // [29:29] is the sub-list for method output_type
	29, // [29:29] is the sub-list for method input_type
	29, // [29:29] is the sub-list for extension type_name
	29, // [29:29] is the sub-list for extension extendee
	0,  // [0:29] is the sub-list for field type_name
}

func init() { file_temporal_server_api_persistence_v1_task_queues_proto_init() }
func file_temporal_server_api_persistence_v1_task_queues_proto_init() {
	if File_temporal_server_api_persistence_v1_task_queues_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_temporal_server_api_persistence_v1_task_queues_proto_rawDesc), len(file_temporal_server_api_persistence_v1_task_queues_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   13,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_temporal_server_api_persistence_v1_task_queues_proto_goTypes,
		DependencyIndexes: file_temporal_server_api_persistence_v1_task_queues_proto_depIdxs,
		EnumInfos:         file_temporal_server_api_persistence_v1_task_queues_proto_enumTypes,
		MessageInfos:      file_temporal_server_api_persistence_v1_task_queues_proto_msgTypes,
	}.Build()
	File_temporal_server_api_persistence_v1_task_queues_proto = out.File
	file_temporal_server_api_persistence_v1_task_queues_proto_goTypes = nil
	file_temporal_server_api_persistence_v1_task_queues_proto_depIdxs = nil
}
