// The MIT License
//
// Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.
//
// Copyright (c) 2020 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: temporal/server/api/persistence/v1/task_queues.proto

package persistence

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"

	proto "github.com/gogo/protobuf/proto"
	v1 "go.temporal.io/server/api/clock/v1"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BuildId_State int32

const (
	STATE_UNSPECIFIED BuildId_State = 0
	STATE_ACTIVE      BuildId_State = 1
	STATE_DELETED     BuildId_State = 2
)

var BuildId_State_name = map[int32]string{
	0: "StateUnspecified",
	1: "StateActive",
	2: "StateDeleted",
}

var BuildId_State_value = map[string]int32{
	"StateUnspecified": 0,
	"StateActive":      1,
	"StateDeleted":     2,
}

func (BuildId_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0cb9a0f256d1327d, []int{0, 0}
}

// BuildId is an identifier with a timestamped status used to identify workers for task queue versioning purposes.
type BuildId struct {
	Id    string        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	State BuildId_State `protobuf:"varint,2,opt,name=state,proto3,enum=temporal.server.api.persistence.v1.BuildId_State" json:"state,omitempty"`
	// HLC timestamp representing when the state was updated or the when build ID was originally inserted.
	// (-- api-linter: core::0142::time-field-type=disabled
	//     aip.dev/not-precedent: Using HLC instead of wall clock. --)
	StateUpdateTimestamp *v1.HybridLogicalClock `protobuf:"bytes,3,opt,name=state_update_timestamp,json=stateUpdateTimestamp,proto3" json:"state_update_timestamp,omitempty"`
	// HLC timestamp representing when this build id was last made default in its version set.
	// (-- api-linter: core::0142::time-field-type=disabled
	//     aip.dev/not-precedent: Using HLC instead of wall clock. --)
	BecameDefaultTimestamp *v1.HybridLogicalClock `protobuf:"bytes,4,opt,name=became_default_timestamp,json=becameDefaultTimestamp,proto3" json:"became_default_timestamp,omitempty"`
}

func (m *BuildId) Reset()      { *m = BuildId{} }
func (*BuildId) ProtoMessage() {}
func (*BuildId) Descriptor() ([]byte, []int) {
	return fileDescriptor_0cb9a0f256d1327d, []int{0}
}
func (m *BuildId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildId.Merge(m, src)
}
func (m *BuildId) XXX_Size() int {
	return m.Size()
}
func (m *BuildId) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildId.DiscardUnknown(m)
}

var xxx_messageInfo_BuildId proto.InternalMessageInfo

func (m *BuildId) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BuildId) GetState() BuildId_State {
	if m != nil {
		return m.State
	}
	return STATE_UNSPECIFIED
}

func (m *BuildId) GetStateUpdateTimestamp() *v1.HybridLogicalClock {
	if m != nil {
		return m.StateUpdateTimestamp
	}
	return nil
}

func (m *BuildId) GetBecameDefaultTimestamp() *v1.HybridLogicalClock {
	if m != nil {
		return m.BecameDefaultTimestamp
	}
	return nil
}

// An internal represenation of temporal.api.taskqueue.v1.CompatibleVersionSet
type CompatibleVersionSet struct {
	// Set IDs are used internally by matching.
	// A set typically has one set ID and extra care is taken to enforce this.
	// In split brain scenarios, there may be conflicting concurrent writes to the task queue versioning data, in which
	// case a set might end up with more than one ID.
	SetIds []string `protobuf:"bytes,1,rep,name=set_ids,json=setIds,proto3" json:"set_ids,omitempty"`
	// All the compatible versions, unordered except for the last element, which is considered the set "default".
	BuildIds []*BuildId `protobuf:"bytes,2,rep,name=build_ids,json=buildIds,proto3" json:"build_ids,omitempty"`
	// HLC timestamp representing when this set was last made the default for the queue.
	// (-- api-linter: core::0142::time-field-type=disabled
	//     aip.dev/not-precedent: Using HLC instead of wall clock. --)
	BecameDefaultTimestamp *v1.HybridLogicalClock `protobuf:"bytes,4,opt,name=became_default_timestamp,json=becameDefaultTimestamp,proto3" json:"became_default_timestamp,omitempty"`
}

func (m *CompatibleVersionSet) Reset()      { *m = CompatibleVersionSet{} }
func (*CompatibleVersionSet) ProtoMessage() {}
func (*CompatibleVersionSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0cb9a0f256d1327d, []int{1}
}
func (m *CompatibleVersionSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompatibleVersionSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompatibleVersionSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompatibleVersionSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompatibleVersionSet.Merge(m, src)
}
func (m *CompatibleVersionSet) XXX_Size() int {
	return m.Size()
}
func (m *CompatibleVersionSet) XXX_DiscardUnknown() {
	xxx_messageInfo_CompatibleVersionSet.DiscardUnknown(m)
}

var xxx_messageInfo_CompatibleVersionSet proto.InternalMessageInfo

func (m *CompatibleVersionSet) GetSetIds() []string {
	if m != nil {
		return m.SetIds
	}
	return nil
}

func (m *CompatibleVersionSet) GetBuildIds() []*BuildId {
	if m != nil {
		return m.BuildIds
	}
	return nil
}

func (m *CompatibleVersionSet) GetBecameDefaultTimestamp() *v1.HybridLogicalClock {
	if m != nil {
		return m.BecameDefaultTimestamp
	}
	return nil
}

// Holds all the data related to worker versioning for a task queue.
// Backwards-incompatible changes cannot be made, as this would make existing stored data unreadable.
type VersioningData struct {
	// All the incompatible version sets, unordered except for the last element, which is considered the set "default".
	VersionSets []*CompatibleVersionSet `protobuf:"bytes,1,rep,name=version_sets,json=versionSets,proto3" json:"version_sets,omitempty"`
}

func (m *VersioningData) Reset()      { *m = VersioningData{} }
func (*VersioningData) ProtoMessage() {}
func (*VersioningData) Descriptor() ([]byte, []int) {
	return fileDescriptor_0cb9a0f256d1327d, []int{2}
}
func (m *VersioningData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersioningData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersioningData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersioningData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersioningData.Merge(m, src)
}
func (m *VersioningData) XXX_Size() int {
	return m.Size()
}
func (m *VersioningData) XXX_DiscardUnknown() {
	xxx_messageInfo_VersioningData.DiscardUnknown(m)
}

var xxx_messageInfo_VersioningData proto.InternalMessageInfo

func (m *VersioningData) GetVersionSets() []*CompatibleVersionSet {
	if m != nil {
		return m.VersionSets
	}
	return nil
}

// Container for all persistent user provided data for a task queue.
// Task queue as a named concept here is close to how users interpret them, rather than relating to some specific type
// (workflow vs activity, etc) and thus, as a consequence, any data that applies to a specific type (say, activity rate
// limiting) should be defined as such within this structure.
// This data must all fit in a single DB column and is kept cached in-memory, take extra care to ensure data added here
// has reasonable size limits imposed on it.
type TaskQueueUserData struct {
	// The last recorded cluster-local Hybrid Logical Clock timestamp for _this_ task queue.
	// Updated whenever user data is directly updated due to a user action but not when applying replication events.
	// The clock is referenced when new timestamps are generated to ensure it produces monotonically increasing
	// timestamps.
	Clock          *v1.HybridLogicalClock `protobuf:"bytes,1,opt,name=clock,proto3" json:"clock,omitempty"`
	VersioningData *VersioningData        `protobuf:"bytes,2,opt,name=versioning_data,json=versioningData,proto3" json:"versioning_data,omitempty"`
}

func (m *TaskQueueUserData) Reset()      { *m = TaskQueueUserData{} }
func (*TaskQueueUserData) ProtoMessage() {}
func (*TaskQueueUserData) Descriptor() ([]byte, []int) {
	return fileDescriptor_0cb9a0f256d1327d, []int{3}
}
func (m *TaskQueueUserData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskQueueUserData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskQueueUserData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskQueueUserData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskQueueUserData.Merge(m, src)
}
func (m *TaskQueueUserData) XXX_Size() int {
	return m.Size()
}
func (m *TaskQueueUserData) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskQueueUserData.DiscardUnknown(m)
}

var xxx_messageInfo_TaskQueueUserData proto.InternalMessageInfo

func (m *TaskQueueUserData) GetClock() *v1.HybridLogicalClock {
	if m != nil {
		return m.Clock
	}
	return nil
}

func (m *TaskQueueUserData) GetVersioningData() *VersioningData {
	if m != nil {
		return m.VersioningData
	}
	return nil
}

// Simple wrapper that includes a TaskQueueUserData and its storage version.
type VersionedTaskQueueUserData struct {
	Data    *TaskQueueUserData `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Version int64              `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *VersionedTaskQueueUserData) Reset()      { *m = VersionedTaskQueueUserData{} }
func (*VersionedTaskQueueUserData) ProtoMessage() {}
func (*VersionedTaskQueueUserData) Descriptor() ([]byte, []int) {
	return fileDescriptor_0cb9a0f256d1327d, []int{4}
}
func (m *VersionedTaskQueueUserData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionedTaskQueueUserData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionedTaskQueueUserData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionedTaskQueueUserData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionedTaskQueueUserData.Merge(m, src)
}
func (m *VersionedTaskQueueUserData) XXX_Size() int {
	return m.Size()
}
func (m *VersionedTaskQueueUserData) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionedTaskQueueUserData.DiscardUnknown(m)
}

var xxx_messageInfo_VersionedTaskQueueUserData proto.InternalMessageInfo

func (m *VersionedTaskQueueUserData) GetData() *TaskQueueUserData {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *VersionedTaskQueueUserData) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func init() {
	proto.RegisterEnum("temporal.server.api.persistence.v1.BuildId_State", BuildId_State_name, BuildId_State_value)
	proto.RegisterType((*BuildId)(nil), "temporal.server.api.persistence.v1.BuildId")
	proto.RegisterType((*CompatibleVersionSet)(nil), "temporal.server.api.persistence.v1.CompatibleVersionSet")
	proto.RegisterType((*VersioningData)(nil), "temporal.server.api.persistence.v1.VersioningData")
	proto.RegisterType((*TaskQueueUserData)(nil), "temporal.server.api.persistence.v1.TaskQueueUserData")
	proto.RegisterType((*VersionedTaskQueueUserData)(nil), "temporal.server.api.persistence.v1.VersionedTaskQueueUserData")
}

func init() {
	proto.RegisterFile("temporal/server/api/persistence/v1/task_queues.proto", fileDescriptor_0cb9a0f256d1327d)
}

var fileDescriptor_0cb9a0f256d1327d = []byte{
	// 589 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x94, 0x4f, 0x6f, 0xd3, 0x3e,
	0x18, 0xc7, 0xe3, 0x74, 0x7f, 0x7e, 0x73, 0xf7, 0x2b, 0x9d, 0x35, 0x46, 0xb4, 0x83, 0x55, 0xe5,
	0x54, 0x81, 0x94, 0xb2, 0x30, 0x24, 0x24, 0x4e, 0x5b, 0x9b, 0xb1, 0x48, 0x13, 0x82, 0x34, 0xdb,
	0x81, 0x1d, 0x22, 0xa7, 0xf1, 0x2a, 0x6f, 0xc9, 0x12, 0x62, 0x37, 0x12, 0x37, 0x78, 0x07, 0xbc,
	0x0c, 0x5e, 0x02, 0x2f, 0x81, 0xe3, 0x8e, 0x3b, 0xb2, 0x4c, 0x48, 0x1c, 0x77, 0xe7, 0x82, 0x62,
	0x77, 0x63, 0xd3, 0x8a, 0x28, 0x3b, 0x70, 0xaa, 0xfd, 0x34, 0xdf, 0xcf, 0xf7, 0xf9, 0x3e, 0x89,
	0x0d, 0xd7, 0x05, 0x4d, 0xb2, 0x34, 0x27, 0x71, 0x87, 0xd3, 0xbc, 0xa0, 0x79, 0x87, 0x64, 0xac,
	0x93, 0xd1, 0x9c, 0x33, 0x2e, 0xe8, 0xf1, 0x80, 0x76, 0x8a, 0xb5, 0x8e, 0x20, 0xfc, 0x28, 0x78,
	0x3b, 0xa2, 0x23, 0xca, 0xad, 0x2c, 0x4f, 0x45, 0x8a, 0xcc, 0x4b, 0x95, 0xa5, 0x54, 0x16, 0xc9,
	0x98, 0x75, 0x4d, 0x65, 0x15, 0x6b, 0xab, 0x0f, 0x27, 0x91, 0x07, 0x71, 0x3a, 0x38, 0xaa, 0x98,
	0x09, 0xe5, 0x9c, 0x0c, 0xa9, 0xe2, 0x99, 0x3f, 0x74, 0x38, 0xbf, 0x39, 0x62, 0x71, 0xe4, 0x46,
	0xa8, 0x01, 0x75, 0x16, 0x19, 0xa0, 0x05, 0xda, 0x0b, 0x9e, 0xce, 0x22, 0xf4, 0x02, 0xce, 0x72,
	0x41, 0x04, 0x35, 0xf4, 0x16, 0x68, 0x37, 0xec, 0x35, 0xeb, 0xcf, 0xde, 0xd6, 0x98, 0x65, 0xf5,
	0x2b, 0xa1, 0xa7, 0xf4, 0xe8, 0x00, 0xae, 0xc8, 0x45, 0x30, 0xca, 0xa2, 0xea, 0x47, 0xb0, 0x84,
	0x72, 0x41, 0x92, 0xcc, 0xa8, 0xb5, 0x40, 0xbb, 0x6e, 0x3f, 0x9e, 0x48, 0x96, 0x1d, 0x57, 0xcc,
	0xed, 0x77, 0x61, 0xce, 0xa2, 0x9d, 0x74, 0xc8, 0x06, 0x24, 0xee, 0x56, 0x55, 0x6f, 0x59, 0xf2,
	0x76, 0x25, 0xce, 0xbf, 0xa4, 0xa1, 0x43, 0x68, 0x84, 0x74, 0x40, 0x12, 0x1a, 0x44, 0xf4, 0x80,
	0x8c, 0x62, 0x71, 0xcd, 0x69, 0xe6, 0x8e, 0x4e, 0x2b, 0x8a, 0xd8, 0x53, 0xc0, 0x2b, 0x2f, 0xb3,
	0x0b, 0x67, 0x65, 0x46, 0x74, 0x1f, 0x2e, 0xf5, 0xfd, 0x0d, 0xdf, 0x09, 0x76, 0x5f, 0xf6, 0x5f,
	0x39, 0x5d, 0x77, 0xcb, 0x75, 0x7a, 0x4d, 0x0d, 0x35, 0xe1, 0xa2, 0x2a, 0x6f, 0x74, 0x7d, 0x77,
	0xcf, 0x69, 0x02, 0xb4, 0x04, 0xff, 0x57, 0x95, 0x9e, 0xb3, 0xe3, 0xf8, 0x4e, 0xaf, 0xa9, 0x9b,
	0xdf, 0x00, 0x5c, 0xee, 0xa6, 0x49, 0x46, 0x04, 0x0b, 0x63, 0xba, 0x57, 0x8d, 0x32, 0x3d, 0xee,
	0x53, 0x81, 0x1e, 0xc0, 0x79, 0x4e, 0x45, 0xc0, 0x22, 0x6e, 0x80, 0x56, 0xad, 0xbd, 0xe0, 0xcd,
	0x71, 0x2a, 0xdc, 0x88, 0xa3, 0x6d, 0xb8, 0x10, 0x56, 0x23, 0x96, 0x7f, 0xe9, 0xad, 0x5a, 0xbb,
	0x6e, 0x3f, 0xfa, 0x8b, 0xf7, 0xe2, 0xfd, 0x17, 0xaa, 0x05, 0xff, 0xa7, 0xc3, 0x4a, 0x60, 0x63,
	0x1c, 0x8e, 0x1d, 0x0f, 0x7b, 0x44, 0x10, 0xb4, 0x0f, 0x17, 0x0b, 0x55, 0x09, 0x38, 0x15, 0x2a,
	0x65, 0xdd, 0x7e, 0x36, 0x4d, 0x94, 0x49, 0x03, 0xf3, 0xea, 0xc5, 0xd5, 0x9a, 0x9b, 0x9f, 0x01,
	0x5c, 0xf2, 0x09, 0x3f, 0x7a, 0x5d, 0x9d, 0x9c, 0x5d, 0x4e, 0x73, 0x69, 0xb9, 0x05, 0x67, 0x65,
	0xef, 0xf2, 0x0b, 0xbf, 0x4b, 0x3a, 0x25, 0x47, 0xfb, 0xf0, 0x5e, 0x71, 0x15, 0x26, 0x88, 0x88,
	0x20, 0xf2, 0x80, 0xd4, 0x6d, 0x7b, 0x9a, 0xee, 0x6f, 0xce, 0xc1, 0x6b, 0x14, 0x37, 0xf6, 0xe6,
	0x07, 0x00, 0x57, 0xc7, 0x8f, 0xd0, 0xe8, 0x76, 0x06, 0x17, 0xce, 0x48, 0x43, 0x15, 0xe1, 0xe9,
	0x34, 0x86, 0xb7, 0x20, 0x9e, 0x44, 0x20, 0x03, 0xce, 0x8f, 0xbd, 0x65, 0xfb, 0x35, 0xef, 0x72,
	0xbb, 0x79, 0x78, 0x72, 0x86, 0xb5, 0xd3, 0x33, 0xac, 0x5d, 0x9c, 0x61, 0xf0, 0xbe, 0xc4, 0xe0,
	0x53, 0x89, 0xc1, 0x97, 0x12, 0x83, 0x93, 0x12, 0x83, 0xaf, 0x25, 0x06, 0xdf, 0x4b, 0xac, 0x5d,
	0x94, 0x18, 0x7c, 0x3c, 0xc7, 0xda, 0xc9, 0x39, 0xd6, 0x4e, 0xcf, 0xb1, 0xf6, 0x66, 0x7d, 0x98,
	0xfe, 0x6a, 0x87, 0xa5, 0xbf, 0xbf, 0xd5, 0x9e, 0x5f, 0xdb, 0x86, 0x73, 0xf2, 0x1a, 0x7a, 0xf2,
	0x33, 0x00, 0x00, 0xff, 0xff, 0xce, 0x85, 0xd4, 0xc4, 0x0e, 0x05, 0x00, 0x00,
}

func (x BuildId_State) String() string {
	s, ok := BuildId_State_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *BuildId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BuildId)
	if !ok {
		that2, ok := that.(BuildId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if !this.StateUpdateTimestamp.Equal(that1.StateUpdateTimestamp) {
		return false
	}
	if !this.BecameDefaultTimestamp.Equal(that1.BecameDefaultTimestamp) {
		return false
	}
	return true
}
func (this *CompatibleVersionSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CompatibleVersionSet)
	if !ok {
		that2, ok := that.(CompatibleVersionSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SetIds) != len(that1.SetIds) {
		return false
	}
	for i := range this.SetIds {
		if this.SetIds[i] != that1.SetIds[i] {
			return false
		}
	}
	if len(this.BuildIds) != len(that1.BuildIds) {
		return false
	}
	for i := range this.BuildIds {
		if !this.BuildIds[i].Equal(that1.BuildIds[i]) {
			return false
		}
	}
	if !this.BecameDefaultTimestamp.Equal(that1.BecameDefaultTimestamp) {
		return false
	}
	return true
}
func (this *VersioningData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VersioningData)
	if !ok {
		that2, ok := that.(VersioningData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VersionSets) != len(that1.VersionSets) {
		return false
	}
	for i := range this.VersionSets {
		if !this.VersionSets[i].Equal(that1.VersionSets[i]) {
			return false
		}
	}
	return true
}
func (this *TaskQueueUserData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskQueueUserData)
	if !ok {
		that2, ok := that.(TaskQueueUserData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Clock.Equal(that1.Clock) {
		return false
	}
	if !this.VersioningData.Equal(that1.VersioningData) {
		return false
	}
	return true
}
func (this *VersionedTaskQueueUserData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VersionedTaskQueueUserData)
	if !ok {
		that2, ok := that.(VersionedTaskQueueUserData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Data.Equal(that1.Data) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}
func (this *BuildId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&persistence.BuildId{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.StateUpdateTimestamp != nil {
		s = append(s, "StateUpdateTimestamp: "+fmt.Sprintf("%#v", this.StateUpdateTimestamp)+",\n")
	}
	if this.BecameDefaultTimestamp != nil {
		s = append(s, "BecameDefaultTimestamp: "+fmt.Sprintf("%#v", this.BecameDefaultTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CompatibleVersionSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&persistence.CompatibleVersionSet{")
	s = append(s, "SetIds: "+fmt.Sprintf("%#v", this.SetIds)+",\n")
	if this.BuildIds != nil {
		s = append(s, "BuildIds: "+fmt.Sprintf("%#v", this.BuildIds)+",\n")
	}
	if this.BecameDefaultTimestamp != nil {
		s = append(s, "BecameDefaultTimestamp: "+fmt.Sprintf("%#v", this.BecameDefaultTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VersioningData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&persistence.VersioningData{")
	if this.VersionSets != nil {
		s = append(s, "VersionSets: "+fmt.Sprintf("%#v", this.VersionSets)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TaskQueueUserData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&persistence.TaskQueueUserData{")
	if this.Clock != nil {
		s = append(s, "Clock: "+fmt.Sprintf("%#v", this.Clock)+",\n")
	}
	if this.VersioningData != nil {
		s = append(s, "VersioningData: "+fmt.Sprintf("%#v", this.VersioningData)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VersionedTaskQueueUserData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&persistence.VersionedTaskQueueUserData{")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTaskQueues(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *BuildId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BecameDefaultTimestamp != nil {
		{
			size, err := m.BecameDefaultTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTaskQueues(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.StateUpdateTimestamp != nil {
		{
			size, err := m.StateUpdateTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTaskQueues(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintTaskQueues(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTaskQueues(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CompatibleVersionSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompatibleVersionSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompatibleVersionSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BecameDefaultTimestamp != nil {
		{
			size, err := m.BecameDefaultTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTaskQueues(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.BuildIds) > 0 {
		for iNdEx := len(m.BuildIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BuildIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTaskQueues(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SetIds) > 0 {
		for iNdEx := len(m.SetIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SetIds[iNdEx])
			copy(dAtA[i:], m.SetIds[iNdEx])
			i = encodeVarintTaskQueues(dAtA, i, uint64(len(m.SetIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VersioningData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersioningData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersioningData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VersionSets) > 0 {
		for iNdEx := len(m.VersionSets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VersionSets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTaskQueues(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TaskQueueUserData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskQueueUserData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskQueueUserData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VersioningData != nil {
		{
			size, err := m.VersioningData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTaskQueues(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Clock != nil {
		{
			size, err := m.Clock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTaskQueues(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VersionedTaskQueueUserData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionedTaskQueueUserData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersionedTaskQueueUserData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintTaskQueues(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTaskQueues(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTaskQueues(dAtA []byte, offset int, v uint64) int {
	offset -= sovTaskQueues(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BuildId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTaskQueues(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTaskQueues(uint64(m.State))
	}
	if m.StateUpdateTimestamp != nil {
		l = m.StateUpdateTimestamp.Size()
		n += 1 + l + sovTaskQueues(uint64(l))
	}
	if m.BecameDefaultTimestamp != nil {
		l = m.BecameDefaultTimestamp.Size()
		n += 1 + l + sovTaskQueues(uint64(l))
	}
	return n
}

func (m *CompatibleVersionSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SetIds) > 0 {
		for _, s := range m.SetIds {
			l = len(s)
			n += 1 + l + sovTaskQueues(uint64(l))
		}
	}
	if len(m.BuildIds) > 0 {
		for _, e := range m.BuildIds {
			l = e.Size()
			n += 1 + l + sovTaskQueues(uint64(l))
		}
	}
	if m.BecameDefaultTimestamp != nil {
		l = m.BecameDefaultTimestamp.Size()
		n += 1 + l + sovTaskQueues(uint64(l))
	}
	return n
}

func (m *VersioningData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VersionSets) > 0 {
		for _, e := range m.VersionSets {
			l = e.Size()
			n += 1 + l + sovTaskQueues(uint64(l))
		}
	}
	return n
}

func (m *TaskQueueUserData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Clock != nil {
		l = m.Clock.Size()
		n += 1 + l + sovTaskQueues(uint64(l))
	}
	if m.VersioningData != nil {
		l = m.VersioningData.Size()
		n += 1 + l + sovTaskQueues(uint64(l))
	}
	return n
}

func (m *VersionedTaskQueueUserData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovTaskQueues(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovTaskQueues(uint64(m.Version))
	}
	return n
}

func sovTaskQueues(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTaskQueues(x uint64) (n int) {
	return sovTaskQueues(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *BuildId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BuildId{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`StateUpdateTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.StateUpdateTimestamp), "HybridLogicalClock", "v1.HybridLogicalClock", 1) + `,`,
		`BecameDefaultTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.BecameDefaultTimestamp), "HybridLogicalClock", "v1.HybridLogicalClock", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CompatibleVersionSet) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForBuildIds := "[]*BuildId{"
	for _, f := range this.BuildIds {
		repeatedStringForBuildIds += strings.Replace(f.String(), "BuildId", "BuildId", 1) + ","
	}
	repeatedStringForBuildIds += "}"
	s := strings.Join([]string{`&CompatibleVersionSet{`,
		`SetIds:` + fmt.Sprintf("%v", this.SetIds) + `,`,
		`BuildIds:` + repeatedStringForBuildIds + `,`,
		`BecameDefaultTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.BecameDefaultTimestamp), "HybridLogicalClock", "v1.HybridLogicalClock", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VersioningData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVersionSets := "[]*CompatibleVersionSet{"
	for _, f := range this.VersionSets {
		repeatedStringForVersionSets += strings.Replace(f.String(), "CompatibleVersionSet", "CompatibleVersionSet", 1) + ","
	}
	repeatedStringForVersionSets += "}"
	s := strings.Join([]string{`&VersioningData{`,
		`VersionSets:` + repeatedStringForVersionSets + `,`,
		`}`,
	}, "")
	return s
}
func (this *TaskQueueUserData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TaskQueueUserData{`,
		`Clock:` + strings.Replace(fmt.Sprintf("%v", this.Clock), "HybridLogicalClock", "v1.HybridLogicalClock", 1) + `,`,
		`VersioningData:` + strings.Replace(this.VersioningData.String(), "VersioningData", "VersioningData", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VersionedTaskQueueUserData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VersionedTaskQueueUserData{`,
		`Data:` + strings.Replace(this.Data.String(), "TaskQueueUserData", "TaskQueueUserData", 1) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTaskQueues(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *BuildId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskQueues
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskQueues
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTaskQueues
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskQueues
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= BuildId_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateUpdateTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskQueues
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskQueues
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StateUpdateTimestamp == nil {
				m.StateUpdateTimestamp = &v1.HybridLogicalClock{}
			}
			if err := m.StateUpdateTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BecameDefaultTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskQueues
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskQueues
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BecameDefaultTimestamp == nil {
				m.BecameDefaultTimestamp = &v1.HybridLogicalClock{}
			}
			if err := m.BecameDefaultTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskQueues(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompatibleVersionSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskQueues
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompatibleVersionSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompatibleVersionSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskQueues
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTaskQueues
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetIds = append(m.SetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskQueues
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskQueues
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildIds = append(m.BuildIds, &BuildId{})
			if err := m.BuildIds[len(m.BuildIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BecameDefaultTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskQueues
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskQueues
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BecameDefaultTimestamp == nil {
				m.BecameDefaultTimestamp = &v1.HybridLogicalClock{}
			}
			if err := m.BecameDefaultTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskQueues(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersioningData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskQueues
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersioningData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersioningData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskQueues
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskQueues
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionSets = append(m.VersionSets, &CompatibleVersionSet{})
			if err := m.VersionSets[len(m.VersionSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskQueues(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskQueueUserData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskQueues
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskQueueUserData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskQueueUserData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskQueues
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskQueues
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Clock == nil {
				m.Clock = &v1.HybridLogicalClock{}
			}
			if err := m.Clock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersioningData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskQueues
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskQueues
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VersioningData == nil {
				m.VersioningData = &VersioningData{}
			}
			if err := m.VersioningData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskQueues(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionedTaskQueueUserData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskQueues
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionedTaskQueueUserData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionedTaskQueueUserData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskQueues
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskQueues
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &TaskQueueUserData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskQueues
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTaskQueues(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTaskQueues
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTaskQueues(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTaskQueues
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTaskQueues
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTaskQueues
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTaskQueues
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTaskQueues
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTaskQueues
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTaskQueues        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTaskQueues          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTaskQueues = fmt.Errorf("proto: unexpected end of group")
)
