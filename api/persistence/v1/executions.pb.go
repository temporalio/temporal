// The MIT License
//
// Copyright (c) 2020 Temporal Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Code generated by protoc-gen-go. DO NOT EDIT.
// plugins:
// 	protoc-gen-go
// 	protoc
// source: temporal/server/api/persistence/v1/executions.proto

package persistence

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	v12 "go.temporal.io/api/common/v1"
	v18 "go.temporal.io/api/deployment/v1"
	v16 "go.temporal.io/api/enums/v1"
	v17 "go.temporal.io/api/failure/v1"
	v19 "go.temporal.io/api/history/v1"
	v11 "go.temporal.io/api/workflow/v1"
	v14 "go.temporal.io/server/api/clock/v1"
	v1 "go.temporal.io/server/api/enums/v1"
	v13 "go.temporal.io/server/api/history/v1"
	v15 "go.temporal.io/server/api/workflow/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// shard column
type ShardInfo struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	ShardId int32                  `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	RangeId int64                  `protobuf:"varint,2,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	Owner   string                 `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: "since" is needed here. --)
	StolenSinceRenew       int32                  `protobuf:"varint,6,opt,name=stolen_since_renew,json=stolenSinceRenew,proto3" json:"stolen_since_renew,omitempty"`
	UpdateTime             *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	ReplicationDlqAckLevel map[string]int64       `protobuf:"bytes,13,rep,name=replication_dlq_ack_level,json=replicationDlqAckLevel,proto3" json:"replication_dlq_ack_level,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	QueueStates            map[int32]*QueueState  `protobuf:"bytes,17,rep,name=queue_states,json=queueStates,proto3" json:"queue_states,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *ShardInfo) Reset() {
	*x = ShardInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShardInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShardInfo) ProtoMessage() {}

func (x *ShardInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShardInfo.ProtoReflect.Descriptor instead.
func (*ShardInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{0}
}

func (x *ShardInfo) GetShardId() int32 {
	if x != nil {
		return x.ShardId
	}
	return 0
}

func (x *ShardInfo) GetRangeId() int64 {
	if x != nil {
		return x.RangeId
	}
	return 0
}

func (x *ShardInfo) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *ShardInfo) GetStolenSinceRenew() int32 {
	if x != nil {
		return x.StolenSinceRenew
	}
	return 0
}

func (x *ShardInfo) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

func (x *ShardInfo) GetReplicationDlqAckLevel() map[string]int64 {
	if x != nil {
		return x.ReplicationDlqAckLevel
	}
	return nil
}

func (x *ShardInfo) GetQueueStates() map[int32]*QueueState {
	if x != nil {
		return x.QueueStates
	}
	return nil
}

// execution column
type WorkflowExecutionInfo struct {
	state                                   protoimpl.MessageState `protogen:"open.v1"`
	NamespaceId                             string                 `protobuf:"bytes,1,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	WorkflowId                              string                 `protobuf:"bytes,2,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	ParentNamespaceId                       string                 `protobuf:"bytes,3,opt,name=parent_namespace_id,json=parentNamespaceId,proto3" json:"parent_namespace_id,omitempty"`
	ParentWorkflowId                        string                 `protobuf:"bytes,4,opt,name=parent_workflow_id,json=parentWorkflowId,proto3" json:"parent_workflow_id,omitempty"`
	ParentRunId                             string                 `protobuf:"bytes,5,opt,name=parent_run_id,json=parentRunId,proto3" json:"parent_run_id,omitempty"`
	ParentInitiatedId                       int64                  `protobuf:"varint,6,opt,name=parent_initiated_id,json=parentInitiatedId,proto3" json:"parent_initiated_id,omitempty"`
	CompletionEventBatchId                  int64                  `protobuf:"varint,7,opt,name=completion_event_batch_id,json=completionEventBatchId,proto3" json:"completion_event_batch_id,omitempty"`
	TaskQueue                               string                 `protobuf:"bytes,9,opt,name=task_queue,json=taskQueue,proto3" json:"task_queue,omitempty"`
	WorkflowTypeName                        string                 `protobuf:"bytes,10,opt,name=workflow_type_name,json=workflowTypeName,proto3" json:"workflow_type_name,omitempty"`
	WorkflowExecutionTimeout                *durationpb.Duration   `protobuf:"bytes,11,opt,name=workflow_execution_timeout,json=workflowExecutionTimeout,proto3" json:"workflow_execution_timeout,omitempty"`
	WorkflowRunTimeout                      *durationpb.Duration   `protobuf:"bytes,12,opt,name=workflow_run_timeout,json=workflowRunTimeout,proto3" json:"workflow_run_timeout,omitempty"`
	DefaultWorkflowTaskTimeout              *durationpb.Duration   `protobuf:"bytes,13,opt,name=default_workflow_task_timeout,json=defaultWorkflowTaskTimeout,proto3" json:"default_workflow_task_timeout,omitempty"`
	LastEventTaskId                         int64                  `protobuf:"varint,17,opt,name=last_event_task_id,json=lastEventTaskId,proto3" json:"last_event_task_id,omitempty"`
	LastFirstEventId                        int64                  `protobuf:"varint,18,opt,name=last_first_event_id,json=lastFirstEventId,proto3" json:"last_first_event_id,omitempty"`
	LastCompletedWorkflowTaskStartedEventId int64                  `protobuf:"varint,19,opt,name=last_completed_workflow_task_started_event_id,json=lastCompletedWorkflowTaskStartedEventId,proto3" json:"last_completed_workflow_task_started_event_id,omitempty"`
	// Deprecated. use `WorkflowExecutionState.start_time`
	StartTime      *timestamppb.Timestamp `protobuf:"bytes,20,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	LastUpdateTime *timestamppb.Timestamp `protobuf:"bytes,21,opt,name=last_update_time,json=lastUpdateTime,proto3" json:"last_update_time,omitempty"`
	// Workflow task fields.
	WorkflowTaskVersion               int64                  `protobuf:"varint,22,opt,name=workflow_task_version,json=workflowTaskVersion,proto3" json:"workflow_task_version,omitempty"`
	WorkflowTaskScheduledEventId      int64                  `protobuf:"varint,23,opt,name=workflow_task_scheduled_event_id,json=workflowTaskScheduledEventId,proto3" json:"workflow_task_scheduled_event_id,omitempty"`
	WorkflowTaskStartedEventId        int64                  `protobuf:"varint,24,opt,name=workflow_task_started_event_id,json=workflowTaskStartedEventId,proto3" json:"workflow_task_started_event_id,omitempty"`
	WorkflowTaskTimeout               *durationpb.Duration   `protobuf:"bytes,25,opt,name=workflow_task_timeout,json=workflowTaskTimeout,proto3" json:"workflow_task_timeout,omitempty"`
	WorkflowTaskAttempt               int32                  `protobuf:"varint,26,opt,name=workflow_task_attempt,json=workflowTaskAttempt,proto3" json:"workflow_task_attempt,omitempty"`
	WorkflowTaskStartedTime           *timestamppb.Timestamp `protobuf:"bytes,27,opt,name=workflow_task_started_time,json=workflowTaskStartedTime,proto3" json:"workflow_task_started_time,omitempty"`
	WorkflowTaskScheduledTime         *timestamppb.Timestamp `protobuf:"bytes,28,opt,name=workflow_task_scheduled_time,json=workflowTaskScheduledTime,proto3" json:"workflow_task_scheduled_time,omitempty"`
	WorkflowTaskOriginalScheduledTime *timestamppb.Timestamp `protobuf:"bytes,30,opt,name=workflow_task_original_scheduled_time,json=workflowTaskOriginalScheduledTime,proto3" json:"workflow_task_original_scheduled_time,omitempty"`
	WorkflowTaskRequestId             string                 `protobuf:"bytes,31,opt,name=workflow_task_request_id,json=workflowTaskRequestId,proto3" json:"workflow_task_request_id,omitempty"`
	WorkflowTaskType                  v1.WorkflowTaskType    `protobuf:"varint,68,opt,name=workflow_task_type,json=workflowTaskType,proto3,enum=temporal.server.api.enums.v1.WorkflowTaskType" json:"workflow_task_type,omitempty"`
	WorkflowTaskSuggestContinueAsNew  bool                   `protobuf:"varint,69,opt,name=workflow_task_suggest_continue_as_new,json=workflowTaskSuggestContinueAsNew,proto3" json:"workflow_task_suggest_continue_as_new,omitempty"`
	WorkflowTaskHistorySizeBytes      int64                  `protobuf:"varint,70,opt,name=workflow_task_history_size_bytes,json=workflowTaskHistorySizeBytes,proto3" json:"workflow_task_history_size_bytes,omitempty"`
	// tracks the started build ID for transient/speculative WFT. This info is used for two purposes:
	// - verify WFT completes by the same Build ID that started in the latest attempt
	// - when persisting transient/speculative WFT, the right Build ID is used in the WFT started event
	// Deprecated. Clean up with versioning-2. [cleanup-old-wv]
	WorkflowTaskBuildId string `protobuf:"bytes,88,opt,name=workflow_task_build_id,json=workflowTaskBuildId,proto3" json:"workflow_task_build_id,omitempty"`
	// tracks the started build ID redirect counter for transient/speculative WFT. This info is to
	// ensure the right redirect counter is used in the WFT started event created later
	// for a transient/speculative WFT.
	// Deprecated. Clean up with versioning-2. [cleanup-old-wv]
	WorkflowTaskBuildIdRedirectCounter int64  `protobuf:"varint,89,opt,name=workflow_task_build_id_redirect_counter,json=workflowTaskBuildIdRedirectCounter,proto3" json:"workflow_task_build_id_redirect_counter,omitempty"`
	CancelRequested                    bool   `protobuf:"varint,29,opt,name=cancel_requested,json=cancelRequested,proto3" json:"cancel_requested,omitempty"`
	CancelRequestId                    string `protobuf:"bytes,32,opt,name=cancel_request_id,json=cancelRequestId,proto3" json:"cancel_request_id,omitempty"`
	StickyTaskQueue                    string `protobuf:"bytes,33,opt,name=sticky_task_queue,json=stickyTaskQueue,proto3" json:"sticky_task_queue,omitempty"`
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: "to" is used to indicate interval. --)
	StickyScheduleToStartTimeout    *durationpb.Duration    `protobuf:"bytes,34,opt,name=sticky_schedule_to_start_timeout,json=stickyScheduleToStartTimeout,proto3" json:"sticky_schedule_to_start_timeout,omitempty"`
	Attempt                         int32                   `protobuf:"varint,35,opt,name=attempt,proto3" json:"attempt,omitempty"`
	RetryInitialInterval            *durationpb.Duration    `protobuf:"bytes,36,opt,name=retry_initial_interval,json=retryInitialInterval,proto3" json:"retry_initial_interval,omitempty"`
	RetryMaximumInterval            *durationpb.Duration    `protobuf:"bytes,37,opt,name=retry_maximum_interval,json=retryMaximumInterval,proto3" json:"retry_maximum_interval,omitempty"`
	RetryMaximumAttempts            int32                   `protobuf:"varint,38,opt,name=retry_maximum_attempts,json=retryMaximumAttempts,proto3" json:"retry_maximum_attempts,omitempty"`
	RetryBackoffCoefficient         float64                 `protobuf:"fixed64,39,opt,name=retry_backoff_coefficient,json=retryBackoffCoefficient,proto3" json:"retry_backoff_coefficient,omitempty"`
	WorkflowExecutionExpirationTime *timestamppb.Timestamp  `protobuf:"bytes,40,opt,name=workflow_execution_expiration_time,json=workflowExecutionExpirationTime,proto3" json:"workflow_execution_expiration_time,omitempty"`
	RetryNonRetryableErrorTypes     []string                `protobuf:"bytes,41,rep,name=retry_non_retryable_error_types,json=retryNonRetryableErrorTypes,proto3" json:"retry_non_retryable_error_types,omitempty"`
	HasRetryPolicy                  bool                    `protobuf:"varint,42,opt,name=has_retry_policy,json=hasRetryPolicy,proto3" json:"has_retry_policy,omitempty"`
	CronSchedule                    string                  `protobuf:"bytes,43,opt,name=cron_schedule,json=cronSchedule,proto3" json:"cron_schedule,omitempty"`
	SignalCount                     int64                   `protobuf:"varint,46,opt,name=signal_count,json=signalCount,proto3" json:"signal_count,omitempty"`
	ActivityCount                   int64                   `protobuf:"varint,71,opt,name=activity_count,json=activityCount,proto3" json:"activity_count,omitempty"`
	ChildExecutionCount             int64                   `protobuf:"varint,72,opt,name=child_execution_count,json=childExecutionCount,proto3" json:"child_execution_count,omitempty"`
	UserTimerCount                  int64                   `protobuf:"varint,73,opt,name=user_timer_count,json=userTimerCount,proto3" json:"user_timer_count,omitempty"`
	RequestCancelExternalCount      int64                   `protobuf:"varint,74,opt,name=request_cancel_external_count,json=requestCancelExternalCount,proto3" json:"request_cancel_external_count,omitempty"`
	SignalExternalCount             int64                   `protobuf:"varint,75,opt,name=signal_external_count,json=signalExternalCount,proto3" json:"signal_external_count,omitempty"`
	UpdateCount                     int64                   `protobuf:"varint,77,opt,name=update_count,json=updateCount,proto3" json:"update_count,omitempty"`
	AutoResetPoints                 *v11.ResetPoints        `protobuf:"bytes,51,opt,name=auto_reset_points,json=autoResetPoints,proto3" json:"auto_reset_points,omitempty"`
	SearchAttributes                map[string]*v12.Payload `protobuf:"bytes,52,rep,name=search_attributes,json=searchAttributes,proto3" json:"search_attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Memo                            map[string]*v12.Payload `protobuf:"bytes,53,rep,name=memo,proto3" json:"memo,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	VersionHistories                *v13.VersionHistories   `protobuf:"bytes,54,opt,name=version_histories,json=versionHistories,proto3" json:"version_histories,omitempty"`
	FirstExecutionRunId             string                  `protobuf:"bytes,55,opt,name=first_execution_run_id,json=firstExecutionRunId,proto3" json:"first_execution_run_id,omitempty"`
	ExecutionStats                  *ExecutionStats         `protobuf:"bytes,56,opt,name=execution_stats,json=executionStats,proto3" json:"execution_stats,omitempty"`
	WorkflowRunExpirationTime       *timestamppb.Timestamp  `protobuf:"bytes,57,opt,name=workflow_run_expiration_time,json=workflowRunExpirationTime,proto3" json:"workflow_run_expiration_time,omitempty"`
	// Transaction Id of the first event in the last batch of events.
	LastFirstEventTxnId  int64                  `protobuf:"varint,58,opt,name=last_first_event_txn_id,json=lastFirstEventTxnId,proto3" json:"last_first_event_txn_id,omitempty"`
	StateTransitionCount int64                  `protobuf:"varint,59,opt,name=state_transition_count,json=stateTransitionCount,proto3" json:"state_transition_count,omitempty"`
	ExecutionTime        *timestamppb.Timestamp `protobuf:"bytes,60,opt,name=execution_time,json=executionTime,proto3" json:"execution_time,omitempty"`
	// If continued-as-new, or retried, or cron, holds the new run id.
	NewExecutionRunId string           `protobuf:"bytes,61,opt,name=new_execution_run_id,json=newExecutionRunId,proto3" json:"new_execution_run_id,omitempty"`
	ParentClock       *v14.VectorClock `protobuf:"bytes,62,opt,name=parent_clock,json=parentClock,proto3" json:"parent_clock,omitempty"`
	// version of child execution initiated event in parent workflow
	ParentInitiatedVersion int64 `protobuf:"varint,63,opt,name=parent_initiated_version,json=parentInitiatedVersion,proto3" json:"parent_initiated_version,omitempty"`
	// Used to check if transfer close task is processed before deleting the workflow execution.
	CloseTransferTaskId int64 `protobuf:"varint,64,opt,name=close_transfer_task_id,json=closeTransferTaskId,proto3" json:"close_transfer_task_id,omitempty"`
	// Used to check if visibility close task is processed before deleting the workflow execution.
	CloseVisibilityTaskId int64                  `protobuf:"varint,65,opt,name=close_visibility_task_id,json=closeVisibilityTaskId,proto3" json:"close_visibility_task_id,omitempty"`
	CloseTime             *timestamppb.Timestamp `protobuf:"bytes,66,opt,name=close_time,json=closeTime,proto3" json:"close_time,omitempty"`
	// Relocatable attributes are memo and search attributes. If they were removed, then they are not
	// present in the mutable state, and they should be in visibility store.
	RelocatableAttributesRemoved bool                   `protobuf:"varint,67,opt,name=relocatable_attributes_removed,json=relocatableAttributesRemoved,proto3" json:"relocatable_attributes_removed,omitempty"`
	BaseExecutionInfo            *v15.BaseExecutionInfo `protobuf:"bytes,76,opt,name=base_execution_info,json=baseExecutionInfo,proto3" json:"base_execution_info,omitempty"`
	// If using build-id based versioning: version stamp of the last worker to complete a
	// workflow tasks for this workflow.
	// Deprecated. Clean up with versioning-2. [cleanup-old-wv]
	MostRecentWorkerVersionStamp *v12.WorkerVersionStamp `protobuf:"bytes,78,opt,name=most_recent_worker_version_stamp,json=mostRecentWorkerVersionStamp,proto3" json:"most_recent_worker_version_stamp,omitempty"`
	// The currently assigned build ID for this execution. Presence of this value means worker versioning is used
	// for this execution. Assigned build ID is selected by matching based on Worker Versioning Assignment Rules
	// when the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled
	// again, the assigned build ID may change according to the latest versioning rules.
	// Assigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to
	// this execution.
	// Deprecated. Clean up with versioning-2. [cleanup-old-wv]
	AssignedBuildId string `protobuf:"bytes,85,opt,name=assigned_build_id,json=assignedBuildId,proto3" json:"assigned_build_id,omitempty"`
	// Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead
	// of using the assignment rules.
	// Deprecated. Clean up with versioning-2. [cleanup-old-wv]
	InheritedBuildId string `protobuf:"bytes,86,opt,name=inherited_build_id,json=inheritedBuildId,proto3" json:"inherited_build_id,omitempty"`
	// Tracks the number of times a redirect rule is applied to this workflow. Used to apply redirects in the right
	// order when mutable state is rebuilt from history events.
	// Deprecated. Clean up with versioning-2. [cleanup-old-wv]
	BuildIdRedirectCounter int64 `protobuf:"varint,87,opt,name=build_id_redirect_counter,json=buildIdRedirectCounter,proto3" json:"build_id_redirect_counter,omitempty"`
	// index of update IDs and pointers to associated history events.
	UpdateInfos map[string]*UpdateInfo `protobuf:"bytes,79,rep,name=update_infos,json=updateInfos,proto3" json:"update_infos,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Transition history encodes all transitions a mutable state object has gone through in a compact way.
	// Here the transition_count field of VersionedTransition represents the maximum transition count the mutable state object
	// has gone through for the corresponding namespace failover version.
	// For example, if the transition history is `[{v: 1, t: 3}, {v: 2, t: 5}]`, it means transition 1-3 have failover version 1,
	// and transition 4-5 have failover version 2.
	//
	// Each task generated by the HSM framework is imprinted with the current VersionedTransition at the end of the transaction.
	// When a task is being processed, the transition history is compared with the imprinted task information to
	// verify that a task is not referencing a stale state or that the task itself is not stale.
	// For example, with the same transition history above, task A `{v: 2, t: 4}` **is not**
	// referencing stale state because for version `2` transitions `4-5` are valid, while task B `{v: 2, t: 6}` **is**
	// referencing stale state because the transition count is out of range for version `2`.
	// Furthermore, task C `{v: 1, t: 4}` itself is stale because it is referencing an impossible state, likely due to post
	// split-brain reconciliation.
	TransitionHistory []*VersionedTransition `protobuf:"bytes,80,rep,name=transition_history,json=transitionHistory,proto3" json:"transition_history,omitempty"`
	// Map of state machine type to map of machine by ID.
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: "by" is used to clarify the keys and values. --)
	SubStateMachinesByType map[string]*StateMachineMap `protobuf:"bytes,81,rep,name=sub_state_machines_by_type,json=subStateMachinesByType,proto3" json:"sub_state_machines_by_type,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// This field is for tracking if the workflow execution timer task is created or not.
	// We don't need this field if we always create the execution timer task when the first
	// workflow in a workflow chain starts. However, this execution timer logic is later added.
	// To maintain backward compatibility, we need to track if the execution timer task is created
	// for a workflow chain since later workflows in the chain also need to create the execution
	// timer task if it is not created yet.
	// NOTE: Task status is clsuter specific information, so when replicating mutable state, this
	// field need to be sanitized.
	WorkflowExecutionTimerTaskStatus int32 `protobuf:"varint,82,opt,name=workflow_execution_timer_task_status,json=workflowExecutionTimerTaskStatus,proto3" json:"workflow_execution_timer_task_status,omitempty"`
	// The root workflow execution is defined as follows:
	// 1. A workflow without parent workflow is its own root workflow.
	// 2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
	RootWorkflowId string `protobuf:"bytes,83,opt,name=root_workflow_id,json=rootWorkflowId,proto3" json:"root_workflow_id,omitempty"`
	RootRunId      string `protobuf:"bytes,84,opt,name=root_run_id,json=rootRunId,proto3" json:"root_run_id,omitempty"`
	// Timer tasks emitted from state machines are stored in this array, grouped and sorted by their deadline. Only the
	// next state machine timer task is generated at a time per mutable state. When that task is processed it iterates
	// this array and triggers timers that are ready.
	// NOTE: Task status is cluster specific information, so when replicating mutable state, this field needs to be
	// sanitized.
	StateMachineTimers []*StateMachineTimerGroup `protobuf:"bytes,90,rep,name=state_machine_timers,json=stateMachineTimers,proto3" json:"state_machine_timers,omitempty"`
	// The shard clock's timestamp at the time the first valid task was created for this mutable state (either for a new
	// mutable state or when rebuilding from events). The field should be updated whenever we refresh tasks, marking
	// older generation tasks obsolete.
	// This field is used for task staleness checks when mutable state is rebuilt.
	// NOTE: Task status is cluster specific information, so when replicating mutable state, this field needs to be
	// sanitized.
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: Ignoring api-linter rules for clarity --)
	//
	// (-- api-linter: core::0142::time-field-type=disabled
	//
	//	aip.dev/not-precedent: This is a vector clock, not a timestamp --)
	TaskGenerationShardClockTimestamp             int64                         `protobuf:"varint,91,opt,name=task_generation_shard_clock_timestamp,json=taskGenerationShardClockTimestamp,proto3" json:"task_generation_shard_clock_timestamp,omitempty"`
	WorkflowTaskLastUpdateVersionedTransition     *VersionedTransition          `protobuf:"bytes,92,opt,name=workflow_task_last_update_versioned_transition,json=workflowTaskLastUpdateVersionedTransition,proto3" json:"workflow_task_last_update_versioned_transition,omitempty"`
	VisibilityLastUpdateVersionedTransition       *VersionedTransition          `protobuf:"bytes,93,opt,name=visibility_last_update_versioned_transition,json=visibilityLastUpdateVersionedTransition,proto3" json:"visibility_last_update_versioned_transition,omitempty"`
	SignalRequestIdsLastUpdateVersionedTransition *VersionedTransition          `protobuf:"bytes,94,opt,name=signal_request_ids_last_update_versioned_transition,json=signalRequestIdsLastUpdateVersionedTransition,proto3" json:"signal_request_ids_last_update_versioned_transition,omitempty"`
	SubStateMachineTombstoneBatches               []*StateMachineTombstoneBatch `protobuf:"bytes,95,rep,name=sub_state_machine_tombstone_batches,json=subStateMachineTombstoneBatches,proto3" json:"sub_state_machine_tombstone_batches,omitempty"`
	// The workflow has been reset.
	WorkflowWasReset bool `protobuf:"varint,96,opt,name=workflow_was_reset,json=workflowWasReset,proto3" json:"workflow_was_reset,omitempty"`
	// Reset Run ID points to the new nun when this execution is reset. If the execution is reset multiple times, it points to the latest run.
	ResetRunId string `protobuf:"bytes,97,opt,name=reset_run_id,json=resetRunId,proto3" json:"reset_run_id,omitempty"`
	// When present, it means the workflow execution is versioned, or is transitioning from
	// unversioned workers to versioned ones.
	// Note: Deployment objects inside versioning info are immutable, never change their fields.
	// (-- api-linter: core::0203::immutable=disabled
	//
	//	aip.dev/not-precedent: field_behavior annotation is not yet used in this repo --)
	VersioningInfo *v11.WorkflowExecutionVersioningInfo `protobuf:"bytes,98,opt,name=versioning_info,json=versioningInfo,proto3" json:"versioning_info,omitempty"`
	// This is the run id when the WorkflowExecutionStarted event was written.
	// A workflow reset changes the execution run_id, but preserves this field so that we have a reference to the original workflow execution that was reset.
	OriginalExecutionRunId string `protobuf:"bytes,99,opt,name=original_execution_run_id,json=originalExecutionRunId,proto3" json:"original_execution_run_id,omitempty"`
	// These two fields are to record the transition history when the transition history is cleaned up due to disabling transition history
	// Should be deprecated once the transition history is fully launched
	PreviousTransitionHistory       []*VersionedTransition `protobuf:"bytes,100,rep,name=previous_transition_history,json=previousTransitionHistory,proto3" json:"previous_transition_history,omitempty"`
	LastTransitionHistoryBreakPoint *VersionedTransition   `protobuf:"bytes,101,opt,name=last_transition_history_break_point,json=lastTransitionHistoryBreakPoint,proto3" json:"last_transition_history_break_point,omitempty"`
	// This is a set of child workflows that were initialized after the reset point in the parent workflow.
	// The children are identified by the key "workflow_type:workflow_id". When the parent starts to make progress after reset, it uses this data to
	// determine the right start policy to apply to the child. This list will include children initiated in continue-as-new runs.
	ChildrenInitializedPostResetPoint map[string]*ResetChildInfo `protobuf:"bytes,102,rep,name=children_initialized_post_reset_point,json=childrenInitializedPostResetPoint,proto3" json:"children_initialized_post_reset_point,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The worker deployment that completed the last WFT.
	WorkerDeploymentName string `protobuf:"bytes,103,opt,name=worker_deployment_name,json=workerDeploymentName,proto3" json:"worker_deployment_name,omitempty"`
	// Priority contains metadata that controls relative ordering of task processing
	// when tasks are backed up in a queue.
	Priority      *v12.Priority `protobuf:"bytes,104,opt,name=priority,proto3" json:"priority,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkflowExecutionInfo) Reset() {
	*x = WorkflowExecutionInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowExecutionInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowExecutionInfo) ProtoMessage() {}

func (x *WorkflowExecutionInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowExecutionInfo.ProtoReflect.Descriptor instead.
func (*WorkflowExecutionInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{1}
}

func (x *WorkflowExecutionInfo) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetParentNamespaceId() string {
	if x != nil {
		return x.ParentNamespaceId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetParentWorkflowId() string {
	if x != nil {
		return x.ParentWorkflowId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetParentRunId() string {
	if x != nil {
		return x.ParentRunId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetParentInitiatedId() int64 {
	if x != nil {
		return x.ParentInitiatedId
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetCompletionEventBatchId() int64 {
	if x != nil {
		return x.CompletionEventBatchId
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetTaskQueue() string {
	if x != nil {
		return x.TaskQueue
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetWorkflowTypeName() string {
	if x != nil {
		return x.WorkflowTypeName
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetWorkflowExecutionTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowExecutionTimeout
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetWorkflowRunTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowRunTimeout
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetDefaultWorkflowTaskTimeout() *durationpb.Duration {
	if x != nil {
		return x.DefaultWorkflowTaskTimeout
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetLastEventTaskId() int64 {
	if x != nil {
		return x.LastEventTaskId
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetLastFirstEventId() int64 {
	if x != nil {
		return x.LastFirstEventId
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetLastCompletedWorkflowTaskStartedEventId() int64 {
	if x != nil {
		return x.LastCompletedWorkflowTaskStartedEventId
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetLastUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastUpdateTime
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskVersion() int64 {
	if x != nil {
		return x.WorkflowTaskVersion
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskScheduledEventId() int64 {
	if x != nil {
		return x.WorkflowTaskScheduledEventId
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskStartedEventId() int64 {
	if x != nil {
		return x.WorkflowTaskStartedEventId
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowTaskTimeout
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskAttempt() int32 {
	if x != nil {
		return x.WorkflowTaskAttempt
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskStartedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.WorkflowTaskStartedTime
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskScheduledTime() *timestamppb.Timestamp {
	if x != nil {
		return x.WorkflowTaskScheduledTime
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskOriginalScheduledTime() *timestamppb.Timestamp {
	if x != nil {
		return x.WorkflowTaskOriginalScheduledTime
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskRequestId() string {
	if x != nil {
		return x.WorkflowTaskRequestId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskType() v1.WorkflowTaskType {
	if x != nil {
		return x.WorkflowTaskType
	}
	return v1.WorkflowTaskType(0)
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskSuggestContinueAsNew() bool {
	if x != nil {
		return x.WorkflowTaskSuggestContinueAsNew
	}
	return false
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskHistorySizeBytes() int64 {
	if x != nil {
		return x.WorkflowTaskHistorySizeBytes
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskBuildId() string {
	if x != nil {
		return x.WorkflowTaskBuildId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskBuildIdRedirectCounter() int64 {
	if x != nil {
		return x.WorkflowTaskBuildIdRedirectCounter
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetCancelRequested() bool {
	if x != nil {
		return x.CancelRequested
	}
	return false
}

func (x *WorkflowExecutionInfo) GetCancelRequestId() string {
	if x != nil {
		return x.CancelRequestId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetStickyTaskQueue() string {
	if x != nil {
		return x.StickyTaskQueue
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetStickyScheduleToStartTimeout() *durationpb.Duration {
	if x != nil {
		return x.StickyScheduleToStartTimeout
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetAttempt() int32 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetRetryInitialInterval() *durationpb.Duration {
	if x != nil {
		return x.RetryInitialInterval
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetRetryMaximumInterval() *durationpb.Duration {
	if x != nil {
		return x.RetryMaximumInterval
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetRetryMaximumAttempts() int32 {
	if x != nil {
		return x.RetryMaximumAttempts
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetRetryBackoffCoefficient() float64 {
	if x != nil {
		return x.RetryBackoffCoefficient
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetWorkflowExecutionExpirationTime() *timestamppb.Timestamp {
	if x != nil {
		return x.WorkflowExecutionExpirationTime
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetRetryNonRetryableErrorTypes() []string {
	if x != nil {
		return x.RetryNonRetryableErrorTypes
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetHasRetryPolicy() bool {
	if x != nil {
		return x.HasRetryPolicy
	}
	return false
}

func (x *WorkflowExecutionInfo) GetCronSchedule() string {
	if x != nil {
		return x.CronSchedule
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetSignalCount() int64 {
	if x != nil {
		return x.SignalCount
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetActivityCount() int64 {
	if x != nil {
		return x.ActivityCount
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetChildExecutionCount() int64 {
	if x != nil {
		return x.ChildExecutionCount
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetUserTimerCount() int64 {
	if x != nil {
		return x.UserTimerCount
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetRequestCancelExternalCount() int64 {
	if x != nil {
		return x.RequestCancelExternalCount
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetSignalExternalCount() int64 {
	if x != nil {
		return x.SignalExternalCount
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetUpdateCount() int64 {
	if x != nil {
		return x.UpdateCount
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetAutoResetPoints() *v11.ResetPoints {
	if x != nil {
		return x.AutoResetPoints
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetSearchAttributes() map[string]*v12.Payload {
	if x != nil {
		return x.SearchAttributes
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetMemo() map[string]*v12.Payload {
	if x != nil {
		return x.Memo
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetVersionHistories() *v13.VersionHistories {
	if x != nil {
		return x.VersionHistories
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetFirstExecutionRunId() string {
	if x != nil {
		return x.FirstExecutionRunId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetExecutionStats() *ExecutionStats {
	if x != nil {
		return x.ExecutionStats
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetWorkflowRunExpirationTime() *timestamppb.Timestamp {
	if x != nil {
		return x.WorkflowRunExpirationTime
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetLastFirstEventTxnId() int64 {
	if x != nil {
		return x.LastFirstEventTxnId
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetStateTransitionCount() int64 {
	if x != nil {
		return x.StateTransitionCount
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetExecutionTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExecutionTime
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetNewExecutionRunId() string {
	if x != nil {
		return x.NewExecutionRunId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetParentClock() *v14.VectorClock {
	if x != nil {
		return x.ParentClock
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetParentInitiatedVersion() int64 {
	if x != nil {
		return x.ParentInitiatedVersion
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetCloseTransferTaskId() int64 {
	if x != nil {
		return x.CloseTransferTaskId
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetCloseVisibilityTaskId() int64 {
	if x != nil {
		return x.CloseVisibilityTaskId
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetCloseTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CloseTime
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetRelocatableAttributesRemoved() bool {
	if x != nil {
		return x.RelocatableAttributesRemoved
	}
	return false
}

func (x *WorkflowExecutionInfo) GetBaseExecutionInfo() *v15.BaseExecutionInfo {
	if x != nil {
		return x.BaseExecutionInfo
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetMostRecentWorkerVersionStamp() *v12.WorkerVersionStamp {
	if x != nil {
		return x.MostRecentWorkerVersionStamp
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetAssignedBuildId() string {
	if x != nil {
		return x.AssignedBuildId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetInheritedBuildId() string {
	if x != nil {
		return x.InheritedBuildId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetBuildIdRedirectCounter() int64 {
	if x != nil {
		return x.BuildIdRedirectCounter
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetUpdateInfos() map[string]*UpdateInfo {
	if x != nil {
		return x.UpdateInfos
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetTransitionHistory() []*VersionedTransition {
	if x != nil {
		return x.TransitionHistory
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetSubStateMachinesByType() map[string]*StateMachineMap {
	if x != nil {
		return x.SubStateMachinesByType
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetWorkflowExecutionTimerTaskStatus() int32 {
	if x != nil {
		return x.WorkflowExecutionTimerTaskStatus
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetRootWorkflowId() string {
	if x != nil {
		return x.RootWorkflowId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetRootRunId() string {
	if x != nil {
		return x.RootRunId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetStateMachineTimers() []*StateMachineTimerGroup {
	if x != nil {
		return x.StateMachineTimers
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetTaskGenerationShardClockTimestamp() int64 {
	if x != nil {
		return x.TaskGenerationShardClockTimestamp
	}
	return 0
}

func (x *WorkflowExecutionInfo) GetWorkflowTaskLastUpdateVersionedTransition() *VersionedTransition {
	if x != nil {
		return x.WorkflowTaskLastUpdateVersionedTransition
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetVisibilityLastUpdateVersionedTransition() *VersionedTransition {
	if x != nil {
		return x.VisibilityLastUpdateVersionedTransition
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetSignalRequestIdsLastUpdateVersionedTransition() *VersionedTransition {
	if x != nil {
		return x.SignalRequestIdsLastUpdateVersionedTransition
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetSubStateMachineTombstoneBatches() []*StateMachineTombstoneBatch {
	if x != nil {
		return x.SubStateMachineTombstoneBatches
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetWorkflowWasReset() bool {
	if x != nil {
		return x.WorkflowWasReset
	}
	return false
}

func (x *WorkflowExecutionInfo) GetResetRunId() string {
	if x != nil {
		return x.ResetRunId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetVersioningInfo() *v11.WorkflowExecutionVersioningInfo {
	if x != nil {
		return x.VersioningInfo
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetOriginalExecutionRunId() string {
	if x != nil {
		return x.OriginalExecutionRunId
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetPreviousTransitionHistory() []*VersionedTransition {
	if x != nil {
		return x.PreviousTransitionHistory
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetLastTransitionHistoryBreakPoint() *VersionedTransition {
	if x != nil {
		return x.LastTransitionHistoryBreakPoint
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetChildrenInitializedPostResetPoint() map[string]*ResetChildInfo {
	if x != nil {
		return x.ChildrenInitializedPostResetPoint
	}
	return nil
}

func (x *WorkflowExecutionInfo) GetWorkerDeploymentName() string {
	if x != nil {
		return x.WorkerDeploymentName
	}
	return ""
}

func (x *WorkflowExecutionInfo) GetPriority() *v12.Priority {
	if x != nil {
		return x.Priority
	}
	return nil
}

type ExecutionStats struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	HistorySize   int64                  `protobuf:"varint,1,opt,name=history_size,json=historySize,proto3" json:"history_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecutionStats) Reset() {
	*x = ExecutionStats{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecutionStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecutionStats) ProtoMessage() {}

func (x *ExecutionStats) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecutionStats.ProtoReflect.Descriptor instead.
func (*ExecutionStats) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{2}
}

func (x *ExecutionStats) GetHistorySize() int64 {
	if x != nil {
		return x.HistorySize
	}
	return 0
}

// execution_state column
type WorkflowExecutionState struct {
	state                         protoimpl.MessageState      `protogen:"open.v1"`
	CreateRequestId               string                      `protobuf:"bytes,1,opt,name=create_request_id,json=createRequestId,proto3" json:"create_request_id,omitempty"`
	RunId                         string                      `protobuf:"bytes,2,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	State                         v1.WorkflowExecutionState   `protobuf:"varint,3,opt,name=state,proto3,enum=temporal.server.api.enums.v1.WorkflowExecutionState" json:"state,omitempty"`
	Status                        v16.WorkflowExecutionStatus `protobuf:"varint,4,opt,name=status,proto3,enum=temporal.api.enums.v1.WorkflowExecutionStatus" json:"status,omitempty"`
	LastUpdateVersionedTransition *VersionedTransition        `protobuf:"bytes,5,opt,name=last_update_versioned_transition,json=lastUpdateVersionedTransition,proto3" json:"last_update_versioned_transition,omitempty"`
	StartTime                     *timestamppb.Timestamp      `protobuf:"bytes,6,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Request IDs that are attached to the workflow execution. It can the request ID that started
	// the workflow execution or request IDs that were attached to an existing running workflow
	// execution via StartWorkflowExecutionRequest.OnConflictOptions.
	RequestIds    map[string]*RequestIDInfo `protobuf:"bytes,7,rep,name=request_ids,json=requestIds,proto3" json:"request_ids,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkflowExecutionState) Reset() {
	*x = WorkflowExecutionState{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowExecutionState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowExecutionState) ProtoMessage() {}

func (x *WorkflowExecutionState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowExecutionState.ProtoReflect.Descriptor instead.
func (*WorkflowExecutionState) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{3}
}

func (x *WorkflowExecutionState) GetCreateRequestId() string {
	if x != nil {
		return x.CreateRequestId
	}
	return ""
}

func (x *WorkflowExecutionState) GetRunId() string {
	if x != nil {
		return x.RunId
	}
	return ""
}

func (x *WorkflowExecutionState) GetState() v1.WorkflowExecutionState {
	if x != nil {
		return x.State
	}
	return v1.WorkflowExecutionState(0)
}

func (x *WorkflowExecutionState) GetStatus() v16.WorkflowExecutionStatus {
	if x != nil {
		return x.Status
	}
	return v16.WorkflowExecutionStatus(0)
}

func (x *WorkflowExecutionState) GetLastUpdateVersionedTransition() *VersionedTransition {
	if x != nil {
		return x.LastUpdateVersionedTransition
	}
	return nil
}

func (x *WorkflowExecutionState) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *WorkflowExecutionState) GetRequestIds() map[string]*RequestIDInfo {
	if x != nil {
		return x.RequestIds
	}
	return nil
}

type RequestIDInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	EventType     v16.EventType          `protobuf:"varint,1,opt,name=event_type,json=eventType,proto3,enum=temporal.api.enums.v1.EventType" json:"event_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RequestIDInfo) Reset() {
	*x = RequestIDInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestIDInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestIDInfo) ProtoMessage() {}

func (x *RequestIDInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestIDInfo.ProtoReflect.Descriptor instead.
func (*RequestIDInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{4}
}

func (x *RequestIDInfo) GetEventType() v16.EventType {
	if x != nil {
		return x.EventType
	}
	return v16.EventType(0)
}

// transfer column
type TransferTaskInfo struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	NamespaceId             string                 `protobuf:"bytes,1,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	WorkflowId              string                 `protobuf:"bytes,2,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	RunId                   string                 `protobuf:"bytes,3,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	TaskType                v1.TaskType            `protobuf:"varint,4,opt,name=task_type,json=taskType,proto3,enum=temporal.server.api.enums.v1.TaskType" json:"task_type,omitempty"`
	TargetNamespaceId       string                 `protobuf:"bytes,5,opt,name=target_namespace_id,json=targetNamespaceId,proto3" json:"target_namespace_id,omitempty"`
	TargetWorkflowId        string                 `protobuf:"bytes,6,opt,name=target_workflow_id,json=targetWorkflowId,proto3" json:"target_workflow_id,omitempty"`
	TargetRunId             string                 `protobuf:"bytes,7,opt,name=target_run_id,json=targetRunId,proto3" json:"target_run_id,omitempty"`
	TaskQueue               string                 `protobuf:"bytes,8,opt,name=task_queue,json=taskQueue,proto3" json:"task_queue,omitempty"`
	TargetChildWorkflowOnly bool                   `protobuf:"varint,9,opt,name=target_child_workflow_only,json=targetChildWorkflowOnly,proto3" json:"target_child_workflow_only,omitempty"`
	ScheduledEventId        int64                  `protobuf:"varint,10,opt,name=scheduled_event_id,json=scheduledEventId,proto3" json:"scheduled_event_id,omitempty"`
	Version                 int64                  `protobuf:"varint,11,opt,name=version,proto3" json:"version,omitempty"`
	TaskId                  int64                  `protobuf:"varint,12,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	VisibilityTime          *timestamppb.Timestamp `protobuf:"bytes,13,opt,name=visibility_time,json=visibilityTime,proto3" json:"visibility_time,omitempty"`
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: "after" is used to indicate sequence of actions. --)
	DeleteAfterClose bool `protobuf:"varint,15,opt,name=delete_after_close,json=deleteAfterClose,proto3" json:"delete_after_close,omitempty"`
	// Types that are valid to be assigned to TaskDetails:
	//
	//	*TransferTaskInfo_CloseExecutionTaskDetails_
	//	*TransferTaskInfo_ChasmTaskInfo
	TaskDetails isTransferTaskInfo_TaskDetails `protobuf_oneof:"task_details"`
	// Stamp represents the version of the activity internal state, for which the timer task was created.
	// It monotonically increments when the activity options are changed.
	// It is used to check if activity related tasks are still relevant to  their corresponding state machine.
	Stamp         int32 `protobuf:"varint,17,opt,name=stamp,proto3" json:"stamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransferTaskInfo) Reset() {
	*x = TransferTaskInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransferTaskInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransferTaskInfo) ProtoMessage() {}

func (x *TransferTaskInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransferTaskInfo.ProtoReflect.Descriptor instead.
func (*TransferTaskInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{5}
}

func (x *TransferTaskInfo) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *TransferTaskInfo) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *TransferTaskInfo) GetRunId() string {
	if x != nil {
		return x.RunId
	}
	return ""
}

func (x *TransferTaskInfo) GetTaskType() v1.TaskType {
	if x != nil {
		return x.TaskType
	}
	return v1.TaskType(0)
}

func (x *TransferTaskInfo) GetTargetNamespaceId() string {
	if x != nil {
		return x.TargetNamespaceId
	}
	return ""
}

func (x *TransferTaskInfo) GetTargetWorkflowId() string {
	if x != nil {
		return x.TargetWorkflowId
	}
	return ""
}

func (x *TransferTaskInfo) GetTargetRunId() string {
	if x != nil {
		return x.TargetRunId
	}
	return ""
}

func (x *TransferTaskInfo) GetTaskQueue() string {
	if x != nil {
		return x.TaskQueue
	}
	return ""
}

func (x *TransferTaskInfo) GetTargetChildWorkflowOnly() bool {
	if x != nil {
		return x.TargetChildWorkflowOnly
	}
	return false
}

func (x *TransferTaskInfo) GetScheduledEventId() int64 {
	if x != nil {
		return x.ScheduledEventId
	}
	return 0
}

func (x *TransferTaskInfo) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *TransferTaskInfo) GetTaskId() int64 {
	if x != nil {
		return x.TaskId
	}
	return 0
}

func (x *TransferTaskInfo) GetVisibilityTime() *timestamppb.Timestamp {
	if x != nil {
		return x.VisibilityTime
	}
	return nil
}

func (x *TransferTaskInfo) GetDeleteAfterClose() bool {
	if x != nil {
		return x.DeleteAfterClose
	}
	return false
}

func (x *TransferTaskInfo) GetTaskDetails() isTransferTaskInfo_TaskDetails {
	if x != nil {
		return x.TaskDetails
	}
	return nil
}

func (x *TransferTaskInfo) GetCloseExecutionTaskDetails() *TransferTaskInfo_CloseExecutionTaskDetails {
	if x != nil {
		if x, ok := x.TaskDetails.(*TransferTaskInfo_CloseExecutionTaskDetails_); ok {
			return x.CloseExecutionTaskDetails
		}
	}
	return nil
}

func (x *TransferTaskInfo) GetChasmTaskInfo() *ChasmTaskInfo {
	if x != nil {
		if x, ok := x.TaskDetails.(*TransferTaskInfo_ChasmTaskInfo); ok {
			return x.ChasmTaskInfo
		}
	}
	return nil
}

func (x *TransferTaskInfo) GetStamp() int32 {
	if x != nil {
		return x.Stamp
	}
	return 0
}

type isTransferTaskInfo_TaskDetails interface {
	isTransferTaskInfo_TaskDetails()
}

type TransferTaskInfo_CloseExecutionTaskDetails_ struct {
	CloseExecutionTaskDetails *TransferTaskInfo_CloseExecutionTaskDetails `protobuf:"bytes,16,opt,name=close_execution_task_details,json=closeExecutionTaskDetails,proto3,oneof"`
}

type TransferTaskInfo_ChasmTaskInfo struct {
	// If the task addresses a CHASM component, this field will be set.
	ChasmTaskInfo *ChasmTaskInfo `protobuf:"bytes,18,opt,name=chasm_task_info,json=chasmTaskInfo,proto3,oneof"`
}

func (*TransferTaskInfo_CloseExecutionTaskDetails_) isTransferTaskInfo_TaskDetails() {}

func (*TransferTaskInfo_ChasmTaskInfo) isTransferTaskInfo_TaskDetails() {}

// replication column
type ReplicationTaskInfo struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	NamespaceId         string                 `protobuf:"bytes,1,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	WorkflowId          string                 `protobuf:"bytes,2,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	RunId               string                 `protobuf:"bytes,3,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	TaskType            v1.TaskType            `protobuf:"varint,4,opt,name=task_type,json=taskType,proto3,enum=temporal.server.api.enums.v1.TaskType" json:"task_type,omitempty"`
	Version             int64                  `protobuf:"varint,5,opt,name=version,proto3" json:"version,omitempty"`
	FirstEventId        int64                  `protobuf:"varint,6,opt,name=first_event_id,json=firstEventId,proto3" json:"first_event_id,omitempty"`
	NextEventId         int64                  `protobuf:"varint,7,opt,name=next_event_id,json=nextEventId,proto3" json:"next_event_id,omitempty"`
	ScheduledEventId    int64                  `protobuf:"varint,8,opt,name=scheduled_event_id,json=scheduledEventId,proto3" json:"scheduled_event_id,omitempty"`
	BranchToken         []byte                 `protobuf:"bytes,11,opt,name=branch_token,json=branchToken,proto3" json:"branch_token,omitempty"`
	NewRunBranchToken   []byte                 `protobuf:"bytes,13,opt,name=new_run_branch_token,json=newRunBranchToken,proto3" json:"new_run_branch_token,omitempty"`
	TaskId              int64                  `protobuf:"varint,15,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	VisibilityTime      *timestamppb.Timestamp `protobuf:"bytes,16,opt,name=visibility_time,json=visibilityTime,proto3" json:"visibility_time,omitempty"`
	NewRunId            string                 `protobuf:"bytes,17,opt,name=new_run_id,json=newRunId,proto3" json:"new_run_id,omitempty"`
	Priority            v1.TaskPriority        `protobuf:"varint,18,opt,name=priority,proto3,enum=temporal.server.api.enums.v1.TaskPriority" json:"priority,omitempty"`
	VersionedTransition *VersionedTransition   `protobuf:"bytes,19,opt,name=versioned_transition,json=versionedTransition,proto3" json:"versioned_transition,omitempty"`
	// A list of event-based replication tasks that, together, are equivalent
	// to this state-based task.
	// TODO: Remove this field when state-based replication is stable and
	// doesn't need to be disabled.
	TaskEquivalents        []*ReplicationTaskInfo  `protobuf:"bytes,20,rep,name=task_equivalents,json=taskEquivalents,proto3" json:"task_equivalents,omitempty"`
	LastVersionHistoryItem *v13.VersionHistoryItem `protobuf:"bytes,21,opt,name=last_version_history_item,json=lastVersionHistoryItem,proto3" json:"last_version_history_item,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *ReplicationTaskInfo) Reset() {
	*x = ReplicationTaskInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicationTaskInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicationTaskInfo) ProtoMessage() {}

func (x *ReplicationTaskInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicationTaskInfo.ProtoReflect.Descriptor instead.
func (*ReplicationTaskInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{6}
}

func (x *ReplicationTaskInfo) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *ReplicationTaskInfo) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *ReplicationTaskInfo) GetRunId() string {
	if x != nil {
		return x.RunId
	}
	return ""
}

func (x *ReplicationTaskInfo) GetTaskType() v1.TaskType {
	if x != nil {
		return x.TaskType
	}
	return v1.TaskType(0)
}

func (x *ReplicationTaskInfo) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *ReplicationTaskInfo) GetFirstEventId() int64 {
	if x != nil {
		return x.FirstEventId
	}
	return 0
}

func (x *ReplicationTaskInfo) GetNextEventId() int64 {
	if x != nil {
		return x.NextEventId
	}
	return 0
}

func (x *ReplicationTaskInfo) GetScheduledEventId() int64 {
	if x != nil {
		return x.ScheduledEventId
	}
	return 0
}

func (x *ReplicationTaskInfo) GetBranchToken() []byte {
	if x != nil {
		return x.BranchToken
	}
	return nil
}

func (x *ReplicationTaskInfo) GetNewRunBranchToken() []byte {
	if x != nil {
		return x.NewRunBranchToken
	}
	return nil
}

func (x *ReplicationTaskInfo) GetTaskId() int64 {
	if x != nil {
		return x.TaskId
	}
	return 0
}

func (x *ReplicationTaskInfo) GetVisibilityTime() *timestamppb.Timestamp {
	if x != nil {
		return x.VisibilityTime
	}
	return nil
}

func (x *ReplicationTaskInfo) GetNewRunId() string {
	if x != nil {
		return x.NewRunId
	}
	return ""
}

func (x *ReplicationTaskInfo) GetPriority() v1.TaskPriority {
	if x != nil {
		return x.Priority
	}
	return v1.TaskPriority(0)
}

func (x *ReplicationTaskInfo) GetVersionedTransition() *VersionedTransition {
	if x != nil {
		return x.VersionedTransition
	}
	return nil
}

func (x *ReplicationTaskInfo) GetTaskEquivalents() []*ReplicationTaskInfo {
	if x != nil {
		return x.TaskEquivalents
	}
	return nil
}

func (x *ReplicationTaskInfo) GetLastVersionHistoryItem() *v13.VersionHistoryItem {
	if x != nil {
		return x.LastVersionHistoryItem
	}
	return nil
}

// visibility_task_data column
type VisibilityTaskInfo struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	NamespaceId           string                 `protobuf:"bytes,1,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	WorkflowId            string                 `protobuf:"bytes,2,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	RunId                 string                 `protobuf:"bytes,3,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	TaskType              v1.TaskType            `protobuf:"varint,4,opt,name=task_type,json=taskType,proto3,enum=temporal.server.api.enums.v1.TaskType" json:"task_type,omitempty"`
	Version               int64                  `protobuf:"varint,5,opt,name=version,proto3" json:"version,omitempty"`
	TaskId                int64                  `protobuf:"varint,6,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	VisibilityTime        *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=visibility_time,json=visibilityTime,proto3" json:"visibility_time,omitempty"`
	CloseVisibilityTaskId int64                  `protobuf:"varint,10,opt,name=close_visibility_task_id,json=closeVisibilityTaskId,proto3" json:"close_visibility_task_id,omitempty"`
	CloseTime             *timestamppb.Timestamp `protobuf:"bytes,11,opt,name=close_time,json=closeTime,proto3" json:"close_time,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *VisibilityTaskInfo) Reset() {
	*x = VisibilityTaskInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VisibilityTaskInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VisibilityTaskInfo) ProtoMessage() {}

func (x *VisibilityTaskInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VisibilityTaskInfo.ProtoReflect.Descriptor instead.
func (*VisibilityTaskInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{7}
}

func (x *VisibilityTaskInfo) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *VisibilityTaskInfo) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *VisibilityTaskInfo) GetRunId() string {
	if x != nil {
		return x.RunId
	}
	return ""
}

func (x *VisibilityTaskInfo) GetTaskType() v1.TaskType {
	if x != nil {
		return x.TaskType
	}
	return v1.TaskType(0)
}

func (x *VisibilityTaskInfo) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *VisibilityTaskInfo) GetTaskId() int64 {
	if x != nil {
		return x.TaskId
	}
	return 0
}

func (x *VisibilityTaskInfo) GetVisibilityTime() *timestamppb.Timestamp {
	if x != nil {
		return x.VisibilityTime
	}
	return nil
}

func (x *VisibilityTaskInfo) GetCloseVisibilityTaskId() int64 {
	if x != nil {
		return x.CloseVisibilityTaskId
	}
	return 0
}

func (x *VisibilityTaskInfo) GetCloseTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CloseTime
	}
	return nil
}

// timer column
type TimerTaskInfo struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	NamespaceId         string                 `protobuf:"bytes,1,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	WorkflowId          string                 `protobuf:"bytes,2,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	RunId               string                 `protobuf:"bytes,3,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	TaskType            v1.TaskType            `protobuf:"varint,4,opt,name=task_type,json=taskType,proto3,enum=temporal.server.api.enums.v1.TaskType" json:"task_type,omitempty"`
	TimeoutType         v16.TimeoutType        `protobuf:"varint,5,opt,name=timeout_type,json=timeoutType,proto3,enum=temporal.api.enums.v1.TimeoutType" json:"timeout_type,omitempty"`
	WorkflowBackoffType v1.WorkflowBackoffType `protobuf:"varint,6,opt,name=workflow_backoff_type,json=workflowBackoffType,proto3,enum=temporal.server.api.enums.v1.WorkflowBackoffType" json:"workflow_backoff_type,omitempty"`
	Version             int64                  `protobuf:"varint,7,opt,name=version,proto3" json:"version,omitempty"`
	ScheduleAttempt     int32                  `protobuf:"varint,8,opt,name=schedule_attempt,json=scheduleAttempt,proto3" json:"schedule_attempt,omitempty"`
	EventId             int64                  `protobuf:"varint,9,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	TaskId              int64                  `protobuf:"varint,10,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	VisibilityTime      *timestamppb.Timestamp `protobuf:"bytes,11,opt,name=visibility_time,json=visibilityTime,proto3" json:"visibility_time,omitempty"`
	BranchToken         []byte                 `protobuf:"bytes,12,opt,name=branch_token,json=branchToken,proto3" json:"branch_token,omitempty"`
	// If this is true, we can bypass archival before deleting. Only defined for DeleteHistoryEventTasks.
	AlreadyArchived bool `protobuf:"varint,13,opt,name=already_archived,json=alreadyArchived,proto3" json:"already_archived,omitempty"`
	// Number of transitions on the corresponding mutable state object. Used to verify that a task is not referencing a
	// stale state or, in some situations, that the task itself is not stale.
	// If task addresses a sub-statemachine (e.g. callback), this field will be set.
	MutableStateTransitionCount int64 `protobuf:"varint,14,opt,name=mutable_state_transition_count,json=mutableStateTransitionCount,proto3" json:"mutable_state_transition_count,omitempty"`
	// If specified, the task is a for a workflow chain instead of a specific workflow run.
	// A workflow chain is identified by the run_id of the first workflow in the chain.
	FirstRunId string `protobuf:"bytes,15,opt,name=first_run_id,json=firstRunId,proto3" json:"first_run_id,omitempty"`
	// Stamp represents the version of the activity internal state, for which the timer task was created.
	// It monotonically increments when the activity options are changed.
	// It is used to check if activity related tasks are still relevant to  their corresponding state machine.
	Stamp int32 `protobuf:"varint,16,opt,name=stamp,proto3" json:"stamp,omitempty"`
	// Types that are valid to be assigned to TaskDetails:
	//
	//	*TimerTaskInfo_ChasmTaskInfo
	TaskDetails   isTimerTaskInfo_TaskDetails `protobuf_oneof:"task_details"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TimerTaskInfo) Reset() {
	*x = TimerTaskInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimerTaskInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimerTaskInfo) ProtoMessage() {}

func (x *TimerTaskInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimerTaskInfo.ProtoReflect.Descriptor instead.
func (*TimerTaskInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{8}
}

func (x *TimerTaskInfo) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *TimerTaskInfo) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *TimerTaskInfo) GetRunId() string {
	if x != nil {
		return x.RunId
	}
	return ""
}

func (x *TimerTaskInfo) GetTaskType() v1.TaskType {
	if x != nil {
		return x.TaskType
	}
	return v1.TaskType(0)
}

func (x *TimerTaskInfo) GetTimeoutType() v16.TimeoutType {
	if x != nil {
		return x.TimeoutType
	}
	return v16.TimeoutType(0)
}

func (x *TimerTaskInfo) GetWorkflowBackoffType() v1.WorkflowBackoffType {
	if x != nil {
		return x.WorkflowBackoffType
	}
	return v1.WorkflowBackoffType(0)
}

func (x *TimerTaskInfo) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *TimerTaskInfo) GetScheduleAttempt() int32 {
	if x != nil {
		return x.ScheduleAttempt
	}
	return 0
}

func (x *TimerTaskInfo) GetEventId() int64 {
	if x != nil {
		return x.EventId
	}
	return 0
}

func (x *TimerTaskInfo) GetTaskId() int64 {
	if x != nil {
		return x.TaskId
	}
	return 0
}

func (x *TimerTaskInfo) GetVisibilityTime() *timestamppb.Timestamp {
	if x != nil {
		return x.VisibilityTime
	}
	return nil
}

func (x *TimerTaskInfo) GetBranchToken() []byte {
	if x != nil {
		return x.BranchToken
	}
	return nil
}

func (x *TimerTaskInfo) GetAlreadyArchived() bool {
	if x != nil {
		return x.AlreadyArchived
	}
	return false
}

func (x *TimerTaskInfo) GetMutableStateTransitionCount() int64 {
	if x != nil {
		return x.MutableStateTransitionCount
	}
	return 0
}

func (x *TimerTaskInfo) GetFirstRunId() string {
	if x != nil {
		return x.FirstRunId
	}
	return ""
}

func (x *TimerTaskInfo) GetStamp() int32 {
	if x != nil {
		return x.Stamp
	}
	return 0
}

func (x *TimerTaskInfo) GetTaskDetails() isTimerTaskInfo_TaskDetails {
	if x != nil {
		return x.TaskDetails
	}
	return nil
}

func (x *TimerTaskInfo) GetChasmTaskInfo() *ChasmTaskInfo {
	if x != nil {
		if x, ok := x.TaskDetails.(*TimerTaskInfo_ChasmTaskInfo); ok {
			return x.ChasmTaskInfo
		}
	}
	return nil
}

type isTimerTaskInfo_TaskDetails interface {
	isTimerTaskInfo_TaskDetails()
}

type TimerTaskInfo_ChasmTaskInfo struct {
	// If the task addresses a CHASM component, this field will be set.
	ChasmTaskInfo *ChasmTaskInfo `protobuf:"bytes,17,opt,name=chasm_task_info,json=chasmTaskInfo,proto3,oneof"`
}

func (*TimerTaskInfo_ChasmTaskInfo) isTimerTaskInfo_TaskDetails() {}

type ArchivalTaskInfo struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	TaskId         int64                  `protobuf:"varint,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	NamespaceId    string                 `protobuf:"bytes,2,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	WorkflowId     string                 `protobuf:"bytes,3,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	RunId          string                 `protobuf:"bytes,4,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	TaskType       v1.TaskType            `protobuf:"varint,5,opt,name=task_type,json=taskType,proto3,enum=temporal.server.api.enums.v1.TaskType" json:"task_type,omitempty"`
	Version        int64                  `protobuf:"varint,6,opt,name=version,proto3" json:"version,omitempty"`
	VisibilityTime *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=visibility_time,json=visibilityTime,proto3" json:"visibility_time,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ArchivalTaskInfo) Reset() {
	*x = ArchivalTaskInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArchivalTaskInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArchivalTaskInfo) ProtoMessage() {}

func (x *ArchivalTaskInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArchivalTaskInfo.ProtoReflect.Descriptor instead.
func (*ArchivalTaskInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{9}
}

func (x *ArchivalTaskInfo) GetTaskId() int64 {
	if x != nil {
		return x.TaskId
	}
	return 0
}

func (x *ArchivalTaskInfo) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *ArchivalTaskInfo) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *ArchivalTaskInfo) GetRunId() string {
	if x != nil {
		return x.RunId
	}
	return ""
}

func (x *ArchivalTaskInfo) GetTaskType() v1.TaskType {
	if x != nil {
		return x.TaskType
	}
	return v1.TaskType(0)
}

func (x *ArchivalTaskInfo) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *ArchivalTaskInfo) GetVisibilityTime() *timestamppb.Timestamp {
	if x != nil {
		return x.VisibilityTime
	}
	return nil
}

type OutboundTaskInfo struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	NamespaceId    string                 `protobuf:"bytes,1,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	WorkflowId     string                 `protobuf:"bytes,2,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	RunId          string                 `protobuf:"bytes,3,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	TaskType       v1.TaskType            `protobuf:"varint,4,opt,name=task_type,json=taskType,proto3,enum=temporal.server.api.enums.v1.TaskType" json:"task_type,omitempty"`
	TaskId         int64                  `protobuf:"varint,5,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	VisibilityTime *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=visibility_time,json=visibilityTime,proto3" json:"visibility_time,omitempty"`
	// Destination of this task (e.g. protocol+host+port for callbacks).
	// Outbound tasks are grouped by this field (and the namespace ID) when scheduling.
	Destination string `protobuf:"bytes,7,opt,name=destination,proto3" json:"destination,omitempty"`
	// Types that are valid to be assigned to TaskDetails:
	//
	//	*OutboundTaskInfo_StateMachineInfo
	//	*OutboundTaskInfo_ChasmTaskInfo
	TaskDetails   isOutboundTaskInfo_TaskDetails `protobuf_oneof:"task_details"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OutboundTaskInfo) Reset() {
	*x = OutboundTaskInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutboundTaskInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutboundTaskInfo) ProtoMessage() {}

func (x *OutboundTaskInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutboundTaskInfo.ProtoReflect.Descriptor instead.
func (*OutboundTaskInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{10}
}

func (x *OutboundTaskInfo) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *OutboundTaskInfo) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *OutboundTaskInfo) GetRunId() string {
	if x != nil {
		return x.RunId
	}
	return ""
}

func (x *OutboundTaskInfo) GetTaskType() v1.TaskType {
	if x != nil {
		return x.TaskType
	}
	return v1.TaskType(0)
}

func (x *OutboundTaskInfo) GetTaskId() int64 {
	if x != nil {
		return x.TaskId
	}
	return 0
}

func (x *OutboundTaskInfo) GetVisibilityTime() *timestamppb.Timestamp {
	if x != nil {
		return x.VisibilityTime
	}
	return nil
}

func (x *OutboundTaskInfo) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

func (x *OutboundTaskInfo) GetTaskDetails() isOutboundTaskInfo_TaskDetails {
	if x != nil {
		return x.TaskDetails
	}
	return nil
}

func (x *OutboundTaskInfo) GetStateMachineInfo() *StateMachineTaskInfo {
	if x != nil {
		if x, ok := x.TaskDetails.(*OutboundTaskInfo_StateMachineInfo); ok {
			return x.StateMachineInfo
		}
	}
	return nil
}

func (x *OutboundTaskInfo) GetChasmTaskInfo() *ChasmTaskInfo {
	if x != nil {
		if x, ok := x.TaskDetails.(*OutboundTaskInfo_ChasmTaskInfo); ok {
			return x.ChasmTaskInfo
		}
	}
	return nil
}

type isOutboundTaskInfo_TaskDetails interface {
	isOutboundTaskInfo_TaskDetails()
}

type OutboundTaskInfo_StateMachineInfo struct {
	// If task addresses a sub-statemachine (e.g. callback), this field will be set.
	StateMachineInfo *StateMachineTaskInfo `protobuf:"bytes,8,opt,name=state_machine_info,json=stateMachineInfo,proto3,oneof"`
}

type OutboundTaskInfo_ChasmTaskInfo struct {
	// If the task addresses a CHASM component, this field will be set.
	ChasmTaskInfo *ChasmTaskInfo `protobuf:"bytes,9,opt,name=chasm_task_info,json=chasmTaskInfo,proto3,oneof"`
}

func (*OutboundTaskInfo_StateMachineInfo) isOutboundTaskInfo_TaskDetails() {}

func (*OutboundTaskInfo_ChasmTaskInfo) isOutboundTaskInfo_TaskDetails() {}

type NexusInvocationTaskInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Attempt       int32                  `protobuf:"varint,1,opt,name=attempt,proto3" json:"attempt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NexusInvocationTaskInfo) Reset() {
	*x = NexusInvocationTaskInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NexusInvocationTaskInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NexusInvocationTaskInfo) ProtoMessage() {}

func (x *NexusInvocationTaskInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NexusInvocationTaskInfo.ProtoReflect.Descriptor instead.
func (*NexusInvocationTaskInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{11}
}

func (x *NexusInvocationTaskInfo) GetAttempt() int32 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

type NexusCancelationTaskInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Attempt       int32                  `protobuf:"varint,1,opt,name=attempt,proto3" json:"attempt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NexusCancelationTaskInfo) Reset() {
	*x = NexusCancelationTaskInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NexusCancelationTaskInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NexusCancelationTaskInfo) ProtoMessage() {}

func (x *NexusCancelationTaskInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NexusCancelationTaskInfo.ProtoReflect.Descriptor instead.
func (*NexusCancelationTaskInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{12}
}

func (x *NexusCancelationTaskInfo) GetAttempt() int32 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

// activity_map column
type ActivityInfo struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	Version               int64                  `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	ScheduledEventBatchId int64                  `protobuf:"varint,2,opt,name=scheduled_event_batch_id,json=scheduledEventBatchId,proto3" json:"scheduled_event_batch_id,omitempty"`
	ScheduledTime         *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=scheduled_time,json=scheduledTime,proto3" json:"scheduled_time,omitempty"`
	StartedEventId        int64                  `protobuf:"varint,5,opt,name=started_event_id,json=startedEventId,proto3" json:"started_event_id,omitempty"`
	StartedTime           *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=started_time,json=startedTime,proto3" json:"started_time,omitempty"`
	ActivityId            string                 `protobuf:"bytes,8,opt,name=activity_id,json=activityId,proto3" json:"activity_id,omitempty"`
	RequestId             string                 `protobuf:"bytes,9,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: "to" is used to indicate interval. --)
	ScheduleToStartTimeout *durationpb.Duration `protobuf:"bytes,10,opt,name=schedule_to_start_timeout,json=scheduleToStartTimeout,proto3" json:"schedule_to_start_timeout,omitempty"`
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: "to" is used to indicate interval. --)
	ScheduleToCloseTimeout *durationpb.Duration `protobuf:"bytes,11,opt,name=schedule_to_close_timeout,json=scheduleToCloseTimeout,proto3" json:"schedule_to_close_timeout,omitempty"`
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: "to" is used to indicate interval. --)
	StartToCloseTimeout         *durationpb.Duration   `protobuf:"bytes,12,opt,name=start_to_close_timeout,json=startToCloseTimeout,proto3" json:"start_to_close_timeout,omitempty"`
	HeartbeatTimeout            *durationpb.Duration   `protobuf:"bytes,13,opt,name=heartbeat_timeout,json=heartbeatTimeout,proto3" json:"heartbeat_timeout,omitempty"`
	CancelRequested             bool                   `protobuf:"varint,14,opt,name=cancel_requested,json=cancelRequested,proto3" json:"cancel_requested,omitempty"`
	CancelRequestId             int64                  `protobuf:"varint,15,opt,name=cancel_request_id,json=cancelRequestId,proto3" json:"cancel_request_id,omitempty"`
	TimerTaskStatus             int32                  `protobuf:"varint,16,opt,name=timer_task_status,json=timerTaskStatus,proto3" json:"timer_task_status,omitempty"`
	Attempt                     int32                  `protobuf:"varint,17,opt,name=attempt,proto3" json:"attempt,omitempty"`
	TaskQueue                   string                 `protobuf:"bytes,18,opt,name=task_queue,json=taskQueue,proto3" json:"task_queue,omitempty"`
	StartedIdentity             string                 `protobuf:"bytes,19,opt,name=started_identity,json=startedIdentity,proto3" json:"started_identity,omitempty"`
	HasRetryPolicy              bool                   `protobuf:"varint,20,opt,name=has_retry_policy,json=hasRetryPolicy,proto3" json:"has_retry_policy,omitempty"`
	RetryInitialInterval        *durationpb.Duration   `protobuf:"bytes,21,opt,name=retry_initial_interval,json=retryInitialInterval,proto3" json:"retry_initial_interval,omitempty"`
	RetryMaximumInterval        *durationpb.Duration   `protobuf:"bytes,22,opt,name=retry_maximum_interval,json=retryMaximumInterval,proto3" json:"retry_maximum_interval,omitempty"`
	RetryMaximumAttempts        int32                  `protobuf:"varint,23,opt,name=retry_maximum_attempts,json=retryMaximumAttempts,proto3" json:"retry_maximum_attempts,omitempty"`
	RetryExpirationTime         *timestamppb.Timestamp `protobuf:"bytes,24,opt,name=retry_expiration_time,json=retryExpirationTime,proto3" json:"retry_expiration_time,omitempty"`
	RetryBackoffCoefficient     float64                `protobuf:"fixed64,25,opt,name=retry_backoff_coefficient,json=retryBackoffCoefficient,proto3" json:"retry_backoff_coefficient,omitempty"`
	RetryNonRetryableErrorTypes []string               `protobuf:"bytes,26,rep,name=retry_non_retryable_error_types,json=retryNonRetryableErrorTypes,proto3" json:"retry_non_retryable_error_types,omitempty"`
	RetryLastFailure            *v17.Failure           `protobuf:"bytes,27,opt,name=retry_last_failure,json=retryLastFailure,proto3" json:"retry_last_failure,omitempty"`
	RetryLastWorkerIdentity     string                 `protobuf:"bytes,28,opt,name=retry_last_worker_identity,json=retryLastWorkerIdentity,proto3" json:"retry_last_worker_identity,omitempty"`
	ScheduledEventId            int64                  `protobuf:"varint,30,opt,name=scheduled_event_id,json=scheduledEventId,proto3" json:"scheduled_event_id,omitempty"`
	LastHeartbeatDetails        *v12.Payloads          `protobuf:"bytes,31,opt,name=last_heartbeat_details,json=lastHeartbeatDetails,proto3" json:"last_heartbeat_details,omitempty"`
	LastHeartbeatUpdateTime     *timestamppb.Timestamp `protobuf:"bytes,32,opt,name=last_heartbeat_update_time,json=lastHeartbeatUpdateTime,proto3" json:"last_heartbeat_update_time,omitempty"`
	// When true, it means the activity is assigned to the build ID of its workflow (only set for old versioning)
	// Deprecated. use `use_workflow_build_id`
	// Deprecated. Clean up with versioning-2. [cleanup-old-wv]
	UseCompatibleVersion bool              `protobuf:"varint,33,opt,name=use_compatible_version,json=useCompatibleVersion,proto3" json:"use_compatible_version,omitempty"`
	ActivityType         *v12.ActivityType `protobuf:"bytes,34,opt,name=activity_type,json=activityType,proto3" json:"activity_type,omitempty"`
	// Absence of `assigned_build_id` generally means this task is on an "unversioned" task queue.
	// In rare cases, it can also mean that the task queue is versioned but we failed to write activity's
	// independently-assigned build ID to the database. This case heals automatically once the task is dispatched.
	// Deprecated. Clean up with versioning-2. [cleanup-old-wv]
	//
	// Types that are valid to be assigned to BuildIdInfo:
	//
	//	*ActivityInfo_UseWorkflowBuildIdInfo_
	//	*ActivityInfo_LastIndependentlyAssignedBuildId
	BuildIdInfo isActivityInfo_BuildIdInfo `protobuf_oneof:"build_id_info"`
	// The version stamp of the worker to whom this activity was most-recently dispatched
	// Deprecated. Clean up with versioning-2. [cleanup-old-wv]
	LastWorkerVersionStamp        *v12.WorkerVersionStamp `protobuf:"bytes,37,opt,name=last_worker_version_stamp,json=lastWorkerVersionStamp,proto3" json:"last_worker_version_stamp,omitempty"`
	LastUpdateVersionedTransition *VersionedTransition    `protobuf:"bytes,38,opt,name=last_update_versioned_transition,json=lastUpdateVersionedTransition,proto3" json:"last_update_versioned_transition,omitempty"`
	// The first time the activity was scheduled.
	FirstScheduledTime *timestamppb.Timestamp `protobuf:"bytes,39,opt,name=first_scheduled_time,json=firstScheduledTime,proto3" json:"first_scheduled_time,omitempty"`
	// The last time an activity attempt completion was recorded by the server.
	LastAttemptCompleteTime *timestamppb.Timestamp `protobuf:"bytes,40,opt,name=last_attempt_complete_time,json=lastAttemptCompleteTime,proto3" json:"last_attempt_complete_time,omitempty"`
	// Stamp represents the “version” of the activity internal state (options) and can/will be changed with Activity API.
	// It monotonically increments when the activity options are changed.
	// It is used to check if activity related tasks are still relevant to  their corresponding state machine.
	Stamp int32 `protobuf:"varint,41,opt,name=stamp,proto3" json:"stamp,omitempty"`
	// Paused state. When activity is paused it will not advance until unpaused.
	// Iw will not be scheduled, timer tasks will not be processed, etc.
	// Note: it still can be cancelled/completed.
	Paused bool `protobuf:"varint,42,opt,name=paused,proto3" json:"paused,omitempty"`
	// The deployment this activity was dispatched to most recently. Present only if the activity
	// was dispatched to a versioned worker.
	// Deprecated. Replaced by last_worker_deployment_version.
	LastStartedDeployment *v18.Deployment `protobuf:"bytes,43,opt,name=last_started_deployment,json=lastStartedDeployment,proto3" json:"last_started_deployment,omitempty"`
	// The deployment this activity was dispatched to most recently. Present only if the activity
	// was dispatched to a versioned worker.
	LastWorkerDeploymentVersion string `protobuf:"bytes,44,opt,name=last_worker_deployment_version,json=lastWorkerDeploymentVersion,proto3" json:"last_worker_deployment_version,omitempty"`
	// Priority metadata. If this message is not present, or any fields are not
	// present, they inherit the values from the workflow.
	Priority      *v12.Priority `protobuf:"bytes,45,opt,name=priority,proto3" json:"priority,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ActivityInfo) Reset() {
	*x = ActivityInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ActivityInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ActivityInfo) ProtoMessage() {}

func (x *ActivityInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ActivityInfo.ProtoReflect.Descriptor instead.
func (*ActivityInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{13}
}

func (x *ActivityInfo) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *ActivityInfo) GetScheduledEventBatchId() int64 {
	if x != nil {
		return x.ScheduledEventBatchId
	}
	return 0
}

func (x *ActivityInfo) GetScheduledTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ScheduledTime
	}
	return nil
}

func (x *ActivityInfo) GetStartedEventId() int64 {
	if x != nil {
		return x.StartedEventId
	}
	return 0
}

func (x *ActivityInfo) GetStartedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartedTime
	}
	return nil
}

func (x *ActivityInfo) GetActivityId() string {
	if x != nil {
		return x.ActivityId
	}
	return ""
}

func (x *ActivityInfo) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *ActivityInfo) GetScheduleToStartTimeout() *durationpb.Duration {
	if x != nil {
		return x.ScheduleToStartTimeout
	}
	return nil
}

func (x *ActivityInfo) GetScheduleToCloseTimeout() *durationpb.Duration {
	if x != nil {
		return x.ScheduleToCloseTimeout
	}
	return nil
}

func (x *ActivityInfo) GetStartToCloseTimeout() *durationpb.Duration {
	if x != nil {
		return x.StartToCloseTimeout
	}
	return nil
}

func (x *ActivityInfo) GetHeartbeatTimeout() *durationpb.Duration {
	if x != nil {
		return x.HeartbeatTimeout
	}
	return nil
}

func (x *ActivityInfo) GetCancelRequested() bool {
	if x != nil {
		return x.CancelRequested
	}
	return false
}

func (x *ActivityInfo) GetCancelRequestId() int64 {
	if x != nil {
		return x.CancelRequestId
	}
	return 0
}

func (x *ActivityInfo) GetTimerTaskStatus() int32 {
	if x != nil {
		return x.TimerTaskStatus
	}
	return 0
}

func (x *ActivityInfo) GetAttempt() int32 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

func (x *ActivityInfo) GetTaskQueue() string {
	if x != nil {
		return x.TaskQueue
	}
	return ""
}

func (x *ActivityInfo) GetStartedIdentity() string {
	if x != nil {
		return x.StartedIdentity
	}
	return ""
}

func (x *ActivityInfo) GetHasRetryPolicy() bool {
	if x != nil {
		return x.HasRetryPolicy
	}
	return false
}

func (x *ActivityInfo) GetRetryInitialInterval() *durationpb.Duration {
	if x != nil {
		return x.RetryInitialInterval
	}
	return nil
}

func (x *ActivityInfo) GetRetryMaximumInterval() *durationpb.Duration {
	if x != nil {
		return x.RetryMaximumInterval
	}
	return nil
}

func (x *ActivityInfo) GetRetryMaximumAttempts() int32 {
	if x != nil {
		return x.RetryMaximumAttempts
	}
	return 0
}

func (x *ActivityInfo) GetRetryExpirationTime() *timestamppb.Timestamp {
	if x != nil {
		return x.RetryExpirationTime
	}
	return nil
}

func (x *ActivityInfo) GetRetryBackoffCoefficient() float64 {
	if x != nil {
		return x.RetryBackoffCoefficient
	}
	return 0
}

func (x *ActivityInfo) GetRetryNonRetryableErrorTypes() []string {
	if x != nil {
		return x.RetryNonRetryableErrorTypes
	}
	return nil
}

func (x *ActivityInfo) GetRetryLastFailure() *v17.Failure {
	if x != nil {
		return x.RetryLastFailure
	}
	return nil
}

func (x *ActivityInfo) GetRetryLastWorkerIdentity() string {
	if x != nil {
		return x.RetryLastWorkerIdentity
	}
	return ""
}

func (x *ActivityInfo) GetScheduledEventId() int64 {
	if x != nil {
		return x.ScheduledEventId
	}
	return 0
}

func (x *ActivityInfo) GetLastHeartbeatDetails() *v12.Payloads {
	if x != nil {
		return x.LastHeartbeatDetails
	}
	return nil
}

func (x *ActivityInfo) GetLastHeartbeatUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastHeartbeatUpdateTime
	}
	return nil
}

func (x *ActivityInfo) GetUseCompatibleVersion() bool {
	if x != nil {
		return x.UseCompatibleVersion
	}
	return false
}

func (x *ActivityInfo) GetActivityType() *v12.ActivityType {
	if x != nil {
		return x.ActivityType
	}
	return nil
}

func (x *ActivityInfo) GetBuildIdInfo() isActivityInfo_BuildIdInfo {
	if x != nil {
		return x.BuildIdInfo
	}
	return nil
}

func (x *ActivityInfo) GetUseWorkflowBuildIdInfo() *ActivityInfo_UseWorkflowBuildIdInfo {
	if x != nil {
		if x, ok := x.BuildIdInfo.(*ActivityInfo_UseWorkflowBuildIdInfo_); ok {
			return x.UseWorkflowBuildIdInfo
		}
	}
	return nil
}

func (x *ActivityInfo) GetLastIndependentlyAssignedBuildId() string {
	if x != nil {
		if x, ok := x.BuildIdInfo.(*ActivityInfo_LastIndependentlyAssignedBuildId); ok {
			return x.LastIndependentlyAssignedBuildId
		}
	}
	return ""
}

func (x *ActivityInfo) GetLastWorkerVersionStamp() *v12.WorkerVersionStamp {
	if x != nil {
		return x.LastWorkerVersionStamp
	}
	return nil
}

func (x *ActivityInfo) GetLastUpdateVersionedTransition() *VersionedTransition {
	if x != nil {
		return x.LastUpdateVersionedTransition
	}
	return nil
}

func (x *ActivityInfo) GetFirstScheduledTime() *timestamppb.Timestamp {
	if x != nil {
		return x.FirstScheduledTime
	}
	return nil
}

func (x *ActivityInfo) GetLastAttemptCompleteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastAttemptCompleteTime
	}
	return nil
}

func (x *ActivityInfo) GetStamp() int32 {
	if x != nil {
		return x.Stamp
	}
	return 0
}

func (x *ActivityInfo) GetPaused() bool {
	if x != nil {
		return x.Paused
	}
	return false
}

func (x *ActivityInfo) GetLastStartedDeployment() *v18.Deployment {
	if x != nil {
		return x.LastStartedDeployment
	}
	return nil
}

func (x *ActivityInfo) GetLastWorkerDeploymentVersion() string {
	if x != nil {
		return x.LastWorkerDeploymentVersion
	}
	return ""
}

func (x *ActivityInfo) GetPriority() *v12.Priority {
	if x != nil {
		return x.Priority
	}
	return nil
}

type isActivityInfo_BuildIdInfo interface {
	isActivityInfo_BuildIdInfo()
}

type ActivityInfo_UseWorkflowBuildIdInfo_ struct {
	// When present, it means this activity is assigned to the build ID of its workflow.
	// Deprecated. Clean up with versioning-2. [cleanup-old-wv]
	UseWorkflowBuildIdInfo *ActivityInfo_UseWorkflowBuildIdInfo `protobuf:"bytes,35,opt,name=use_workflow_build_id_info,json=useWorkflowBuildIdInfo,proto3,oneof"`
}

type ActivityInfo_LastIndependentlyAssignedBuildId struct {
	// This means the activity is independently versioned and not bound to the build ID of its workflow.
	// If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
	// rules. This value also updates if a redirect rule is applied to the activity task to reflect the build ID
	// of the worker who received the task.
	// Deprecated. Clean up with versioning-2. [cleanup-old-wv]
	LastIndependentlyAssignedBuildId string `protobuf:"bytes,36,opt,name=last_independently_assigned_build_id,json=lastIndependentlyAssignedBuildId,proto3,oneof"`
}

func (*ActivityInfo_UseWorkflowBuildIdInfo_) isActivityInfo_BuildIdInfo() {}

func (*ActivityInfo_LastIndependentlyAssignedBuildId) isActivityInfo_BuildIdInfo() {}

// timer_map column
type TimerInfo struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Version        int64                  `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	StartedEventId int64                  `protobuf:"varint,2,opt,name=started_event_id,json=startedEventId,proto3" json:"started_event_id,omitempty"`
	ExpiryTime     *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=expiry_time,json=expiryTime,proto3" json:"expiry_time,omitempty"`
	TaskStatus     int64                  `protobuf:"varint,4,opt,name=task_status,json=taskStatus,proto3" json:"task_status,omitempty"`
	// timerId serves the purpose of indicating whether a timer task is generated for this timer info.
	TimerId                       string               `protobuf:"bytes,5,opt,name=timer_id,json=timerId,proto3" json:"timer_id,omitempty"`
	LastUpdateVersionedTransition *VersionedTransition `protobuf:"bytes,6,opt,name=last_update_versioned_transition,json=lastUpdateVersionedTransition,proto3" json:"last_update_versioned_transition,omitempty"`
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *TimerInfo) Reset() {
	*x = TimerInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimerInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimerInfo) ProtoMessage() {}

func (x *TimerInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimerInfo.ProtoReflect.Descriptor instead.
func (*TimerInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{14}
}

func (x *TimerInfo) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *TimerInfo) GetStartedEventId() int64 {
	if x != nil {
		return x.StartedEventId
	}
	return 0
}

func (x *TimerInfo) GetExpiryTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiryTime
	}
	return nil
}

func (x *TimerInfo) GetTaskStatus() int64 {
	if x != nil {
		return x.TaskStatus
	}
	return 0
}

func (x *TimerInfo) GetTimerId() string {
	if x != nil {
		return x.TimerId
	}
	return ""
}

func (x *TimerInfo) GetLastUpdateVersionedTransition() *VersionedTransition {
	if x != nil {
		return x.LastUpdateVersionedTransition
	}
	return nil
}

// child_executions_map column
type ChildExecutionInfo struct {
	state                         protoimpl.MessageState `protogen:"open.v1"`
	Version                       int64                  `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	InitiatedEventBatchId         int64                  `protobuf:"varint,2,opt,name=initiated_event_batch_id,json=initiatedEventBatchId,proto3" json:"initiated_event_batch_id,omitempty"`
	StartedEventId                int64                  `protobuf:"varint,3,opt,name=started_event_id,json=startedEventId,proto3" json:"started_event_id,omitempty"`
	StartedWorkflowId             string                 `protobuf:"bytes,5,opt,name=started_workflow_id,json=startedWorkflowId,proto3" json:"started_workflow_id,omitempty"`
	StartedRunId                  string                 `protobuf:"bytes,6,opt,name=started_run_id,json=startedRunId,proto3" json:"started_run_id,omitempty"`
	CreateRequestId               string                 `protobuf:"bytes,8,opt,name=create_request_id,json=createRequestId,proto3" json:"create_request_id,omitempty"`
	Namespace                     string                 `protobuf:"bytes,9,opt,name=namespace,proto3" json:"namespace,omitempty"`
	WorkflowTypeName              string                 `protobuf:"bytes,10,opt,name=workflow_type_name,json=workflowTypeName,proto3" json:"workflow_type_name,omitempty"`
	ParentClosePolicy             v16.ParentClosePolicy  `protobuf:"varint,11,opt,name=parent_close_policy,json=parentClosePolicy,proto3,enum=temporal.api.enums.v1.ParentClosePolicy" json:"parent_close_policy,omitempty"`
	InitiatedEventId              int64                  `protobuf:"varint,12,opt,name=initiated_event_id,json=initiatedEventId,proto3" json:"initiated_event_id,omitempty"`
	Clock                         *v14.VectorClock       `protobuf:"bytes,13,opt,name=clock,proto3" json:"clock,omitempty"`
	NamespaceId                   string                 `protobuf:"bytes,14,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	LastUpdateVersionedTransition *VersionedTransition   `protobuf:"bytes,15,opt,name=last_update_versioned_transition,json=lastUpdateVersionedTransition,proto3" json:"last_update_versioned_transition,omitempty"`
	Priority                      *v12.Priority          `protobuf:"bytes,16,opt,name=priority,proto3" json:"priority,omitempty"`
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *ChildExecutionInfo) Reset() {
	*x = ChildExecutionInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChildExecutionInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChildExecutionInfo) ProtoMessage() {}

func (x *ChildExecutionInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChildExecutionInfo.ProtoReflect.Descriptor instead.
func (*ChildExecutionInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{15}
}

func (x *ChildExecutionInfo) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *ChildExecutionInfo) GetInitiatedEventBatchId() int64 {
	if x != nil {
		return x.InitiatedEventBatchId
	}
	return 0
}

func (x *ChildExecutionInfo) GetStartedEventId() int64 {
	if x != nil {
		return x.StartedEventId
	}
	return 0
}

func (x *ChildExecutionInfo) GetStartedWorkflowId() string {
	if x != nil {
		return x.StartedWorkflowId
	}
	return ""
}

func (x *ChildExecutionInfo) GetStartedRunId() string {
	if x != nil {
		return x.StartedRunId
	}
	return ""
}

func (x *ChildExecutionInfo) GetCreateRequestId() string {
	if x != nil {
		return x.CreateRequestId
	}
	return ""
}

func (x *ChildExecutionInfo) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *ChildExecutionInfo) GetWorkflowTypeName() string {
	if x != nil {
		return x.WorkflowTypeName
	}
	return ""
}

func (x *ChildExecutionInfo) GetParentClosePolicy() v16.ParentClosePolicy {
	if x != nil {
		return x.ParentClosePolicy
	}
	return v16.ParentClosePolicy(0)
}

func (x *ChildExecutionInfo) GetInitiatedEventId() int64 {
	if x != nil {
		return x.InitiatedEventId
	}
	return 0
}

func (x *ChildExecutionInfo) GetClock() *v14.VectorClock {
	if x != nil {
		return x.Clock
	}
	return nil
}

func (x *ChildExecutionInfo) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *ChildExecutionInfo) GetLastUpdateVersionedTransition() *VersionedTransition {
	if x != nil {
		return x.LastUpdateVersionedTransition
	}
	return nil
}

func (x *ChildExecutionInfo) GetPriority() *v12.Priority {
	if x != nil {
		return x.Priority
	}
	return nil
}

// request_cancel_map column
type RequestCancelInfo struct {
	state                         protoimpl.MessageState `protogen:"open.v1"`
	Version                       int64                  `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	InitiatedEventBatchId         int64                  `protobuf:"varint,2,opt,name=initiated_event_batch_id,json=initiatedEventBatchId,proto3" json:"initiated_event_batch_id,omitempty"`
	CancelRequestId               string                 `protobuf:"bytes,3,opt,name=cancel_request_id,json=cancelRequestId,proto3" json:"cancel_request_id,omitempty"`
	InitiatedEventId              int64                  `protobuf:"varint,4,opt,name=initiated_event_id,json=initiatedEventId,proto3" json:"initiated_event_id,omitempty"`
	LastUpdateVersionedTransition *VersionedTransition   `protobuf:"bytes,5,opt,name=last_update_versioned_transition,json=lastUpdateVersionedTransition,proto3" json:"last_update_versioned_transition,omitempty"`
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *RequestCancelInfo) Reset() {
	*x = RequestCancelInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestCancelInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestCancelInfo) ProtoMessage() {}

func (x *RequestCancelInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestCancelInfo.ProtoReflect.Descriptor instead.
func (*RequestCancelInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{16}
}

func (x *RequestCancelInfo) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *RequestCancelInfo) GetInitiatedEventBatchId() int64 {
	if x != nil {
		return x.InitiatedEventBatchId
	}
	return 0
}

func (x *RequestCancelInfo) GetCancelRequestId() string {
	if x != nil {
		return x.CancelRequestId
	}
	return ""
}

func (x *RequestCancelInfo) GetInitiatedEventId() int64 {
	if x != nil {
		return x.InitiatedEventId
	}
	return 0
}

func (x *RequestCancelInfo) GetLastUpdateVersionedTransition() *VersionedTransition {
	if x != nil {
		return x.LastUpdateVersionedTransition
	}
	return nil
}

// signal_map column
type SignalInfo struct {
	state                         protoimpl.MessageState `protogen:"open.v1"`
	Version                       int64                  `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	InitiatedEventBatchId         int64                  `protobuf:"varint,2,opt,name=initiated_event_batch_id,json=initiatedEventBatchId,proto3" json:"initiated_event_batch_id,omitempty"`
	RequestId                     string                 `protobuf:"bytes,3,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	InitiatedEventId              int64                  `protobuf:"varint,7,opt,name=initiated_event_id,json=initiatedEventId,proto3" json:"initiated_event_id,omitempty"`
	LastUpdateVersionedTransition *VersionedTransition   `protobuf:"bytes,9,opt,name=last_update_versioned_transition,json=lastUpdateVersionedTransition,proto3" json:"last_update_versioned_transition,omitempty"`
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *SignalInfo) Reset() {
	*x = SignalInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignalInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignalInfo) ProtoMessage() {}

func (x *SignalInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignalInfo.ProtoReflect.Descriptor instead.
func (*SignalInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{17}
}

func (x *SignalInfo) GetVersion() int64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *SignalInfo) GetInitiatedEventBatchId() int64 {
	if x != nil {
		return x.InitiatedEventBatchId
	}
	return 0
}

func (x *SignalInfo) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *SignalInfo) GetInitiatedEventId() int64 {
	if x != nil {
		return x.InitiatedEventId
	}
	return 0
}

func (x *SignalInfo) GetLastUpdateVersionedTransition() *VersionedTransition {
	if x != nil {
		return x.LastUpdateVersionedTransition
	}
	return nil
}

// checksum column
type Checksum struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Version       int32                  `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Flavor        v1.ChecksumFlavor      `protobuf:"varint,2,opt,name=flavor,proto3,enum=temporal.server.api.enums.v1.ChecksumFlavor" json:"flavor,omitempty"`
	Value         []byte                 `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Checksum) Reset() {
	*x = Checksum{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Checksum) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Checksum) ProtoMessage() {}

func (x *Checksum) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Checksum.ProtoReflect.Descriptor instead.
func (*Checksum) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{18}
}

func (x *Checksum) GetVersion() int32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *Checksum) GetFlavor() v1.ChecksumFlavor {
	if x != nil {
		return x.Flavor
	}
	return v1.ChecksumFlavor(0)
}

func (x *Checksum) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

type Callback struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Variant:
	//
	//	*Callback_Nexus_
	//	*Callback_Hsm
	Variant       isCallback_Variant `protobuf_oneof:"variant"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Callback) Reset() {
	*x = Callback{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Callback) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Callback) ProtoMessage() {}

func (x *Callback) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Callback.ProtoReflect.Descriptor instead.
func (*Callback) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{19}
}

func (x *Callback) GetVariant() isCallback_Variant {
	if x != nil {
		return x.Variant
	}
	return nil
}

func (x *Callback) GetNexus() *Callback_Nexus {
	if x != nil {
		if x, ok := x.Variant.(*Callback_Nexus_); ok {
			return x.Nexus
		}
	}
	return nil
}

func (x *Callback) GetHsm() *Callback_HSM {
	if x != nil {
		if x, ok := x.Variant.(*Callback_Hsm); ok {
			return x.Hsm
		}
	}
	return nil
}

type isCallback_Variant interface {
	isCallback_Variant()
}

type Callback_Nexus_ struct {
	Nexus *Callback_Nexus `protobuf:"bytes,2,opt,name=nexus,proto3,oneof"`
}

type Callback_Hsm struct {
	Hsm *Callback_HSM `protobuf:"bytes,3,opt,name=hsm,proto3,oneof"`
}

func (*Callback_Nexus_) isCallback_Variant() {}

func (*Callback_Hsm) isCallback_Variant() {}

type HSMCompletionCallbackArg struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// namespace ID of the workflow that just completed.
	NamespaceId string `protobuf:"bytes,1,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	// ID of the workflow that just completed.
	WorkflowId string `protobuf:"bytes,2,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	// run ID of the workflow that just completed.
	RunId string `protobuf:"bytes,3,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	// Last event of the completed workflow.
	LastEvent     *v19.HistoryEvent `protobuf:"bytes,4,opt,name=last_event,json=lastEvent,proto3" json:"last_event,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HSMCompletionCallbackArg) Reset() {
	*x = HSMCompletionCallbackArg{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HSMCompletionCallbackArg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HSMCompletionCallbackArg) ProtoMessage() {}

func (x *HSMCompletionCallbackArg) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HSMCompletionCallbackArg.ProtoReflect.Descriptor instead.
func (*HSMCompletionCallbackArg) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{20}
}

func (x *HSMCompletionCallbackArg) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *HSMCompletionCallbackArg) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *HSMCompletionCallbackArg) GetRunId() string {
	if x != nil {
		return x.RunId
	}
	return ""
}

func (x *HSMCompletionCallbackArg) GetLastEvent() *v19.HistoryEvent {
	if x != nil {
		return x.LastEvent
	}
	return nil
}

type CallbackInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Information on how this callback should be invoked (e.g. its URL and type).
	Callback *Callback `protobuf:"bytes,1,opt,name=callback,proto3" json:"callback,omitempty"`
	// Trigger for this callback.
	Trigger *CallbackInfo_Trigger `protobuf:"bytes,2,opt,name=trigger,proto3" json:"trigger,omitempty"`
	// The time when the callback was registered.
	RegistrationTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=registration_time,json=registrationTime,proto3" json:"registration_time,omitempty"`
	State            v1.CallbackState       `protobuf:"varint,4,opt,name=state,proto3,enum=temporal.server.api.enums.v1.CallbackState" json:"state,omitempty"`
	// The number of attempts made to deliver the callback.
	// This number represents a minimum bound since the attempt is incremented after the callback request completes.
	Attempt int32 `protobuf:"varint,5,opt,name=attempt,proto3" json:"attempt,omitempty"`
	// The time when the last attempt completed.
	LastAttemptCompleteTime *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=last_attempt_complete_time,json=lastAttemptCompleteTime,proto3" json:"last_attempt_complete_time,omitempty"`
	// The last attempt's failure, if any.
	LastAttemptFailure *v17.Failure `protobuf:"bytes,7,opt,name=last_attempt_failure,json=lastAttemptFailure,proto3" json:"last_attempt_failure,omitempty"`
	// The time when the next attempt is scheduled.
	NextAttemptScheduleTime *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=next_attempt_schedule_time,json=nextAttemptScheduleTime,proto3" json:"next_attempt_schedule_time,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *CallbackInfo) Reset() {
	*x = CallbackInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CallbackInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CallbackInfo) ProtoMessage() {}

func (x *CallbackInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CallbackInfo.ProtoReflect.Descriptor instead.
func (*CallbackInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{21}
}

func (x *CallbackInfo) GetCallback() *Callback {
	if x != nil {
		return x.Callback
	}
	return nil
}

func (x *CallbackInfo) GetTrigger() *CallbackInfo_Trigger {
	if x != nil {
		return x.Trigger
	}
	return nil
}

func (x *CallbackInfo) GetRegistrationTime() *timestamppb.Timestamp {
	if x != nil {
		return x.RegistrationTime
	}
	return nil
}

func (x *CallbackInfo) GetState() v1.CallbackState {
	if x != nil {
		return x.State
	}
	return v1.CallbackState(0)
}

func (x *CallbackInfo) GetAttempt() int32 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

func (x *CallbackInfo) GetLastAttemptCompleteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastAttemptCompleteTime
	}
	return nil
}

func (x *CallbackInfo) GetLastAttemptFailure() *v17.Failure {
	if x != nil {
		return x.LastAttemptFailure
	}
	return nil
}

func (x *CallbackInfo) GetNextAttemptScheduleTime() *timestamppb.Timestamp {
	if x != nil {
		return x.NextAttemptScheduleTime
	}
	return nil
}

// NexusOperationInfo contains the state of a nexus operation.
type NexusOperationInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Endpoint name.
	// Resolved the endpoint registry for this workflow's namespace.
	Endpoint string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Service name.
	Service string `protobuf:"bytes,2,opt,name=service,proto3" json:"service,omitempty"`
	// Operation name.
	Operation string `protobuf:"bytes,3,opt,name=operation,proto3" json:"operation,omitempty"`
	// Token for fetching the scheduled event.
	ScheduledEventToken []byte `protobuf:"bytes,5,opt,name=scheduled_event_token,json=scheduledEventToken,proto3" json:"scheduled_event_token,omitempty"`
	// Operation token. Only set for asynchronous operations after a successful StartOperation call.
	OperationToken string `protobuf:"bytes,6,opt,name=operation_token,json=operationToken,proto3" json:"operation_token,omitempty"`
	// Schedule-to-close timeout for this operation.
	// This is the only timeout settable by a workflow.
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: "since" is needed here. --)
	ScheduleToCloseTimeout *durationpb.Duration `protobuf:"bytes,7,opt,name=schedule_to_close_timeout,json=scheduleToCloseTimeout,proto3" json:"schedule_to_close_timeout,omitempty"`
	// The time when the operation was scheduled.
	ScheduledTime *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=scheduled_time,json=scheduledTime,proto3" json:"scheduled_time,omitempty"`
	// Unique request ID allocated for all retry attempts of the StartOperation request.
	RequestId string                 `protobuf:"bytes,9,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	State     v1.NexusOperationState `protobuf:"varint,10,opt,name=state,proto3,enum=temporal.server.api.enums.v1.NexusOperationState" json:"state,omitempty"`
	// The number of attempts made to deliver the start operation request.
	// This number represents a minimum bound since the attempt is incremented after the request completes.
	Attempt int32 `protobuf:"varint,11,opt,name=attempt,proto3" json:"attempt,omitempty"`
	// The time when the last attempt completed.
	LastAttemptCompleteTime *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=last_attempt_complete_time,json=lastAttemptCompleteTime,proto3" json:"last_attempt_complete_time,omitempty"`
	// The last attempt's failure, if any.
	LastAttemptFailure *v17.Failure `protobuf:"bytes,13,opt,name=last_attempt_failure,json=lastAttemptFailure,proto3" json:"last_attempt_failure,omitempty"`
	// The time when the next attempt is scheduled.
	NextAttemptScheduleTime *timestamppb.Timestamp `protobuf:"bytes,14,opt,name=next_attempt_schedule_time,json=nextAttemptScheduleTime,proto3" json:"next_attempt_schedule_time,omitempty"`
	// Endpoint ID, the name is also stored here (field 1) but we use the ID internally to avoid failing operation
	// requests when an endpoint is renamed.
	EndpointId    string `protobuf:"bytes,15,opt,name=endpoint_id,json=endpointId,proto3" json:"endpoint_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NexusOperationInfo) Reset() {
	*x = NexusOperationInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NexusOperationInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NexusOperationInfo) ProtoMessage() {}

func (x *NexusOperationInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NexusOperationInfo.ProtoReflect.Descriptor instead.
func (*NexusOperationInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{22}
}

func (x *NexusOperationInfo) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *NexusOperationInfo) GetService() string {
	if x != nil {
		return x.Service
	}
	return ""
}

func (x *NexusOperationInfo) GetOperation() string {
	if x != nil {
		return x.Operation
	}
	return ""
}

func (x *NexusOperationInfo) GetScheduledEventToken() []byte {
	if x != nil {
		return x.ScheduledEventToken
	}
	return nil
}

func (x *NexusOperationInfo) GetOperationToken() string {
	if x != nil {
		return x.OperationToken
	}
	return ""
}

func (x *NexusOperationInfo) GetScheduleToCloseTimeout() *durationpb.Duration {
	if x != nil {
		return x.ScheduleToCloseTimeout
	}
	return nil
}

func (x *NexusOperationInfo) GetScheduledTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ScheduledTime
	}
	return nil
}

func (x *NexusOperationInfo) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *NexusOperationInfo) GetState() v1.NexusOperationState {
	if x != nil {
		return x.State
	}
	return v1.NexusOperationState(0)
}

func (x *NexusOperationInfo) GetAttempt() int32 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

func (x *NexusOperationInfo) GetLastAttemptCompleteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastAttemptCompleteTime
	}
	return nil
}

func (x *NexusOperationInfo) GetLastAttemptFailure() *v17.Failure {
	if x != nil {
		return x.LastAttemptFailure
	}
	return nil
}

func (x *NexusOperationInfo) GetNextAttemptScheduleTime() *timestamppb.Timestamp {
	if x != nil {
		return x.NextAttemptScheduleTime
	}
	return nil
}

func (x *NexusOperationInfo) GetEndpointId() string {
	if x != nil {
		return x.EndpointId
	}
	return ""
}

// NexusOperationCancellationInfo contains the state of a nexus operation cancelation.
type NexusOperationCancellationInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The time when cancelation was requested.
	RequestedTime *timestamppb.Timestamp              `protobuf:"bytes,1,opt,name=requested_time,json=requestedTime,proto3" json:"requested_time,omitempty"`
	State         v16.NexusOperationCancellationState `protobuf:"varint,2,opt,name=state,proto3,enum=temporal.api.enums.v1.NexusOperationCancellationState" json:"state,omitempty"`
	// The number of attempts made to deliver the cancel operation request.
	// This number represents a minimum bound since the attempt is incremented after the request completes.
	Attempt int32 `protobuf:"varint,3,opt,name=attempt,proto3" json:"attempt,omitempty"`
	// The time when the last attempt completed.
	LastAttemptCompleteTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=last_attempt_complete_time,json=lastAttemptCompleteTime,proto3" json:"last_attempt_complete_time,omitempty"`
	// The last attempt's failure, if any.
	LastAttemptFailure *v17.Failure `protobuf:"bytes,5,opt,name=last_attempt_failure,json=lastAttemptFailure,proto3" json:"last_attempt_failure,omitempty"`
	// The time when the next attempt is scheduled.
	NextAttemptScheduleTime *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=next_attempt_schedule_time,json=nextAttemptScheduleTime,proto3" json:"next_attempt_schedule_time,omitempty"`
	// The event ID of the NEXUS_OPERATION_CANCEL_REQUESTED event for this cancelation.
	RequestedEventId int64 `protobuf:"varint,7,opt,name=requested_event_id,json=requestedEventId,proto3" json:"requested_event_id,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *NexusOperationCancellationInfo) Reset() {
	*x = NexusOperationCancellationInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NexusOperationCancellationInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NexusOperationCancellationInfo) ProtoMessage() {}

func (x *NexusOperationCancellationInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NexusOperationCancellationInfo.ProtoReflect.Descriptor instead.
func (*NexusOperationCancellationInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{23}
}

func (x *NexusOperationCancellationInfo) GetRequestedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.RequestedTime
	}
	return nil
}

func (x *NexusOperationCancellationInfo) GetState() v16.NexusOperationCancellationState {
	if x != nil {
		return x.State
	}
	return v16.NexusOperationCancellationState(0)
}

func (x *NexusOperationCancellationInfo) GetAttempt() int32 {
	if x != nil {
		return x.Attempt
	}
	return 0
}

func (x *NexusOperationCancellationInfo) GetLastAttemptCompleteTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastAttemptCompleteTime
	}
	return nil
}

func (x *NexusOperationCancellationInfo) GetLastAttemptFailure() *v17.Failure {
	if x != nil {
		return x.LastAttemptFailure
	}
	return nil
}

func (x *NexusOperationCancellationInfo) GetNextAttemptScheduleTime() *timestamppb.Timestamp {
	if x != nil {
		return x.NextAttemptScheduleTime
	}
	return nil
}

func (x *NexusOperationCancellationInfo) GetRequestedEventId() int64 {
	if x != nil {
		return x.RequestedEventId
	}
	return 0
}

// ResetChildInfo contains the state and actions to be performed on children when a parent workflow resumes after reset.
type ResetChildInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, the parent workflow should terminate the child before starting it.
	ShouldTerminateAndStart bool `protobuf:"varint,1,opt,name=should_terminate_and_start,json=shouldTerminateAndStart,proto3" json:"should_terminate_and_start,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *ResetChildInfo) Reset() {
	*x = ResetChildInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResetChildInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResetChildInfo) ProtoMessage() {}

func (x *ResetChildInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResetChildInfo.ProtoReflect.Descriptor instead.
func (*ResetChildInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{24}
}

func (x *ResetChildInfo) GetShouldTerminateAndStart() bool {
	if x != nil {
		return x.ShouldTerminateAndStart
	}
	return false
}

type TransferTaskInfo_CloseExecutionTaskDetails struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// can_skip_visibility_archival is set to true when we can guarantee that visibility records will be archived
	// by some other task, so this task doesn't need to worry about it.
	CanSkipVisibilityArchival bool `protobuf:"varint,1,opt,name=can_skip_visibility_archival,json=canSkipVisibilityArchival,proto3" json:"can_skip_visibility_archival,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *TransferTaskInfo_CloseExecutionTaskDetails) Reset() {
	*x = TransferTaskInfo_CloseExecutionTaskDetails{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransferTaskInfo_CloseExecutionTaskDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransferTaskInfo_CloseExecutionTaskDetails) ProtoMessage() {}

func (x *TransferTaskInfo_CloseExecutionTaskDetails) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransferTaskInfo_CloseExecutionTaskDetails.ProtoReflect.Descriptor instead.
func (*TransferTaskInfo_CloseExecutionTaskDetails) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{5, 0}
}

func (x *TransferTaskInfo_CloseExecutionTaskDetails) GetCanSkipVisibilityArchival() bool {
	if x != nil {
		return x.CanSkipVisibilityArchival
	}
	return false
}

// Deprecated. Clean up with versioning-2. [cleanup-old-wv]
type ActivityInfo_UseWorkflowBuildIdInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// build ID of the wf when this activity started last time (which is the build ID of
	// the worker who received this activity)
	LastUsedBuildId string `protobuf:"bytes,1,opt,name=last_used_build_id,json=lastUsedBuildId,proto3" json:"last_used_build_id,omitempty"`
	// workflows redirect_counter value when this activity started last time
	LastRedirectCounter int64 `protobuf:"varint,2,opt,name=last_redirect_counter,json=lastRedirectCounter,proto3" json:"last_redirect_counter,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *ActivityInfo_UseWorkflowBuildIdInfo) Reset() {
	*x = ActivityInfo_UseWorkflowBuildIdInfo{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ActivityInfo_UseWorkflowBuildIdInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ActivityInfo_UseWorkflowBuildIdInfo) ProtoMessage() {}

func (x *ActivityInfo_UseWorkflowBuildIdInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ActivityInfo_UseWorkflowBuildIdInfo.ProtoReflect.Descriptor instead.
func (*ActivityInfo_UseWorkflowBuildIdInfo) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{13, 0}
}

func (x *ActivityInfo_UseWorkflowBuildIdInfo) GetLastUsedBuildId() string {
	if x != nil {
		return x.LastUsedBuildId
	}
	return ""
}

func (x *ActivityInfo_UseWorkflowBuildIdInfo) GetLastRedirectCounter() int64 {
	if x != nil {
		return x.LastRedirectCounter
	}
	return 0
}

type Callback_Nexus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Callback URL.
	// (-- api-linter: core::0140::uri=disabled
	//
	//	aip.dev/not-precedent: Not respecting aip here. --)
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// Header to attach to callback request.
	Header        map[string]string `protobuf:"bytes,2,rep,name=header,proto3" json:"header,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Callback_Nexus) Reset() {
	*x = Callback_Nexus{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Callback_Nexus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Callback_Nexus) ProtoMessage() {}

func (x *Callback_Nexus) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Callback_Nexus.ProtoReflect.Descriptor instead.
func (*Callback_Nexus) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{19, 0}
}

func (x *Callback_Nexus) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *Callback_Nexus) GetHeader() map[string]string {
	if x != nil {
		return x.Header
	}
	return nil
}

type Callback_HSM struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// namespace id of the target state machine.
	NamespaceId string `protobuf:"bytes,1,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	// ID of the workflow that the target state machine is attached to.
	WorkflowId string `protobuf:"bytes,2,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	// Run id of said workflow.
	RunId string `protobuf:"bytes,3,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	// A reference to the state machine.
	Ref *StateMachineRef `protobuf:"bytes,4,opt,name=ref,proto3" json:"ref,omitempty"`
	// The method name to invoke. Methods must be explicitly registered for the target state machine in the state
	// machine registry, and accept an argument type of HistoryEvent that is the completion event of the completed
	// workflow.
	Method        string `protobuf:"bytes,5,opt,name=method,proto3" json:"method,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Callback_HSM) Reset() {
	*x = Callback_HSM{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Callback_HSM) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Callback_HSM) ProtoMessage() {}

func (x *Callback_HSM) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Callback_HSM.ProtoReflect.Descriptor instead.
func (*Callback_HSM) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{19, 1}
}

func (x *Callback_HSM) GetNamespaceId() string {
	if x != nil {
		return x.NamespaceId
	}
	return ""
}

func (x *Callback_HSM) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *Callback_HSM) GetRunId() string {
	if x != nil {
		return x.RunId
	}
	return ""
}

func (x *Callback_HSM) GetRef() *StateMachineRef {
	if x != nil {
		return x.Ref
	}
	return nil
}

func (x *Callback_HSM) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

// Trigger for when the workflow is closed.
type CallbackInfo_WorkflowClosed struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CallbackInfo_WorkflowClosed) Reset() {
	*x = CallbackInfo_WorkflowClosed{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CallbackInfo_WorkflowClosed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CallbackInfo_WorkflowClosed) ProtoMessage() {}

func (x *CallbackInfo_WorkflowClosed) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CallbackInfo_WorkflowClosed.ProtoReflect.Descriptor instead.
func (*CallbackInfo_WorkflowClosed) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{21, 0}
}

type CallbackInfo_Trigger struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Variant:
	//
	//	*CallbackInfo_Trigger_WorkflowClosed
	Variant       isCallbackInfo_Trigger_Variant `protobuf_oneof:"variant"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CallbackInfo_Trigger) Reset() {
	*x = CallbackInfo_Trigger{}
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CallbackInfo_Trigger) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CallbackInfo_Trigger) ProtoMessage() {}

func (x *CallbackInfo_Trigger) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_server_api_persistence_v1_executions_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CallbackInfo_Trigger.ProtoReflect.Descriptor instead.
func (*CallbackInfo_Trigger) Descriptor() ([]byte, []int) {
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP(), []int{21, 1}
}

func (x *CallbackInfo_Trigger) GetVariant() isCallbackInfo_Trigger_Variant {
	if x != nil {
		return x.Variant
	}
	return nil
}

func (x *CallbackInfo_Trigger) GetWorkflowClosed() *CallbackInfo_WorkflowClosed {
	if x != nil {
		if x, ok := x.Variant.(*CallbackInfo_Trigger_WorkflowClosed); ok {
			return x.WorkflowClosed
		}
	}
	return nil
}

type isCallbackInfo_Trigger_Variant interface {
	isCallbackInfo_Trigger_Variant()
}

type CallbackInfo_Trigger_WorkflowClosed struct {
	WorkflowClosed *CallbackInfo_WorkflowClosed `protobuf:"bytes,1,opt,name=workflow_closed,json=workflowClosed,proto3,oneof"`
}

func (*CallbackInfo_Trigger_WorkflowClosed) isCallbackInfo_Trigger_Variant() {}

var File_temporal_server_api_persistence_v1_executions_proto protoreflect.FileDescriptor

const file_temporal_server_api_persistence_v1_executions_proto_rawDesc = "" +
	"\n" +
	"3temporal/server/api/persistence/v1/executions.proto\x12\"temporal.server.api.persistence.v1\x1a\x1egoogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a$temporal/api/common/v1/message.proto\x1a\"temporal/api/enums/v1/common.proto\x1a&temporal/api/enums/v1/event_type.proto\x1a$temporal/api/enums/v1/workflow.proto\x1a%temporal/api/failure/v1/message.proto\x1a&temporal/api/workflow/v1/message.proto\x1a%temporal/api/history/v1/message.proto\x1a(temporal/api/deployment/v1/message.proto\x1a*temporal/server/api/clock/v1/message.proto\x1a)temporal/server/api/enums/v1/common.proto\x1a(temporal/server/api/enums/v1/nexus.proto\x1a+temporal/server/api/enums/v1/workflow.proto\x1a'temporal/server/api/enums/v1/task.proto\x1a5temporal/server/api/enums/v1/workflow_task_type.proto\x1a,temporal/server/api/history/v1/message.proto\x1a.temporal/server/api/persistence/v1/chasm.proto\x1a/temporal/server/api/persistence/v1/queues.proto\x1a,temporal/server/api/persistence/v1/hsm.proto\x1a/temporal/server/api/persistence/v1/update.proto\x1a-temporal/server/api/workflow/v1/message.proto\"\xa3\x05\n" +
	"\tShardInfo\x12\x19\n" +
	"\bshard_id\x18\x01 \x01(\x05R\ashardId\x12\x19\n" +
	"\brange_id\x18\x02 \x01(\x03R\arangeId\x12\x14\n" +
	"\x05owner\x18\x03 \x01(\tR\x05owner\x12,\n" +
	"\x12stolen_since_renew\x18\x06 \x01(\x05R\x10stolenSinceRenew\x12;\n" +
	"\vupdate_time\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"updateTime\x12\x84\x01\n" +
	"\x19replication_dlq_ack_level\x18\r \x03(\v2I.temporal.server.api.persistence.v1.ShardInfo.ReplicationDlqAckLevelEntryR\x16replicationDlqAckLevel\x12a\n" +
	"\fqueue_states\x18\x11 \x03(\v2>.temporal.server.api.persistence.v1.ShardInfo.QueueStatesEntryR\vqueueStates\x1aI\n" +
	"\x1bReplicationDlqAckLevelEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\x1an\n" +
	"\x10QueueStatesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x12D\n" +
	"\x05value\x18\x02 \x01(\v2..temporal.server.api.persistence.v1.QueueStateR\x05value:\x028\x01J\x04\b\x04\x10\x05J\x04\b\x05\x10\x06J\x04\b\b\x10\tJ\x04\b\t\x10\n" +
	"J\x04\b\n" +
	"\x10\vJ\x04\b\v\x10\fJ\x04\b\f\x10\rJ\x04\b\x0e\x10\x0fJ\x04\b\x0f\x10\x10J\x04\b\x10\x10\x11\"\xc6:\n" +
	"\x15WorkflowExecutionInfo\x12!\n" +
	"\fnamespace_id\x18\x01 \x01(\tR\vnamespaceId\x12\x1f\n" +
	"\vworkflow_id\x18\x02 \x01(\tR\n" +
	"workflowId\x12.\n" +
	"\x13parent_namespace_id\x18\x03 \x01(\tR\x11parentNamespaceId\x12,\n" +
	"\x12parent_workflow_id\x18\x04 \x01(\tR\x10parentWorkflowId\x12\"\n" +
	"\rparent_run_id\x18\x05 \x01(\tR\vparentRunId\x12.\n" +
	"\x13parent_initiated_id\x18\x06 \x01(\x03R\x11parentInitiatedId\x129\n" +
	"\x19completion_event_batch_id\x18\a \x01(\x03R\x16completionEventBatchId\x12\x1d\n" +
	"\n" +
	"task_queue\x18\t \x01(\tR\ttaskQueue\x12,\n" +
	"\x12workflow_type_name\x18\n" +
	" \x01(\tR\x10workflowTypeName\x12W\n" +
	"\x1aworkflow_execution_timeout\x18\v \x01(\v2\x19.google.protobuf.DurationR\x18workflowExecutionTimeout\x12K\n" +
	"\x14workflow_run_timeout\x18\f \x01(\v2\x19.google.protobuf.DurationR\x12workflowRunTimeout\x12\\\n" +
	"\x1ddefault_workflow_task_timeout\x18\r \x01(\v2\x19.google.protobuf.DurationR\x1adefaultWorkflowTaskTimeout\x12+\n" +
	"\x12last_event_task_id\x18\x11 \x01(\x03R\x0flastEventTaskId\x12-\n" +
	"\x13last_first_event_id\x18\x12 \x01(\x03R\x10lastFirstEventId\x12^\n" +
	"-last_completed_workflow_task_started_event_id\x18\x13 \x01(\x03R'lastCompletedWorkflowTaskStartedEventId\x129\n" +
	"\n" +
	"start_time\x18\x14 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x12D\n" +
	"\x10last_update_time\x18\x15 \x01(\v2\x1a.google.protobuf.TimestampR\x0elastUpdateTime\x122\n" +
	"\x15workflow_task_version\x18\x16 \x01(\x03R\x13workflowTaskVersion\x12F\n" +
	" workflow_task_scheduled_event_id\x18\x17 \x01(\x03R\x1cworkflowTaskScheduledEventId\x12B\n" +
	"\x1eworkflow_task_started_event_id\x18\x18 \x01(\x03R\x1aworkflowTaskStartedEventId\x12M\n" +
	"\x15workflow_task_timeout\x18\x19 \x01(\v2\x19.google.protobuf.DurationR\x13workflowTaskTimeout\x122\n" +
	"\x15workflow_task_attempt\x18\x1a \x01(\x05R\x13workflowTaskAttempt\x12W\n" +
	"\x1aworkflow_task_started_time\x18\x1b \x01(\v2\x1a.google.protobuf.TimestampR\x17workflowTaskStartedTime\x12[\n" +
	"\x1cworkflow_task_scheduled_time\x18\x1c \x01(\v2\x1a.google.protobuf.TimestampR\x19workflowTaskScheduledTime\x12l\n" +
	"%workflow_task_original_scheduled_time\x18\x1e \x01(\v2\x1a.google.protobuf.TimestampR!workflowTaskOriginalScheduledTime\x127\n" +
	"\x18workflow_task_request_id\x18\x1f \x01(\tR\x15workflowTaskRequestId\x12\\\n" +
	"\x12workflow_task_type\x18D \x01(\x0e2..temporal.server.api.enums.v1.WorkflowTaskTypeR\x10workflowTaskType\x12O\n" +
	"%workflow_task_suggest_continue_as_new\x18E \x01(\bR workflowTaskSuggestContinueAsNew\x12F\n" +
	" workflow_task_history_size_bytes\x18F \x01(\x03R\x1cworkflowTaskHistorySizeBytes\x123\n" +
	"\x16workflow_task_build_id\x18X \x01(\tR\x13workflowTaskBuildId\x12S\n" +
	"'workflow_task_build_id_redirect_counter\x18Y \x01(\x03R\"workflowTaskBuildIdRedirectCounter\x12)\n" +
	"\x10cancel_requested\x18\x1d \x01(\bR\x0fcancelRequested\x12*\n" +
	"\x11cancel_request_id\x18  \x01(\tR\x0fcancelRequestId\x12*\n" +
	"\x11sticky_task_queue\x18! \x01(\tR\x0fstickyTaskQueue\x12a\n" +
	" sticky_schedule_to_start_timeout\x18\" \x01(\v2\x19.google.protobuf.DurationR\x1cstickyScheduleToStartTimeout\x12\x18\n" +
	"\aattempt\x18# \x01(\x05R\aattempt\x12O\n" +
	"\x16retry_initial_interval\x18$ \x01(\v2\x19.google.protobuf.DurationR\x14retryInitialInterval\x12O\n" +
	"\x16retry_maximum_interval\x18% \x01(\v2\x19.google.protobuf.DurationR\x14retryMaximumInterval\x124\n" +
	"\x16retry_maximum_attempts\x18& \x01(\x05R\x14retryMaximumAttempts\x12:\n" +
	"\x19retry_backoff_coefficient\x18' \x01(\x01R\x17retryBackoffCoefficient\x12g\n" +
	"\"workflow_execution_expiration_time\x18( \x01(\v2\x1a.google.protobuf.TimestampR\x1fworkflowExecutionExpirationTime\x12D\n" +
	"\x1fretry_non_retryable_error_types\x18) \x03(\tR\x1bretryNonRetryableErrorTypes\x12(\n" +
	"\x10has_retry_policy\x18* \x01(\bR\x0ehasRetryPolicy\x12#\n" +
	"\rcron_schedule\x18+ \x01(\tR\fcronSchedule\x12!\n" +
	"\fsignal_count\x18. \x01(\x03R\vsignalCount\x12%\n" +
	"\x0eactivity_count\x18G \x01(\x03R\ractivityCount\x122\n" +
	"\x15child_execution_count\x18H \x01(\x03R\x13childExecutionCount\x12(\n" +
	"\x10user_timer_count\x18I \x01(\x03R\x0euserTimerCount\x12A\n" +
	"\x1drequest_cancel_external_count\x18J \x01(\x03R\x1arequestCancelExternalCount\x122\n" +
	"\x15signal_external_count\x18K \x01(\x03R\x13signalExternalCount\x12!\n" +
	"\fupdate_count\x18M \x01(\x03R\vupdateCount\x12Q\n" +
	"\x11auto_reset_points\x183 \x01(\v2%.temporal.api.workflow.v1.ResetPointsR\x0fautoResetPoints\x12|\n" +
	"\x11search_attributes\x184 \x03(\v2O.temporal.server.api.persistence.v1.WorkflowExecutionInfo.SearchAttributesEntryR\x10searchAttributes\x12W\n" +
	"\x04memo\x185 \x03(\v2C.temporal.server.api.persistence.v1.WorkflowExecutionInfo.MemoEntryR\x04memo\x12]\n" +
	"\x11version_histories\x186 \x01(\v20.temporal.server.api.history.v1.VersionHistoriesR\x10versionHistories\x123\n" +
	"\x16first_execution_run_id\x187 \x01(\tR\x13firstExecutionRunId\x12[\n" +
	"\x0fexecution_stats\x188 \x01(\v22.temporal.server.api.persistence.v1.ExecutionStatsR\x0eexecutionStats\x12[\n" +
	"\x1cworkflow_run_expiration_time\x189 \x01(\v2\x1a.google.protobuf.TimestampR\x19workflowRunExpirationTime\x124\n" +
	"\x17last_first_event_txn_id\x18: \x01(\x03R\x13lastFirstEventTxnId\x124\n" +
	"\x16state_transition_count\x18; \x01(\x03R\x14stateTransitionCount\x12A\n" +
	"\x0eexecution_time\x18< \x01(\v2\x1a.google.protobuf.TimestampR\rexecutionTime\x12/\n" +
	"\x14new_execution_run_id\x18= \x01(\tR\x11newExecutionRunId\x12L\n" +
	"\fparent_clock\x18> \x01(\v2).temporal.server.api.clock.v1.VectorClockR\vparentClock\x128\n" +
	"\x18parent_initiated_version\x18? \x01(\x03R\x16parentInitiatedVersion\x123\n" +
	"\x16close_transfer_task_id\x18@ \x01(\x03R\x13closeTransferTaskId\x127\n" +
	"\x18close_visibility_task_id\x18A \x01(\x03R\x15closeVisibilityTaskId\x129\n" +
	"\n" +
	"close_time\x18B \x01(\v2\x1a.google.protobuf.TimestampR\tcloseTime\x12D\n" +
	"\x1erelocatable_attributes_removed\x18C \x01(\bR\x1crelocatableAttributesRemoved\x12b\n" +
	"\x13base_execution_info\x18L \x01(\v22.temporal.server.api.workflow.v1.BaseExecutionInfoR\x11baseExecutionInfo\x12r\n" +
	" most_recent_worker_version_stamp\x18N \x01(\v2*.temporal.api.common.v1.WorkerVersionStampR\x1cmostRecentWorkerVersionStamp\x12*\n" +
	"\x11assigned_build_id\x18U \x01(\tR\x0fassignedBuildId\x12,\n" +
	"\x12inherited_build_id\x18V \x01(\tR\x10inheritedBuildId\x129\n" +
	"\x19build_id_redirect_counter\x18W \x01(\x03R\x16buildIdRedirectCounter\x12m\n" +
	"\fupdate_infos\x18O \x03(\v2J.temporal.server.api.persistence.v1.WorkflowExecutionInfo.UpdateInfosEntryR\vupdateInfos\x12f\n" +
	"\x12transition_history\x18P \x03(\v27.temporal.server.api.persistence.v1.VersionedTransitionR\x11transitionHistory\x12\x91\x01\n" +
	"\x1asub_state_machines_by_type\x18Q \x03(\v2U.temporal.server.api.persistence.v1.WorkflowExecutionInfo.SubStateMachinesByTypeEntryR\x16subStateMachinesByType\x12N\n" +
	"$workflow_execution_timer_task_status\x18R \x01(\x05R workflowExecutionTimerTaskStatus\x12(\n" +
	"\x10root_workflow_id\x18S \x01(\tR\x0erootWorkflowId\x12\x1e\n" +
	"\vroot_run_id\x18T \x01(\tR\trootRunId\x12l\n" +
	"\x14state_machine_timers\x18Z \x03(\v2:.temporal.server.api.persistence.v1.StateMachineTimerGroupR\x12stateMachineTimers\x12P\n" +
	"%task_generation_shard_clock_timestamp\x18[ \x01(\x03R!taskGenerationShardClockTimestamp\x12\x9a\x01\n" +
	".workflow_task_last_update_versioned_transition\x18\\ \x01(\v27.temporal.server.api.persistence.v1.VersionedTransitionR)workflowTaskLastUpdateVersionedTransition\x12\x95\x01\n" +
	"+visibility_last_update_versioned_transition\x18] \x01(\v27.temporal.server.api.persistence.v1.VersionedTransitionR'visibilityLastUpdateVersionedTransition\x12\xa3\x01\n" +
	"3signal_request_ids_last_update_versioned_transition\x18^ \x01(\v27.temporal.server.api.persistence.v1.VersionedTransitionR-signalRequestIdsLastUpdateVersionedTransition\x12\x8c\x01\n" +
	"#sub_state_machine_tombstone_batches\x18_ \x03(\v2>.temporal.server.api.persistence.v1.StateMachineTombstoneBatchR\x1fsubStateMachineTombstoneBatches\x12,\n" +
	"\x12workflow_was_reset\x18` \x01(\bR\x10workflowWasReset\x12 \n" +
	"\freset_run_id\x18a \x01(\tR\n" +
	"resetRunId\x12b\n" +
	"\x0fversioning_info\x18b \x01(\v29.temporal.api.workflow.v1.WorkflowExecutionVersioningInfoR\x0eversioningInfo\x129\n" +
	"\x19original_execution_run_id\x18c \x01(\tR\x16originalExecutionRunId\x12w\n" +
	"\x1bprevious_transition_history\x18d \x03(\v27.temporal.server.api.persistence.v1.VersionedTransitionR\x19previousTransitionHistory\x12\x85\x01\n" +
	"#last_transition_history_break_point\x18e \x01(\v27.temporal.server.api.persistence.v1.VersionedTransitionR\x1flastTransitionHistoryBreakPoint\x12\xb2\x01\n" +
	"%children_initialized_post_reset_point\x18f \x03(\v2`.temporal.server.api.persistence.v1.WorkflowExecutionInfo.ChildrenInitializedPostResetPointEntryR!childrenInitializedPostResetPoint\x124\n" +
	"\x16worker_deployment_name\x18g \x01(\tR\x14workerDeploymentName\x12<\n" +
	"\bpriority\x18h \x01(\v2 .temporal.api.common.v1.PriorityR\bpriority\x1ad\n" +
	"\x15SearchAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x05value:\x028\x01\x1aX\n" +
	"\tMemoEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x05value:\x028\x01\x1an\n" +
	"\x10UpdateInfosEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12D\n" +
	"\x05value\x18\x02 \x01(\v2..temporal.server.api.persistence.v1.UpdateInfoR\x05value:\x028\x01\x1a~\n" +
	"\x1bSubStateMachinesByTypeEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12I\n" +
	"\x05value\x18\x02 \x01(\v23.temporal.server.api.persistence.v1.StateMachineMapR\x05value:\x028\x01\x1a\x88\x01\n" +
	"&ChildrenInitializedPostResetPointEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12H\n" +
	"\x05value\x18\x02 \x01(\v22.temporal.server.api.persistence.v1.ResetChildInfoR\x05value:\x028\x01J\x04\b\b\x10\tJ\x04\b\x0e\x10\x0fJ\x04\b\x0f\x10\x10J\x04\b\x10\x10\x11J\x04\b,\x10-J\x04\b-\x10.J\x04\b/\x100J\x04\b0\x101J\x04\b1\x102J\x04\b2\x103\"3\n" +
	"\x0eExecutionStats\x12!\n" +
	"\fhistory_size\x18\x01 \x01(\x03R\vhistorySize\"\x8c\x05\n" +
	"\x16WorkflowExecutionState\x12*\n" +
	"\x11create_request_id\x18\x01 \x01(\tR\x0fcreateRequestId\x12\x15\n" +
	"\x06run_id\x18\x02 \x01(\tR\x05runId\x12J\n" +
	"\x05state\x18\x03 \x01(\x0e24.temporal.server.api.enums.v1.WorkflowExecutionStateR\x05state\x12F\n" +
	"\x06status\x18\x04 \x01(\x0e2..temporal.api.enums.v1.WorkflowExecutionStatusR\x06status\x12\x80\x01\n" +
	" last_update_versioned_transition\x18\x05 \x01(\v27.temporal.server.api.persistence.v1.VersionedTransitionR\x1dlastUpdateVersionedTransition\x129\n" +
	"\n" +
	"start_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x12k\n" +
	"\vrequest_ids\x18\a \x03(\v2J.temporal.server.api.persistence.v1.WorkflowExecutionState.RequestIdsEntryR\n" +
	"requestIds\x1ap\n" +
	"\x0fRequestIdsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12G\n" +
	"\x05value\x18\x02 \x01(\v21.temporal.server.api.persistence.v1.RequestIDInfoR\x05value:\x028\x01\"P\n" +
	"\rRequestIDInfo\x12?\n" +
	"\n" +
	"event_type\x18\x01 \x01(\x0e2 .temporal.api.enums.v1.EventTypeR\teventType\"\xdf\a\n" +
	"\x10TransferTaskInfo\x12!\n" +
	"\fnamespace_id\x18\x01 \x01(\tR\vnamespaceId\x12\x1f\n" +
	"\vworkflow_id\x18\x02 \x01(\tR\n" +
	"workflowId\x12\x15\n" +
	"\x06run_id\x18\x03 \x01(\tR\x05runId\x12C\n" +
	"\ttask_type\x18\x04 \x01(\x0e2&.temporal.server.api.enums.v1.TaskTypeR\btaskType\x12.\n" +
	"\x13target_namespace_id\x18\x05 \x01(\tR\x11targetNamespaceId\x12,\n" +
	"\x12target_workflow_id\x18\x06 \x01(\tR\x10targetWorkflowId\x12\"\n" +
	"\rtarget_run_id\x18\a \x01(\tR\vtargetRunId\x12\x1d\n" +
	"\n" +
	"task_queue\x18\b \x01(\tR\ttaskQueue\x12;\n" +
	"\x1atarget_child_workflow_only\x18\t \x01(\bR\x17targetChildWorkflowOnly\x12,\n" +
	"\x12scheduled_event_id\x18\n" +
	" \x01(\x03R\x10scheduledEventId\x12\x18\n" +
	"\aversion\x18\v \x01(\x03R\aversion\x12\x17\n" +
	"\atask_id\x18\f \x01(\x03R\x06taskId\x12C\n" +
	"\x0fvisibility_time\x18\r \x01(\v2\x1a.google.protobuf.TimestampR\x0evisibilityTime\x12,\n" +
	"\x12delete_after_close\x18\x0f \x01(\bR\x10deleteAfterClose\x12\x91\x01\n" +
	"\x1cclose_execution_task_details\x18\x10 \x01(\v2N.temporal.server.api.persistence.v1.TransferTaskInfo.CloseExecutionTaskDetailsH\x00R\x19closeExecutionTaskDetails\x12[\n" +
	"\x0fchasm_task_info\x18\x12 \x01(\v21.temporal.server.api.persistence.v1.ChasmTaskInfoH\x00R\rchasmTaskInfo\x12\x14\n" +
	"\x05stamp\x18\x11 \x01(\x05R\x05stamp\x1a\\\n" +
	"\x19CloseExecutionTaskDetails\x12?\n" +
	"\x1ccan_skip_visibility_archival\x18\x01 \x01(\bR\x19canSkipVisibilityArchivalB\x0e\n" +
	"\ftask_detailsJ\x04\b\x0e\x10\x0f\"\xb6\a\n" +
	"\x13ReplicationTaskInfo\x12!\n" +
	"\fnamespace_id\x18\x01 \x01(\tR\vnamespaceId\x12\x1f\n" +
	"\vworkflow_id\x18\x02 \x01(\tR\n" +
	"workflowId\x12\x15\n" +
	"\x06run_id\x18\x03 \x01(\tR\x05runId\x12C\n" +
	"\ttask_type\x18\x04 \x01(\x0e2&.temporal.server.api.enums.v1.TaskTypeR\btaskType\x12\x18\n" +
	"\aversion\x18\x05 \x01(\x03R\aversion\x12$\n" +
	"\x0efirst_event_id\x18\x06 \x01(\x03R\ffirstEventId\x12\"\n" +
	"\rnext_event_id\x18\a \x01(\x03R\vnextEventId\x12,\n" +
	"\x12scheduled_event_id\x18\b \x01(\x03R\x10scheduledEventId\x12!\n" +
	"\fbranch_token\x18\v \x01(\fR\vbranchToken\x12/\n" +
	"\x14new_run_branch_token\x18\r \x01(\fR\x11newRunBranchToken\x12\x17\n" +
	"\atask_id\x18\x0f \x01(\x03R\x06taskId\x12C\n" +
	"\x0fvisibility_time\x18\x10 \x01(\v2\x1a.google.protobuf.TimestampR\x0evisibilityTime\x12\x1c\n" +
	"\n" +
	"new_run_id\x18\x11 \x01(\tR\bnewRunId\x12F\n" +
	"\bpriority\x18\x12 \x01(\x0e2*.temporal.server.api.enums.v1.TaskPriorityR\bpriority\x12j\n" +
	"\x14versioned_transition\x18\x13 \x01(\v27.temporal.server.api.persistence.v1.VersionedTransitionR\x13versionedTransition\x12b\n" +
	"\x10task_equivalents\x18\x14 \x03(\v27.temporal.server.api.persistence.v1.ReplicationTaskInfoR\x0ftaskEquivalents\x12m\n" +
	"\x19last_version_history_item\x18\x15 \x01(\v22.temporal.server.api.history.v1.VersionHistoryItemR\x16lastVersionHistoryItemJ\x04\b\t\x10\n" +
	"J\x04\b\n" +
	"\x10\vJ\x04\b\f\x10\rJ\x04\b\x0e\x10\x0f\"\xac\x03\n" +
	"\x12VisibilityTaskInfo\x12!\n" +
	"\fnamespace_id\x18\x01 \x01(\tR\vnamespaceId\x12\x1f\n" +
	"\vworkflow_id\x18\x02 \x01(\tR\n" +
	"workflowId\x12\x15\n" +
	"\x06run_id\x18\x03 \x01(\tR\x05runId\x12C\n" +
	"\ttask_type\x18\x04 \x01(\x0e2&.temporal.server.api.enums.v1.TaskTypeR\btaskType\x12\x18\n" +
	"\aversion\x18\x05 \x01(\x03R\aversion\x12\x17\n" +
	"\atask_id\x18\x06 \x01(\x03R\x06taskId\x12C\n" +
	"\x0fvisibility_time\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\x0evisibilityTime\x127\n" +
	"\x18close_visibility_task_id\x18\n" +
	" \x01(\x03R\x15closeVisibilityTaskId\x129\n" +
	"\n" +
	"close_time\x18\v \x01(\v2\x1a.google.protobuf.TimestampR\tcloseTimeJ\x04\b\b\x10\tJ\x04\b\t\x10\n" +
	"\"\xd3\x06\n" +
	"\rTimerTaskInfo\x12!\n" +
	"\fnamespace_id\x18\x01 \x01(\tR\vnamespaceId\x12\x1f\n" +
	"\vworkflow_id\x18\x02 \x01(\tR\n" +
	"workflowId\x12\x15\n" +
	"\x06run_id\x18\x03 \x01(\tR\x05runId\x12C\n" +
	"\ttask_type\x18\x04 \x01(\x0e2&.temporal.server.api.enums.v1.TaskTypeR\btaskType\x12E\n" +
	"\ftimeout_type\x18\x05 \x01(\x0e2\".temporal.api.enums.v1.TimeoutTypeR\vtimeoutType\x12e\n" +
	"\x15workflow_backoff_type\x18\x06 \x01(\x0e21.temporal.server.api.enums.v1.WorkflowBackoffTypeR\x13workflowBackoffType\x12\x18\n" +
	"\aversion\x18\a \x01(\x03R\aversion\x12)\n" +
	"\x10schedule_attempt\x18\b \x01(\x05R\x0fscheduleAttempt\x12\x19\n" +
	"\bevent_id\x18\t \x01(\x03R\aeventId\x12\x17\n" +
	"\atask_id\x18\n" +
	" \x01(\x03R\x06taskId\x12C\n" +
	"\x0fvisibility_time\x18\v \x01(\v2\x1a.google.protobuf.TimestampR\x0evisibilityTime\x12!\n" +
	"\fbranch_token\x18\f \x01(\fR\vbranchToken\x12)\n" +
	"\x10already_archived\x18\r \x01(\bR\x0falreadyArchived\x12C\n" +
	"\x1emutable_state_transition_count\x18\x0e \x01(\x03R\x1bmutableStateTransitionCount\x12 \n" +
	"\ffirst_run_id\x18\x0f \x01(\tR\n" +
	"firstRunId\x12\x14\n" +
	"\x05stamp\x18\x10 \x01(\x05R\x05stamp\x12[\n" +
	"\x0fchasm_task_info\x18\x11 \x01(\v21.temporal.server.api.persistence.v1.ChasmTaskInfoH\x00R\rchasmTaskInfoB\x0e\n" +
	"\ftask_details\"\xaa\x02\n" +
	"\x10ArchivalTaskInfo\x12\x17\n" +
	"\atask_id\x18\x01 \x01(\x03R\x06taskId\x12!\n" +
	"\fnamespace_id\x18\x02 \x01(\tR\vnamespaceId\x12\x1f\n" +
	"\vworkflow_id\x18\x03 \x01(\tR\n" +
	"workflowId\x12\x15\n" +
	"\x06run_id\x18\x04 \x01(\tR\x05runId\x12C\n" +
	"\ttask_type\x18\x05 \x01(\x0e2&.temporal.server.api.enums.v1.TaskTypeR\btaskType\x12\x18\n" +
	"\aversion\x18\x06 \x01(\x03R\aversion\x12C\n" +
	"\x0fvisibility_time\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\x0evisibilityTime\"\x89\x04\n" +
	"\x10OutboundTaskInfo\x12!\n" +
	"\fnamespace_id\x18\x01 \x01(\tR\vnamespaceId\x12\x1f\n" +
	"\vworkflow_id\x18\x02 \x01(\tR\n" +
	"workflowId\x12\x15\n" +
	"\x06run_id\x18\x03 \x01(\tR\x05runId\x12C\n" +
	"\ttask_type\x18\x04 \x01(\x0e2&.temporal.server.api.enums.v1.TaskTypeR\btaskType\x12\x17\n" +
	"\atask_id\x18\x05 \x01(\x03R\x06taskId\x12C\n" +
	"\x0fvisibility_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\x0evisibilityTime\x12 \n" +
	"\vdestination\x18\a \x01(\tR\vdestination\x12h\n" +
	"\x12state_machine_info\x18\b \x01(\v28.temporal.server.api.persistence.v1.StateMachineTaskInfoH\x00R\x10stateMachineInfo\x12[\n" +
	"\x0fchasm_task_info\x18\t \x01(\v21.temporal.server.api.persistence.v1.ChasmTaskInfoH\x00R\rchasmTaskInfoB\x0e\n" +
	"\ftask_details\"3\n" +
	"\x17NexusInvocationTaskInfo\x12\x18\n" +
	"\aattempt\x18\x01 \x01(\x05R\aattempt\"4\n" +
	"\x18NexusCancelationTaskInfo\x12\x18\n" +
	"\aattempt\x18\x01 \x01(\x05R\aattempt\"\xd3\x16\n" +
	"\fActivityInfo\x12\x18\n" +
	"\aversion\x18\x01 \x01(\x03R\aversion\x127\n" +
	"\x18scheduled_event_batch_id\x18\x02 \x01(\x03R\x15scheduledEventBatchId\x12A\n" +
	"\x0escheduled_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\rscheduledTime\x12(\n" +
	"\x10started_event_id\x18\x05 \x01(\x03R\x0estartedEventId\x12=\n" +
	"\fstarted_time\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\vstartedTime\x12\x1f\n" +
	"\vactivity_id\x18\b \x01(\tR\n" +
	"activityId\x12\x1d\n" +
	"\n" +
	"request_id\x18\t \x01(\tR\trequestId\x12T\n" +
	"\x19schedule_to_start_timeout\x18\n" +
	" \x01(\v2\x19.google.protobuf.DurationR\x16scheduleToStartTimeout\x12T\n" +
	"\x19schedule_to_close_timeout\x18\v \x01(\v2\x19.google.protobuf.DurationR\x16scheduleToCloseTimeout\x12N\n" +
	"\x16start_to_close_timeout\x18\f \x01(\v2\x19.google.protobuf.DurationR\x13startToCloseTimeout\x12F\n" +
	"\x11heartbeat_timeout\x18\r \x01(\v2\x19.google.protobuf.DurationR\x10heartbeatTimeout\x12)\n" +
	"\x10cancel_requested\x18\x0e \x01(\bR\x0fcancelRequested\x12*\n" +
	"\x11cancel_request_id\x18\x0f \x01(\x03R\x0fcancelRequestId\x12*\n" +
	"\x11timer_task_status\x18\x10 \x01(\x05R\x0ftimerTaskStatus\x12\x18\n" +
	"\aattempt\x18\x11 \x01(\x05R\aattempt\x12\x1d\n" +
	"\n" +
	"task_queue\x18\x12 \x01(\tR\ttaskQueue\x12)\n" +
	"\x10started_identity\x18\x13 \x01(\tR\x0fstartedIdentity\x12(\n" +
	"\x10has_retry_policy\x18\x14 \x01(\bR\x0ehasRetryPolicy\x12O\n" +
	"\x16retry_initial_interval\x18\x15 \x01(\v2\x19.google.protobuf.DurationR\x14retryInitialInterval\x12O\n" +
	"\x16retry_maximum_interval\x18\x16 \x01(\v2\x19.google.protobuf.DurationR\x14retryMaximumInterval\x124\n" +
	"\x16retry_maximum_attempts\x18\x17 \x01(\x05R\x14retryMaximumAttempts\x12N\n" +
	"\x15retry_expiration_time\x18\x18 \x01(\v2\x1a.google.protobuf.TimestampR\x13retryExpirationTime\x12:\n" +
	"\x19retry_backoff_coefficient\x18\x19 \x01(\x01R\x17retryBackoffCoefficient\x12D\n" +
	"\x1fretry_non_retryable_error_types\x18\x1a \x03(\tR\x1bretryNonRetryableErrorTypes\x12N\n" +
	"\x12retry_last_failure\x18\x1b \x01(\v2 .temporal.api.failure.v1.FailureR\x10retryLastFailure\x12;\n" +
	"\x1aretry_last_worker_identity\x18\x1c \x01(\tR\x17retryLastWorkerIdentity\x12,\n" +
	"\x12scheduled_event_id\x18\x1e \x01(\x03R\x10scheduledEventId\x12V\n" +
	"\x16last_heartbeat_details\x18\x1f \x01(\v2 .temporal.api.common.v1.PayloadsR\x14lastHeartbeatDetails\x12W\n" +
	"\x1alast_heartbeat_update_time\x18  \x01(\v2\x1a.google.protobuf.TimestampR\x17lastHeartbeatUpdateTime\x124\n" +
	"\x16use_compatible_version\x18! \x01(\bR\x14useCompatibleVersion\x12I\n" +
	"\ractivity_type\x18\" \x01(\v2$.temporal.api.common.v1.ActivityTypeR\factivityType\x12\x85\x01\n" +
	"\x1ause_workflow_build_id_info\x18# \x01(\v2G.temporal.server.api.persistence.v1.ActivityInfo.UseWorkflowBuildIdInfoH\x00R\x16useWorkflowBuildIdInfo\x12P\n" +
	"$last_independently_assigned_build_id\x18$ \x01(\tH\x00R lastIndependentlyAssignedBuildId\x12e\n" +
	"\x19last_worker_version_stamp\x18% \x01(\v2*.temporal.api.common.v1.WorkerVersionStampR\x16lastWorkerVersionStamp\x12\x80\x01\n" +
	" last_update_versioned_transition\x18& \x01(\v27.temporal.server.api.persistence.v1.VersionedTransitionR\x1dlastUpdateVersionedTransition\x12L\n" +
	"\x14first_scheduled_time\x18' \x01(\v2\x1a.google.protobuf.TimestampR\x12firstScheduledTime\x12W\n" +
	"\x1alast_attempt_complete_time\x18( \x01(\v2\x1a.google.protobuf.TimestampR\x17lastAttemptCompleteTime\x12\x14\n" +
	"\x05stamp\x18) \x01(\x05R\x05stamp\x12\x16\n" +
	"\x06paused\x18* \x01(\bR\x06paused\x12^\n" +
	"\x17last_started_deployment\x18+ \x01(\v2&.temporal.api.deployment.v1.DeploymentR\x15lastStartedDeployment\x12C\n" +
	"\x1elast_worker_deployment_version\x18, \x01(\tR\x1blastWorkerDeploymentVersion\x12<\n" +
	"\bpriority\x18- \x01(\v2 .temporal.api.common.v1.PriorityR\bpriority\x1ay\n" +
	"\x16UseWorkflowBuildIdInfo\x12+\n" +
	"\x12last_used_build_id\x18\x01 \x01(\tR\x0flastUsedBuildId\x122\n" +
	"\x15last_redirect_counter\x18\x02 \x01(\x03R\x13lastRedirectCounterB\x0f\n" +
	"\rbuild_id_infoJ\x04\b\x03\x10\x04J\x04\b\x06\x10\aJ\x04\b\x1d\x10\x1e\"\xcb\x02\n" +
	"\tTimerInfo\x12\x18\n" +
	"\aversion\x18\x01 \x01(\x03R\aversion\x12(\n" +
	"\x10started_event_id\x18\x02 \x01(\x03R\x0estartedEventId\x12;\n" +
	"\vexpiry_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"expiryTime\x12\x1f\n" +
	"\vtask_status\x18\x04 \x01(\x03R\n" +
	"taskStatus\x12\x19\n" +
	"\btimer_id\x18\x05 \x01(\tR\atimerId\x12\x80\x01\n" +
	" last_update_versioned_transition\x18\x06 \x01(\v27.temporal.server.api.persistence.v1.VersionedTransitionR\x1dlastUpdateVersionedTransition\"\x98\x06\n" +
	"\x12ChildExecutionInfo\x12\x18\n" +
	"\aversion\x18\x01 \x01(\x03R\aversion\x127\n" +
	"\x18initiated_event_batch_id\x18\x02 \x01(\x03R\x15initiatedEventBatchId\x12(\n" +
	"\x10started_event_id\x18\x03 \x01(\x03R\x0estartedEventId\x12.\n" +
	"\x13started_workflow_id\x18\x05 \x01(\tR\x11startedWorkflowId\x12$\n" +
	"\x0estarted_run_id\x18\x06 \x01(\tR\fstartedRunId\x12*\n" +
	"\x11create_request_id\x18\b \x01(\tR\x0fcreateRequestId\x12\x1c\n" +
	"\tnamespace\x18\t \x01(\tR\tnamespace\x12,\n" +
	"\x12workflow_type_name\x18\n" +
	" \x01(\tR\x10workflowTypeName\x12X\n" +
	"\x13parent_close_policy\x18\v \x01(\x0e2(.temporal.api.enums.v1.ParentClosePolicyR\x11parentClosePolicy\x12,\n" +
	"\x12initiated_event_id\x18\f \x01(\x03R\x10initiatedEventId\x12?\n" +
	"\x05clock\x18\r \x01(\v2).temporal.server.api.clock.v1.VectorClockR\x05clock\x12!\n" +
	"\fnamespace_id\x18\x0e \x01(\tR\vnamespaceId\x12\x80\x01\n" +
	" last_update_versioned_transition\x18\x0f \x01(\v27.temporal.server.api.persistence.v1.VersionedTransitionR\x1dlastUpdateVersionedTransition\x12<\n" +
	"\bpriority\x18\x10 \x01(\v2 .temporal.api.common.v1.PriorityR\bpriorityJ\x04\b\x04\x10\x05J\x04\b\a\x10\b\"\xc3\x02\n" +
	"\x11RequestCancelInfo\x12\x18\n" +
	"\aversion\x18\x01 \x01(\x03R\aversion\x127\n" +
	"\x18initiated_event_batch_id\x18\x02 \x01(\x03R\x15initiatedEventBatchId\x12*\n" +
	"\x11cancel_request_id\x18\x03 \x01(\tR\x0fcancelRequestId\x12,\n" +
	"\x12initiated_event_id\x18\x04 \x01(\x03R\x10initiatedEventId\x12\x80\x01\n" +
	" last_update_versioned_transition\x18\x05 \x01(\v27.temporal.server.api.persistence.v1.VersionedTransitionR\x1dlastUpdateVersionedTransition\"\xc7\x02\n" +
	"\n" +
	"SignalInfo\x12\x18\n" +
	"\aversion\x18\x01 \x01(\x03R\aversion\x127\n" +
	"\x18initiated_event_batch_id\x18\x02 \x01(\x03R\x15initiatedEventBatchId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x03 \x01(\tR\trequestId\x12,\n" +
	"\x12initiated_event_id\x18\a \x01(\x03R\x10initiatedEventId\x12\x80\x01\n" +
	" last_update_versioned_transition\x18\t \x01(\v27.temporal.server.api.persistence.v1.VersionedTransitionR\x1dlastUpdateVersionedTransitionJ\x04\b\x04\x10\x05J\x04\b\x05\x10\x06J\x04\b\x06\x10\aJ\x04\b\b\x10\t\"\x80\x01\n" +
	"\bChecksum\x12\x18\n" +
	"\aversion\x18\x01 \x01(\x05R\aversion\x12D\n" +
	"\x06flavor\x18\x02 \x01(\x0e2,.temporal.server.api.enums.v1.ChecksumFlavorR\x06flavor\x12\x14\n" +
	"\x05value\x18\x03 \x01(\fR\x05value\"\x9e\x04\n" +
	"\bCallback\x12J\n" +
	"\x05nexus\x18\x02 \x01(\v22.temporal.server.api.persistence.v1.Callback.NexusH\x00R\x05nexus\x12D\n" +
	"\x03hsm\x18\x03 \x01(\v20.temporal.server.api.persistence.v1.Callback.HSMH\x00R\x03hsm\x1a\xac\x01\n" +
	"\x05Nexus\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12V\n" +
	"\x06header\x18\x02 \x03(\v2>.temporal.server.api.persistence.v1.Callback.Nexus.HeaderEntryR\x06header\x1a9\n" +
	"\vHeaderEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a\xbf\x01\n" +
	"\x03HSM\x12!\n" +
	"\fnamespace_id\x18\x01 \x01(\tR\vnamespaceId\x12\x1f\n" +
	"\vworkflow_id\x18\x02 \x01(\tR\n" +
	"workflowId\x12\x15\n" +
	"\x06run_id\x18\x03 \x01(\tR\x05runId\x12E\n" +
	"\x03ref\x18\x04 \x01(\v23.temporal.server.api.persistence.v1.StateMachineRefR\x03ref\x12\x16\n" +
	"\x06method\x18\x05 \x01(\tR\x06methodB\t\n" +
	"\avariantJ\x04\b\x01\x10\x02\"\xbb\x01\n" +
	"\x18HSMCompletionCallbackArg\x12!\n" +
	"\fnamespace_id\x18\x01 \x01(\tR\vnamespaceId\x12\x1f\n" +
	"\vworkflow_id\x18\x02 \x01(\tR\n" +
	"workflowId\x12\x15\n" +
	"\x06run_id\x18\x03 \x01(\tR\x05runId\x12D\n" +
	"\n" +
	"last_event\x18\x04 \x01(\v2%.temporal.api.history.v1.HistoryEventR\tlastEvent\"\xed\x05\n" +
	"\fCallbackInfo\x12H\n" +
	"\bcallback\x18\x01 \x01(\v2,.temporal.server.api.persistence.v1.CallbackR\bcallback\x12R\n" +
	"\atrigger\x18\x02 \x01(\v28.temporal.server.api.persistence.v1.CallbackInfo.TriggerR\atrigger\x12G\n" +
	"\x11registration_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\x10registrationTime\x12A\n" +
	"\x05state\x18\x04 \x01(\x0e2+.temporal.server.api.enums.v1.CallbackStateR\x05state\x12\x18\n" +
	"\aattempt\x18\x05 \x01(\x05R\aattempt\x12W\n" +
	"\x1alast_attempt_complete_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\x17lastAttemptCompleteTime\x12R\n" +
	"\x14last_attempt_failure\x18\a \x01(\v2 .temporal.api.failure.v1.FailureR\x12lastAttemptFailure\x12W\n" +
	"\x1anext_attempt_schedule_time\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\x17nextAttemptScheduleTime\x1a\x10\n" +
	"\x0eWorkflowClosed\x1a\x80\x01\n" +
	"\aTrigger\x12j\n" +
	"\x0fworkflow_closed\x18\x01 \x01(\v2?.temporal.server.api.persistence.v1.CallbackInfo.WorkflowClosedH\x00R\x0eworkflowClosedB\t\n" +
	"\avariant\"\x8d\x06\n" +
	"\x12NexusOperationInfo\x12\x1a\n" +
	"\bendpoint\x18\x01 \x01(\tR\bendpoint\x12\x18\n" +
	"\aservice\x18\x02 \x01(\tR\aservice\x12\x1c\n" +
	"\toperation\x18\x03 \x01(\tR\toperation\x122\n" +
	"\x15scheduled_event_token\x18\x05 \x01(\fR\x13scheduledEventToken\x12'\n" +
	"\x0foperation_token\x18\x06 \x01(\tR\x0eoperationToken\x12T\n" +
	"\x19schedule_to_close_timeout\x18\a \x01(\v2\x19.google.protobuf.DurationR\x16scheduleToCloseTimeout\x12A\n" +
	"\x0escheduled_time\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\rscheduledTime\x12\x1d\n" +
	"\n" +
	"request_id\x18\t \x01(\tR\trequestId\x12G\n" +
	"\x05state\x18\n" +
	" \x01(\x0e21.temporal.server.api.enums.v1.NexusOperationStateR\x05state\x12\x18\n" +
	"\aattempt\x18\v \x01(\x05R\aattempt\x12W\n" +
	"\x1alast_attempt_complete_time\x18\f \x01(\v2\x1a.google.protobuf.TimestampR\x17lastAttemptCompleteTime\x12R\n" +
	"\x14last_attempt_failure\x18\r \x01(\v2 .temporal.api.failure.v1.FailureR\x12lastAttemptFailure\x12W\n" +
	"\x1anext_attempt_schedule_time\x18\x0e \x01(\v2\x1a.google.protobuf.TimestampR\x17nextAttemptScheduleTime\x12\x1f\n" +
	"\vendpoint_id\x18\x0f \x01(\tR\n" +
	"endpointIdJ\x04\b\x04\x10\x05\"\xff\x03\n" +
	"\x1eNexusOperationCancellationInfo\x12A\n" +
	"\x0erequested_time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\rrequestedTime\x12L\n" +
	"\x05state\x18\x02 \x01(\x0e26.temporal.api.enums.v1.NexusOperationCancellationStateR\x05state\x12\x18\n" +
	"\aattempt\x18\x03 \x01(\x05R\aattempt\x12W\n" +
	"\x1alast_attempt_complete_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x17lastAttemptCompleteTime\x12R\n" +
	"\x14last_attempt_failure\x18\x05 \x01(\v2 .temporal.api.failure.v1.FailureR\x12lastAttemptFailure\x12W\n" +
	"\x1anext_attempt_schedule_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\x17nextAttemptScheduleTime\x12,\n" +
	"\x12requested_event_id\x18\a \x01(\x03R\x10requestedEventId\"M\n" +
	"\x0eResetChildInfo\x12;\n" +
	"\x1ashould_terminate_and_start\x18\x01 \x01(\bR\x17shouldTerminateAndStartB6Z4go.temporal.io/server/api/persistence/v1;persistenceb\x06proto3"

var (
	file_temporal_server_api_persistence_v1_executions_proto_rawDescOnce sync.Once
	file_temporal_server_api_persistence_v1_executions_proto_rawDescData []byte
)

func file_temporal_server_api_persistence_v1_executions_proto_rawDescGZIP() []byte {
	file_temporal_server_api_persistence_v1_executions_proto_rawDescOnce.Do(func() {
		file_temporal_server_api_persistence_v1_executions_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_temporal_server_api_persistence_v1_executions_proto_rawDesc), len(file_temporal_server_api_persistence_v1_executions_proto_rawDesc)))
	})
	return file_temporal_server_api_persistence_v1_executions_proto_rawDescData
}

var file_temporal_server_api_persistence_v1_executions_proto_msgTypes = make([]protoimpl.MessageInfo, 40)
var file_temporal_server_api_persistence_v1_executions_proto_goTypes = []any{
	(*ShardInfo)(nil),                      // 0: temporal.server.api.persistence.v1.ShardInfo
	(*WorkflowExecutionInfo)(nil),          // 1: temporal.server.api.persistence.v1.WorkflowExecutionInfo
	(*ExecutionStats)(nil),                 // 2: temporal.server.api.persistence.v1.ExecutionStats
	(*WorkflowExecutionState)(nil),         // 3: temporal.server.api.persistence.v1.WorkflowExecutionState
	(*RequestIDInfo)(nil),                  // 4: temporal.server.api.persistence.v1.RequestIDInfo
	(*TransferTaskInfo)(nil),               // 5: temporal.server.api.persistence.v1.TransferTaskInfo
	(*ReplicationTaskInfo)(nil),            // 6: temporal.server.api.persistence.v1.ReplicationTaskInfo
	(*VisibilityTaskInfo)(nil),             // 7: temporal.server.api.persistence.v1.VisibilityTaskInfo
	(*TimerTaskInfo)(nil),                  // 8: temporal.server.api.persistence.v1.TimerTaskInfo
	(*ArchivalTaskInfo)(nil),               // 9: temporal.server.api.persistence.v1.ArchivalTaskInfo
	(*OutboundTaskInfo)(nil),               // 10: temporal.server.api.persistence.v1.OutboundTaskInfo
	(*NexusInvocationTaskInfo)(nil),        // 11: temporal.server.api.persistence.v1.NexusInvocationTaskInfo
	(*NexusCancelationTaskInfo)(nil),       // 12: temporal.server.api.persistence.v1.NexusCancelationTaskInfo
	(*ActivityInfo)(nil),                   // 13: temporal.server.api.persistence.v1.ActivityInfo
	(*TimerInfo)(nil),                      // 14: temporal.server.api.persistence.v1.TimerInfo
	(*ChildExecutionInfo)(nil),             // 15: temporal.server.api.persistence.v1.ChildExecutionInfo
	(*RequestCancelInfo)(nil),              // 16: temporal.server.api.persistence.v1.RequestCancelInfo
	(*SignalInfo)(nil),                     // 17: temporal.server.api.persistence.v1.SignalInfo
	(*Checksum)(nil),                       // 18: temporal.server.api.persistence.v1.Checksum
	(*Callback)(nil),                       // 19: temporal.server.api.persistence.v1.Callback
	(*HSMCompletionCallbackArg)(nil),       // 20: temporal.server.api.persistence.v1.HSMCompletionCallbackArg
	(*CallbackInfo)(nil),                   // 21: temporal.server.api.persistence.v1.CallbackInfo
	(*NexusOperationInfo)(nil),             // 22: temporal.server.api.persistence.v1.NexusOperationInfo
	(*NexusOperationCancellationInfo)(nil), // 23: temporal.server.api.persistence.v1.NexusOperationCancellationInfo
	(*ResetChildInfo)(nil),                 // 24: temporal.server.api.persistence.v1.ResetChildInfo
	nil,                                    // 25: temporal.server.api.persistence.v1.ShardInfo.ReplicationDlqAckLevelEntry
	nil,                                    // 26: temporal.server.api.persistence.v1.ShardInfo.QueueStatesEntry
	nil,                                    // 27: temporal.server.api.persistence.v1.WorkflowExecutionInfo.SearchAttributesEntry
	nil,                                    // 28: temporal.server.api.persistence.v1.WorkflowExecutionInfo.MemoEntry
	nil,                                    // 29: temporal.server.api.persistence.v1.WorkflowExecutionInfo.UpdateInfosEntry
	nil,                                    // 30: temporal.server.api.persistence.v1.WorkflowExecutionInfo.SubStateMachinesByTypeEntry
	nil,                                    // 31: temporal.server.api.persistence.v1.WorkflowExecutionInfo.ChildrenInitializedPostResetPointEntry
	nil,                                    // 32: temporal.server.api.persistence.v1.WorkflowExecutionState.RequestIdsEntry
	(*TransferTaskInfo_CloseExecutionTaskDetails)(nil), // 33: temporal.server.api.persistence.v1.TransferTaskInfo.CloseExecutionTaskDetails
	(*ActivityInfo_UseWorkflowBuildIdInfo)(nil),        // 34: temporal.server.api.persistence.v1.ActivityInfo.UseWorkflowBuildIdInfo
	(*Callback_Nexus)(nil),                             // 35: temporal.server.api.persistence.v1.Callback.Nexus
	(*Callback_HSM)(nil),                               // 36: temporal.server.api.persistence.v1.Callback.HSM
	nil,                                                // 37: temporal.server.api.persistence.v1.Callback.Nexus.HeaderEntry
	(*CallbackInfo_WorkflowClosed)(nil),                // 38: temporal.server.api.persistence.v1.CallbackInfo.WorkflowClosed
	(*CallbackInfo_Trigger)(nil),                       // 39: temporal.server.api.persistence.v1.CallbackInfo.Trigger
	(*timestamppb.Timestamp)(nil),                      // 40: google.protobuf.Timestamp
	(*durationpb.Duration)(nil),                        // 41: google.protobuf.Duration
	(v1.WorkflowTaskType)(0),                           // 42: temporal.server.api.enums.v1.WorkflowTaskType
	(*v11.ResetPoints)(nil),                            // 43: temporal.api.workflow.v1.ResetPoints
	(*v13.VersionHistories)(nil),                       // 44: temporal.server.api.history.v1.VersionHistories
	(*v14.VectorClock)(nil),                            // 45: temporal.server.api.clock.v1.VectorClock
	(*v15.BaseExecutionInfo)(nil),                      // 46: temporal.server.api.workflow.v1.BaseExecutionInfo
	(*v12.WorkerVersionStamp)(nil),                     // 47: temporal.api.common.v1.WorkerVersionStamp
	(*VersionedTransition)(nil),                        // 48: temporal.server.api.persistence.v1.VersionedTransition
	(*StateMachineTimerGroup)(nil),                     // 49: temporal.server.api.persistence.v1.StateMachineTimerGroup
	(*StateMachineTombstoneBatch)(nil),                 // 50: temporal.server.api.persistence.v1.StateMachineTombstoneBatch
	(*v11.WorkflowExecutionVersioningInfo)(nil),        // 51: temporal.api.workflow.v1.WorkflowExecutionVersioningInfo
	(*v12.Priority)(nil),                               // 52: temporal.api.common.v1.Priority
	(v1.WorkflowExecutionState)(0),                     // 53: temporal.server.api.enums.v1.WorkflowExecutionState
	(v16.WorkflowExecutionStatus)(0),                   // 54: temporal.api.enums.v1.WorkflowExecutionStatus
	(v16.EventType)(0),                                 // 55: temporal.api.enums.v1.EventType
	(v1.TaskType)(0),                                   // 56: temporal.server.api.enums.v1.TaskType
	(*ChasmTaskInfo)(nil),                              // 57: temporal.server.api.persistence.v1.ChasmTaskInfo
	(v1.TaskPriority)(0),                               // 58: temporal.server.api.enums.v1.TaskPriority
	(*v13.VersionHistoryItem)(nil),                     // 59: temporal.server.api.history.v1.VersionHistoryItem
	(v16.TimeoutType)(0),                               // 60: temporal.api.enums.v1.TimeoutType
	(v1.WorkflowBackoffType)(0),                        // 61: temporal.server.api.enums.v1.WorkflowBackoffType
	(*StateMachineTaskInfo)(nil),                       // 62: temporal.server.api.persistence.v1.StateMachineTaskInfo
	(*v17.Failure)(nil),                                // 63: temporal.api.failure.v1.Failure
	(*v12.Payloads)(nil),                               // 64: temporal.api.common.v1.Payloads
	(*v12.ActivityType)(nil),                           // 65: temporal.api.common.v1.ActivityType
	(*v18.Deployment)(nil),                             // 66: temporal.api.deployment.v1.Deployment
	(v16.ParentClosePolicy)(0),                         // 67: temporal.api.enums.v1.ParentClosePolicy
	(v1.ChecksumFlavor)(0),                             // 68: temporal.server.api.enums.v1.ChecksumFlavor
	(*v19.HistoryEvent)(nil),                           // 69: temporal.api.history.v1.HistoryEvent
	(v1.CallbackState)(0),                              // 70: temporal.server.api.enums.v1.CallbackState
	(v1.NexusOperationState)(0),                        // 71: temporal.server.api.enums.v1.NexusOperationState
	(v16.NexusOperationCancellationState)(0),           // 72: temporal.api.enums.v1.NexusOperationCancellationState
	(*QueueState)(nil),                                 // 73: temporal.server.api.persistence.v1.QueueState
	(*v12.Payload)(nil),                                // 74: temporal.api.common.v1.Payload
	(*UpdateInfo)(nil),                                 // 75: temporal.server.api.persistence.v1.UpdateInfo
	(*StateMachineMap)(nil),                            // 76: temporal.server.api.persistence.v1.StateMachineMap
	(*StateMachineRef)(nil),                            // 77: temporal.server.api.persistence.v1.StateMachineRef
}
var file_temporal_server_api_persistence_v1_executions_proto_depIdxs = []int32{
	40,  // 0: temporal.server.api.persistence.v1.ShardInfo.update_time:type_name -> google.protobuf.Timestamp
	25,  // 1: temporal.server.api.persistence.v1.ShardInfo.replication_dlq_ack_level:type_name -> temporal.server.api.persistence.v1.ShardInfo.ReplicationDlqAckLevelEntry
	26,  // 2: temporal.server.api.persistence.v1.ShardInfo.queue_states:type_name -> temporal.server.api.persistence.v1.ShardInfo.QueueStatesEntry
	41,  // 3: temporal.server.api.persistence.v1.WorkflowExecutionInfo.workflow_execution_timeout:type_name -> google.protobuf.Duration
	41,  // 4: temporal.server.api.persistence.v1.WorkflowExecutionInfo.workflow_run_timeout:type_name -> google.protobuf.Duration
	41,  // 5: temporal.server.api.persistence.v1.WorkflowExecutionInfo.default_workflow_task_timeout:type_name -> google.protobuf.Duration
	40,  // 6: temporal.server.api.persistence.v1.WorkflowExecutionInfo.start_time:type_name -> google.protobuf.Timestamp
	40,  // 7: temporal.server.api.persistence.v1.WorkflowExecutionInfo.last_update_time:type_name -> google.protobuf.Timestamp
	41,  // 8: temporal.server.api.persistence.v1.WorkflowExecutionInfo.workflow_task_timeout:type_name -> google.protobuf.Duration
	40,  // 9: temporal.server.api.persistence.v1.WorkflowExecutionInfo.workflow_task_started_time:type_name -> google.protobuf.Timestamp
	40,  // 10: temporal.server.api.persistence.v1.WorkflowExecutionInfo.workflow_task_scheduled_time:type_name -> google.protobuf.Timestamp
	40,  // 11: temporal.server.api.persistence.v1.WorkflowExecutionInfo.workflow_task_original_scheduled_time:type_name -> google.protobuf.Timestamp
	42,  // 12: temporal.server.api.persistence.v1.WorkflowExecutionInfo.workflow_task_type:type_name -> temporal.server.api.enums.v1.WorkflowTaskType
	41,  // 13: temporal.server.api.persistence.v1.WorkflowExecutionInfo.sticky_schedule_to_start_timeout:type_name -> google.protobuf.Duration
	41,  // 14: temporal.server.api.persistence.v1.WorkflowExecutionInfo.retry_initial_interval:type_name -> google.protobuf.Duration
	41,  // 15: temporal.server.api.persistence.v1.WorkflowExecutionInfo.retry_maximum_interval:type_name -> google.protobuf.Duration
	40,  // 16: temporal.server.api.persistence.v1.WorkflowExecutionInfo.workflow_execution_expiration_time:type_name -> google.protobuf.Timestamp
	43,  // 17: temporal.server.api.persistence.v1.WorkflowExecutionInfo.auto_reset_points:type_name -> temporal.api.workflow.v1.ResetPoints
	27,  // 18: temporal.server.api.persistence.v1.WorkflowExecutionInfo.search_attributes:type_name -> temporal.server.api.persistence.v1.WorkflowExecutionInfo.SearchAttributesEntry
	28,  // 19: temporal.server.api.persistence.v1.WorkflowExecutionInfo.memo:type_name -> temporal.server.api.persistence.v1.WorkflowExecutionInfo.MemoEntry
	44,  // 20: temporal.server.api.persistence.v1.WorkflowExecutionInfo.version_histories:type_name -> temporal.server.api.history.v1.VersionHistories
	2,   // 21: temporal.server.api.persistence.v1.WorkflowExecutionInfo.execution_stats:type_name -> temporal.server.api.persistence.v1.ExecutionStats
	40,  // 22: temporal.server.api.persistence.v1.WorkflowExecutionInfo.workflow_run_expiration_time:type_name -> google.protobuf.Timestamp
	40,  // 23: temporal.server.api.persistence.v1.WorkflowExecutionInfo.execution_time:type_name -> google.protobuf.Timestamp
	45,  // 24: temporal.server.api.persistence.v1.WorkflowExecutionInfo.parent_clock:type_name -> temporal.server.api.clock.v1.VectorClock
	40,  // 25: temporal.server.api.persistence.v1.WorkflowExecutionInfo.close_time:type_name -> google.protobuf.Timestamp
	46,  // 26: temporal.server.api.persistence.v1.WorkflowExecutionInfo.base_execution_info:type_name -> temporal.server.api.workflow.v1.BaseExecutionInfo
	47,  // 27: temporal.server.api.persistence.v1.WorkflowExecutionInfo.most_recent_worker_version_stamp:type_name -> temporal.api.common.v1.WorkerVersionStamp
	29,  // 28: temporal.server.api.persistence.v1.WorkflowExecutionInfo.update_infos:type_name -> temporal.server.api.persistence.v1.WorkflowExecutionInfo.UpdateInfosEntry
	48,  // 29: temporal.server.api.persistence.v1.WorkflowExecutionInfo.transition_history:type_name -> temporal.server.api.persistence.v1.VersionedTransition
	30,  // 30: temporal.server.api.persistence.v1.WorkflowExecutionInfo.sub_state_machines_by_type:type_name -> temporal.server.api.persistence.v1.WorkflowExecutionInfo.SubStateMachinesByTypeEntry
	49,  // 31: temporal.server.api.persistence.v1.WorkflowExecutionInfo.state_machine_timers:type_name -> temporal.server.api.persistence.v1.StateMachineTimerGroup
	48,  // 32: temporal.server.api.persistence.v1.WorkflowExecutionInfo.workflow_task_last_update_versioned_transition:type_name -> temporal.server.api.persistence.v1.VersionedTransition
	48,  // 33: temporal.server.api.persistence.v1.WorkflowExecutionInfo.visibility_last_update_versioned_transition:type_name -> temporal.server.api.persistence.v1.VersionedTransition
	48,  // 34: temporal.server.api.persistence.v1.WorkflowExecutionInfo.signal_request_ids_last_update_versioned_transition:type_name -> temporal.server.api.persistence.v1.VersionedTransition
	50,  // 35: temporal.server.api.persistence.v1.WorkflowExecutionInfo.sub_state_machine_tombstone_batches:type_name -> temporal.server.api.persistence.v1.StateMachineTombstoneBatch
	51,  // 36: temporal.server.api.persistence.v1.WorkflowExecutionInfo.versioning_info:type_name -> temporal.api.workflow.v1.WorkflowExecutionVersioningInfo
	48,  // 37: temporal.server.api.persistence.v1.WorkflowExecutionInfo.previous_transition_history:type_name -> temporal.server.api.persistence.v1.VersionedTransition
	48,  // 38: temporal.server.api.persistence.v1.WorkflowExecutionInfo.last_transition_history_break_point:type_name -> temporal.server.api.persistence.v1.VersionedTransition
	31,  // 39: temporal.server.api.persistence.v1.WorkflowExecutionInfo.children_initialized_post_reset_point:type_name -> temporal.server.api.persistence.v1.WorkflowExecutionInfo.ChildrenInitializedPostResetPointEntry
	52,  // 40: temporal.server.api.persistence.v1.WorkflowExecutionInfo.priority:type_name -> temporal.api.common.v1.Priority
	53,  // 41: temporal.server.api.persistence.v1.WorkflowExecutionState.state:type_name -> temporal.server.api.enums.v1.WorkflowExecutionState
	54,  // 42: temporal.server.api.persistence.v1.WorkflowExecutionState.status:type_name -> temporal.api.enums.v1.WorkflowExecutionStatus
	48,  // 43: temporal.server.api.persistence.v1.WorkflowExecutionState.last_update_versioned_transition:type_name -> temporal.server.api.persistence.v1.VersionedTransition
	40,  // 44: temporal.server.api.persistence.v1.WorkflowExecutionState.start_time:type_name -> google.protobuf.Timestamp
	32,  // 45: temporal.server.api.persistence.v1.WorkflowExecutionState.request_ids:type_name -> temporal.server.api.persistence.v1.WorkflowExecutionState.RequestIdsEntry
	55,  // 46: temporal.server.api.persistence.v1.RequestIDInfo.event_type:type_name -> temporal.api.enums.v1.EventType
	56,  // 47: temporal.server.api.persistence.v1.TransferTaskInfo.task_type:type_name -> temporal.server.api.enums.v1.TaskType
	40,  // 48: temporal.server.api.persistence.v1.TransferTaskInfo.visibility_time:type_name -> google.protobuf.Timestamp
	33,  // 49: temporal.server.api.persistence.v1.TransferTaskInfo.close_execution_task_details:type_name -> temporal.server.api.persistence.v1.TransferTaskInfo.CloseExecutionTaskDetails
	57,  // 50: temporal.server.api.persistence.v1.TransferTaskInfo.chasm_task_info:type_name -> temporal.server.api.persistence.v1.ChasmTaskInfo
	56,  // 51: temporal.server.api.persistence.v1.ReplicationTaskInfo.task_type:type_name -> temporal.server.api.enums.v1.TaskType
	40,  // 52: temporal.server.api.persistence.v1.ReplicationTaskInfo.visibility_time:type_name -> google.protobuf.Timestamp
	58,  // 53: temporal.server.api.persistence.v1.ReplicationTaskInfo.priority:type_name -> temporal.server.api.enums.v1.TaskPriority
	48,  // 54: temporal.server.api.persistence.v1.ReplicationTaskInfo.versioned_transition:type_name -> temporal.server.api.persistence.v1.VersionedTransition
	6,   // 55: temporal.server.api.persistence.v1.ReplicationTaskInfo.task_equivalents:type_name -> temporal.server.api.persistence.v1.ReplicationTaskInfo
	59,  // 56: temporal.server.api.persistence.v1.ReplicationTaskInfo.last_version_history_item:type_name -> temporal.server.api.history.v1.VersionHistoryItem
	56,  // 57: temporal.server.api.persistence.v1.VisibilityTaskInfo.task_type:type_name -> temporal.server.api.enums.v1.TaskType
	40,  // 58: temporal.server.api.persistence.v1.VisibilityTaskInfo.visibility_time:type_name -> google.protobuf.Timestamp
	40,  // 59: temporal.server.api.persistence.v1.VisibilityTaskInfo.close_time:type_name -> google.protobuf.Timestamp
	56,  // 60: temporal.server.api.persistence.v1.TimerTaskInfo.task_type:type_name -> temporal.server.api.enums.v1.TaskType
	60,  // 61: temporal.server.api.persistence.v1.TimerTaskInfo.timeout_type:type_name -> temporal.api.enums.v1.TimeoutType
	61,  // 62: temporal.server.api.persistence.v1.TimerTaskInfo.workflow_backoff_type:type_name -> temporal.server.api.enums.v1.WorkflowBackoffType
	40,  // 63: temporal.server.api.persistence.v1.TimerTaskInfo.visibility_time:type_name -> google.protobuf.Timestamp
	57,  // 64: temporal.server.api.persistence.v1.TimerTaskInfo.chasm_task_info:type_name -> temporal.server.api.persistence.v1.ChasmTaskInfo
	56,  // 65: temporal.server.api.persistence.v1.ArchivalTaskInfo.task_type:type_name -> temporal.server.api.enums.v1.TaskType
	40,  // 66: temporal.server.api.persistence.v1.ArchivalTaskInfo.visibility_time:type_name -> google.protobuf.Timestamp
	56,  // 67: temporal.server.api.persistence.v1.OutboundTaskInfo.task_type:type_name -> temporal.server.api.enums.v1.TaskType
	40,  // 68: temporal.server.api.persistence.v1.OutboundTaskInfo.visibility_time:type_name -> google.protobuf.Timestamp
	62,  // 69: temporal.server.api.persistence.v1.OutboundTaskInfo.state_machine_info:type_name -> temporal.server.api.persistence.v1.StateMachineTaskInfo
	57,  // 70: temporal.server.api.persistence.v1.OutboundTaskInfo.chasm_task_info:type_name -> temporal.server.api.persistence.v1.ChasmTaskInfo
	40,  // 71: temporal.server.api.persistence.v1.ActivityInfo.scheduled_time:type_name -> google.protobuf.Timestamp
	40,  // 72: temporal.server.api.persistence.v1.ActivityInfo.started_time:type_name -> google.protobuf.Timestamp
	41,  // 73: temporal.server.api.persistence.v1.ActivityInfo.schedule_to_start_timeout:type_name -> google.protobuf.Duration
	41,  // 74: temporal.server.api.persistence.v1.ActivityInfo.schedule_to_close_timeout:type_name -> google.protobuf.Duration
	41,  // 75: temporal.server.api.persistence.v1.ActivityInfo.start_to_close_timeout:type_name -> google.protobuf.Duration
	41,  // 76: temporal.server.api.persistence.v1.ActivityInfo.heartbeat_timeout:type_name -> google.protobuf.Duration
	41,  // 77: temporal.server.api.persistence.v1.ActivityInfo.retry_initial_interval:type_name -> google.protobuf.Duration
	41,  // 78: temporal.server.api.persistence.v1.ActivityInfo.retry_maximum_interval:type_name -> google.protobuf.Duration
	40,  // 79: temporal.server.api.persistence.v1.ActivityInfo.retry_expiration_time:type_name -> google.protobuf.Timestamp
	63,  // 80: temporal.server.api.persistence.v1.ActivityInfo.retry_last_failure:type_name -> temporal.api.failure.v1.Failure
	64,  // 81: temporal.server.api.persistence.v1.ActivityInfo.last_heartbeat_details:type_name -> temporal.api.common.v1.Payloads
	40,  // 82: temporal.server.api.persistence.v1.ActivityInfo.last_heartbeat_update_time:type_name -> google.protobuf.Timestamp
	65,  // 83: temporal.server.api.persistence.v1.ActivityInfo.activity_type:type_name -> temporal.api.common.v1.ActivityType
	34,  // 84: temporal.server.api.persistence.v1.ActivityInfo.use_workflow_build_id_info:type_name -> temporal.server.api.persistence.v1.ActivityInfo.UseWorkflowBuildIdInfo
	47,  // 85: temporal.server.api.persistence.v1.ActivityInfo.last_worker_version_stamp:type_name -> temporal.api.common.v1.WorkerVersionStamp
	48,  // 86: temporal.server.api.persistence.v1.ActivityInfo.last_update_versioned_transition:type_name -> temporal.server.api.persistence.v1.VersionedTransition
	40,  // 87: temporal.server.api.persistence.v1.ActivityInfo.first_scheduled_time:type_name -> google.protobuf.Timestamp
	40,  // 88: temporal.server.api.persistence.v1.ActivityInfo.last_attempt_complete_time:type_name -> google.protobuf.Timestamp
	66,  // 89: temporal.server.api.persistence.v1.ActivityInfo.last_started_deployment:type_name -> temporal.api.deployment.v1.Deployment
	52,  // 90: temporal.server.api.persistence.v1.ActivityInfo.priority:type_name -> temporal.api.common.v1.Priority
	40,  // 91: temporal.server.api.persistence.v1.TimerInfo.expiry_time:type_name -> google.protobuf.Timestamp
	48,  // 92: temporal.server.api.persistence.v1.TimerInfo.last_update_versioned_transition:type_name -> temporal.server.api.persistence.v1.VersionedTransition
	67,  // 93: temporal.server.api.persistence.v1.ChildExecutionInfo.parent_close_policy:type_name -> temporal.api.enums.v1.ParentClosePolicy
	45,  // 94: temporal.server.api.persistence.v1.ChildExecutionInfo.clock:type_name -> temporal.server.api.clock.v1.VectorClock
	48,  // 95: temporal.server.api.persistence.v1.ChildExecutionInfo.last_update_versioned_transition:type_name -> temporal.server.api.persistence.v1.VersionedTransition
	52,  // 96: temporal.server.api.persistence.v1.ChildExecutionInfo.priority:type_name -> temporal.api.common.v1.Priority
	48,  // 97: temporal.server.api.persistence.v1.RequestCancelInfo.last_update_versioned_transition:type_name -> temporal.server.api.persistence.v1.VersionedTransition
	48,  // 98: temporal.server.api.persistence.v1.SignalInfo.last_update_versioned_transition:type_name -> temporal.server.api.persistence.v1.VersionedTransition
	68,  // 99: temporal.server.api.persistence.v1.Checksum.flavor:type_name -> temporal.server.api.enums.v1.ChecksumFlavor
	35,  // 100: temporal.server.api.persistence.v1.Callback.nexus:type_name -> temporal.server.api.persistence.v1.Callback.Nexus
	36,  // 101: temporal.server.api.persistence.v1.Callback.hsm:type_name -> temporal.server.api.persistence.v1.Callback.HSM
	69,  // 102: temporal.server.api.persistence.v1.HSMCompletionCallbackArg.last_event:type_name -> temporal.api.history.v1.HistoryEvent
	19,  // 103: temporal.server.api.persistence.v1.CallbackInfo.callback:type_name -> temporal.server.api.persistence.v1.Callback
	39,  // 104: temporal.server.api.persistence.v1.CallbackInfo.trigger:type_name -> temporal.server.api.persistence.v1.CallbackInfo.Trigger
	40,  // 105: temporal.server.api.persistence.v1.CallbackInfo.registration_time:type_name -> google.protobuf.Timestamp
	70,  // 106: temporal.server.api.persistence.v1.CallbackInfo.state:type_name -> temporal.server.api.enums.v1.CallbackState
	40,  // 107: temporal.server.api.persistence.v1.CallbackInfo.last_attempt_complete_time:type_name -> google.protobuf.Timestamp
	63,  // 108: temporal.server.api.persistence.v1.CallbackInfo.last_attempt_failure:type_name -> temporal.api.failure.v1.Failure
	40,  // 109: temporal.server.api.persistence.v1.CallbackInfo.next_attempt_schedule_time:type_name -> google.protobuf.Timestamp
	41,  // 110: temporal.server.api.persistence.v1.NexusOperationInfo.schedule_to_close_timeout:type_name -> google.protobuf.Duration
	40,  // 111: temporal.server.api.persistence.v1.NexusOperationInfo.scheduled_time:type_name -> google.protobuf.Timestamp
	71,  // 112: temporal.server.api.persistence.v1.NexusOperationInfo.state:type_name -> temporal.server.api.enums.v1.NexusOperationState
	40,  // 113: temporal.server.api.persistence.v1.NexusOperationInfo.last_attempt_complete_time:type_name -> google.protobuf.Timestamp
	63,  // 114: temporal.server.api.persistence.v1.NexusOperationInfo.last_attempt_failure:type_name -> temporal.api.failure.v1.Failure
	40,  // 115: temporal.server.api.persistence.v1.NexusOperationInfo.next_attempt_schedule_time:type_name -> google.protobuf.Timestamp
	40,  // 116: temporal.server.api.persistence.v1.NexusOperationCancellationInfo.requested_time:type_name -> google.protobuf.Timestamp
	72,  // 117: temporal.server.api.persistence.v1.NexusOperationCancellationInfo.state:type_name -> temporal.api.enums.v1.NexusOperationCancellationState
	40,  // 118: temporal.server.api.persistence.v1.NexusOperationCancellationInfo.last_attempt_complete_time:type_name -> google.protobuf.Timestamp
	63,  // 119: temporal.server.api.persistence.v1.NexusOperationCancellationInfo.last_attempt_failure:type_name -> temporal.api.failure.v1.Failure
	40,  // 120: temporal.server.api.persistence.v1.NexusOperationCancellationInfo.next_attempt_schedule_time:type_name -> google.protobuf.Timestamp
	73,  // 121: temporal.server.api.persistence.v1.ShardInfo.QueueStatesEntry.value:type_name -> temporal.server.api.persistence.v1.QueueState
	74,  // 122: temporal.server.api.persistence.v1.WorkflowExecutionInfo.SearchAttributesEntry.value:type_name -> temporal.api.common.v1.Payload
	74,  // 123: temporal.server.api.persistence.v1.WorkflowExecutionInfo.MemoEntry.value:type_name -> temporal.api.common.v1.Payload
	75,  // 124: temporal.server.api.persistence.v1.WorkflowExecutionInfo.UpdateInfosEntry.value:type_name -> temporal.server.api.persistence.v1.UpdateInfo
	76,  // 125: temporal.server.api.persistence.v1.WorkflowExecutionInfo.SubStateMachinesByTypeEntry.value:type_name -> temporal.server.api.persistence.v1.StateMachineMap
	24,  // 126: temporal.server.api.persistence.v1.WorkflowExecutionInfo.ChildrenInitializedPostResetPointEntry.value:type_name -> temporal.server.api.persistence.v1.ResetChildInfo
	4,   // 127: temporal.server.api.persistence.v1.WorkflowExecutionState.RequestIdsEntry.value:type_name -> temporal.server.api.persistence.v1.RequestIDInfo
	37,  // 128: temporal.server.api.persistence.v1.Callback.Nexus.header:type_name -> temporal.server.api.persistence.v1.Callback.Nexus.HeaderEntry
	77,  // 129: temporal.server.api.persistence.v1.Callback.HSM.ref:type_name -> temporal.server.api.persistence.v1.StateMachineRef
	38,  // 130: temporal.server.api.persistence.v1.CallbackInfo.Trigger.workflow_closed:type_name -> temporal.server.api.persistence.v1.CallbackInfo.WorkflowClosed
	131, // [131:131] is the sub-list for method output_type
	131, // [131:131] is the sub-list for method input_type
	131, // [131:131] is the sub-list for extension type_name
	131, // [131:131] is the sub-list for extension extendee
	0,   // [0:131] is the sub-list for field type_name
}

func init() { file_temporal_server_api_persistence_v1_executions_proto_init() }
func file_temporal_server_api_persistence_v1_executions_proto_init() {
	if File_temporal_server_api_persistence_v1_executions_proto != nil {
		return
	}
	file_temporal_server_api_persistence_v1_chasm_proto_init()
	file_temporal_server_api_persistence_v1_queues_proto_init()
	file_temporal_server_api_persistence_v1_hsm_proto_init()
	file_temporal_server_api_persistence_v1_update_proto_init()
	file_temporal_server_api_persistence_v1_executions_proto_msgTypes[5].OneofWrappers = []any{
		(*TransferTaskInfo_CloseExecutionTaskDetails_)(nil),
		(*TransferTaskInfo_ChasmTaskInfo)(nil),
	}
	file_temporal_server_api_persistence_v1_executions_proto_msgTypes[8].OneofWrappers = []any{
		(*TimerTaskInfo_ChasmTaskInfo)(nil),
	}
	file_temporal_server_api_persistence_v1_executions_proto_msgTypes[10].OneofWrappers = []any{
		(*OutboundTaskInfo_StateMachineInfo)(nil),
		(*OutboundTaskInfo_ChasmTaskInfo)(nil),
	}
	file_temporal_server_api_persistence_v1_executions_proto_msgTypes[13].OneofWrappers = []any{
		(*ActivityInfo_UseWorkflowBuildIdInfo_)(nil),
		(*ActivityInfo_LastIndependentlyAssignedBuildId)(nil),
	}
	file_temporal_server_api_persistence_v1_executions_proto_msgTypes[19].OneofWrappers = []any{
		(*Callback_Nexus_)(nil),
		(*Callback_Hsm)(nil),
	}
	file_temporal_server_api_persistence_v1_executions_proto_msgTypes[39].OneofWrappers = []any{
		(*CallbackInfo_Trigger_WorkflowClosed)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_temporal_server_api_persistence_v1_executions_proto_rawDesc), len(file_temporal_server_api_persistence_v1_executions_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   40,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_temporal_server_api_persistence_v1_executions_proto_goTypes,
		DependencyIndexes: file_temporal_server_api_persistence_v1_executions_proto_depIdxs,
		MessageInfos:      file_temporal_server_api_persistence_v1_executions_proto_msgTypes,
	}.Build()
	File_temporal_server_api_persistence_v1_executions_proto = out.File
	file_temporal_server_api_persistence_v1_executions_proto_goTypes = nil
	file_temporal_server_api_persistence_v1_executions_proto_depIdxs = nil
}
